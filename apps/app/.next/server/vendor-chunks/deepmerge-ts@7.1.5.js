"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/deepmerge-ts@7.1.5";
exports.ids = ["vendor-chunks/deepmerge-ts@7.1.5"];
exports.modules = {

/***/ "(ssr)/../../node_modules/.pnpm/deepmerge-ts@7.1.5/node_modules/deepmerge-ts/dist/index.mjs":
/*!********************************************************************************************!*\
  !*** ../../node_modules/.pnpm/deepmerge-ts@7.1.5/node_modules/deepmerge-ts/dist/index.mjs ***!
  \********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   deepmerge: () => (/* binding */ deepmerge),\n/* harmony export */   deepmergeCustom: () => (/* binding */ deepmergeCustom),\n/* harmony export */   deepmergeInto: () => (/* binding */ deepmergeInto),\n/* harmony export */   deepmergeIntoCustom: () => (/* binding */ deepmergeIntoCustom),\n/* harmony export */   getKeys: () => (/* binding */ getKeys),\n/* harmony export */   getObjectType: () => (/* binding */ getObjectType),\n/* harmony export */   objectHasProperty: () => (/* binding */ objectHasProperty)\n/* harmony export */ });\n/**\n * Special values that tell deepmerge to perform a certain action.\n */\nconst actions = {\n    defaultMerge: Symbol(\"deepmerge-ts: default merge\"),\n    skip: Symbol(\"deepmerge-ts: skip\"),\n};\n/**\n * Special values that tell deepmergeInto to perform a certain action.\n */\nconst actionsInto = {\n    defaultMerge: actions.defaultMerge,\n};\n\n/**\n * The default function to update meta data.\n *\n * It doesn't update the meta data.\n */\nfunction defaultMetaDataUpdater(previousMeta, metaMeta) {\n    return metaMeta;\n}\n/**\n * The default function to filter values.\n *\n * It filters out undefined values.\n */\nfunction defaultFilterValues(values, meta) {\n    return values.filter((value) => value !== undefined);\n}\n\n/**\n * The different types of objects deepmerge-ts support.\n */\nvar ObjectType;\n(function (ObjectType) {\n    ObjectType[ObjectType[\"NOT\"] = 0] = \"NOT\";\n    ObjectType[ObjectType[\"RECORD\"] = 1] = \"RECORD\";\n    ObjectType[ObjectType[\"ARRAY\"] = 2] = \"ARRAY\";\n    ObjectType[ObjectType[\"SET\"] = 3] = \"SET\";\n    ObjectType[ObjectType[\"MAP\"] = 4] = \"MAP\";\n    ObjectType[ObjectType[\"OTHER\"] = 5] = \"OTHER\";\n})(ObjectType || (ObjectType = {}));\n/**\n * Get the type of the given object.\n *\n * @param object - The object to get the type of.\n * @returns The type of the given object.\n */\nfunction getObjectType(object) {\n    if (typeof object !== \"object\" || object === null) {\n        return 0 /* ObjectType.NOT */;\n    }\n    if (Array.isArray(object)) {\n        return 2 /* ObjectType.ARRAY */;\n    }\n    if (isRecord(object)) {\n        return 1 /* ObjectType.RECORD */;\n    }\n    if (object instanceof Set) {\n        return 3 /* ObjectType.SET */;\n    }\n    if (object instanceof Map) {\n        return 4 /* ObjectType.MAP */;\n    }\n    return 5 /* ObjectType.OTHER */;\n}\n/**\n * Get the keys of the given objects including symbol keys.\n *\n * Note: Only keys to enumerable properties are returned.\n *\n * @param objects - An array of objects to get the keys of.\n * @returns A set containing all the keys of all the given objects.\n */\nfunction getKeys(objects) {\n    const keys = new Set();\n    for (const object of objects) {\n        for (const key of [...Object.keys(object), ...Object.getOwnPropertySymbols(object)]) {\n            keys.add(key);\n        }\n    }\n    return keys;\n}\n/**\n * Does the given object have the given property.\n *\n * @param object - The object to test.\n * @param property - The property to test.\n * @returns Whether the object has the property.\n */\nfunction objectHasProperty(object, property) {\n    return typeof object === \"object\" && Object.prototype.propertyIsEnumerable.call(object, property);\n}\n/**\n * Get an iterable object that iterates over the given iterables.\n */\nfunction getIterableOfIterables(iterables) {\n    let mut_iterablesIndex = 0;\n    let mut_iterator = iterables[0]?.[Symbol.iterator]();\n    return {\n        [Symbol.iterator]() {\n            return {\n                next() {\n                    do {\n                        if (mut_iterator === undefined) {\n                            return { done: true, value: undefined };\n                        }\n                        const result = mut_iterator.next();\n                        if (result.done === true) {\n                            mut_iterablesIndex += 1;\n                            mut_iterator = iterables[mut_iterablesIndex]?.[Symbol.iterator]();\n                            continue;\n                        }\n                        return {\n                            done: false,\n                            value: result.value,\n                        };\n                    } while (true);\n                },\n            };\n        },\n    };\n}\n// eslint-disable-next-line unicorn/prefer-set-has -- Array is more performant for a low number of elements.\nconst validRecordToStringValues = [\"[object Object]\", \"[object Module]\"];\n/**\n * Does the given object appear to be a record.\n */\nfunction isRecord(value) {\n    // All records are objects.\n    if (!validRecordToStringValues.includes(Object.prototype.toString.call(value))) {\n        return false;\n    }\n    const { constructor } = value;\n    // If has modified constructor.\n    // eslint-disable-next-line ts/no-unnecessary-condition\n    if (constructor === undefined) {\n        return true;\n    }\n    const prototype = constructor.prototype;\n    // If has modified prototype.\n    if (prototype === null ||\n        typeof prototype !== \"object\" ||\n        !validRecordToStringValues.includes(Object.prototype.toString.call(prototype))) {\n        return false;\n    }\n    // If constructor does not have an Object-specific method.\n    // eslint-disable-next-line sonar/prefer-single-boolean-return, no-prototype-builtins\n    if (!prototype.hasOwnProperty(\"isPrototypeOf\")) {\n        return false;\n    }\n    // Most likely a record.\n    return true;\n}\n\n/**\n * The default strategy to merge records.\n *\n * @param values - The records.\n */\nfunction mergeRecords$1(values, utils, meta) {\n    const result = {};\n    for (const key of getKeys(values)) {\n        const propValues = [];\n        for (const value of values) {\n            if (objectHasProperty(value, key)) {\n                propValues.push(value[key]);\n            }\n        }\n        if (propValues.length === 0) {\n            continue;\n        }\n        const updatedMeta = utils.metaDataUpdater(meta, {\n            key,\n            parents: values,\n        });\n        const propertyResult = mergeUnknowns(propValues, utils, updatedMeta);\n        if (propertyResult === actions.skip) {\n            continue;\n        }\n        if (key === \"__proto__\") {\n            Object.defineProperty(result, key, {\n                value: propertyResult,\n                configurable: true,\n                enumerable: true,\n                writable: true,\n            });\n        }\n        else {\n            result[key] = propertyResult;\n        }\n    }\n    return result;\n}\n/**\n * The default strategy to merge arrays.\n *\n * @param values - The arrays.\n */\nfunction mergeArrays$1(values) {\n    return values.flat();\n}\n/**\n * The default strategy to merge sets.\n *\n * @param values - The sets.\n */\nfunction mergeSets$1(values) {\n    return new Set(getIterableOfIterables(values));\n}\n/**\n * The default strategy to merge maps.\n *\n * @param values - The maps.\n */\nfunction mergeMaps$1(values) {\n    return new Map(getIterableOfIterables(values));\n}\n/**\n * Get the last value in the given array.\n */\nfunction mergeOthers$1(values) {\n    return values.at(-1);\n}\n/**\n * The merge functions.\n */\nconst mergeFunctions = {\n    mergeRecords: mergeRecords$1,\n    mergeArrays: mergeArrays$1,\n    mergeSets: mergeSets$1,\n    mergeMaps: mergeMaps$1,\n    mergeOthers: mergeOthers$1,\n};\n\n/**\n * Deeply merge objects.\n *\n * @param objects - The objects to merge.\n */\nfunction deepmerge(...objects) {\n    return deepmergeCustom({})(...objects);\n}\nfunction deepmergeCustom(options, rootMetaData) {\n    const utils = getUtils(options, customizedDeepmerge);\n    /**\n     * The customized deepmerge function.\n     */\n    function customizedDeepmerge(...objects) {\n        return mergeUnknowns(objects, utils, rootMetaData);\n    }\n    return customizedDeepmerge;\n}\n/**\n * The the utils that are available to the merge functions.\n *\n * @param options - The options the user specified\n */\nfunction getUtils(options, customizedDeepmerge) {\n    return {\n        defaultMergeFunctions: mergeFunctions,\n        mergeFunctions: {\n            ...mergeFunctions,\n            ...Object.fromEntries(Object.entries(options)\n                .filter(([key, option]) => Object.hasOwn(mergeFunctions, key))\n                .map(([key, option]) => (option === false ? [key, mergeFunctions.mergeOthers] : [key, option]))),\n        },\n        metaDataUpdater: (options.metaDataUpdater ?? defaultMetaDataUpdater),\n        deepmerge: customizedDeepmerge,\n        useImplicitDefaultMerging: options.enableImplicitDefaultMerging ?? false,\n        filterValues: options.filterValues === false ? undefined : (options.filterValues ?? defaultFilterValues),\n        actions,\n    };\n}\n/**\n * Merge unknown things.\n *\n * @param values - The values.\n */\nfunction mergeUnknowns(values, utils, meta) {\n    const filteredValues = utils.filterValues?.(values, meta) ?? values;\n    if (filteredValues.length === 0) {\n        return undefined;\n    }\n    if (filteredValues.length === 1) {\n        return mergeOthers(filteredValues, utils, meta);\n    }\n    const type = getObjectType(filteredValues[0]);\n    if (type !== 0 /* ObjectType.NOT */ && type !== 5 /* ObjectType.OTHER */) {\n        for (let mut_index = 1; mut_index < filteredValues.length; mut_index++) {\n            if (getObjectType(filteredValues[mut_index]) === type) {\n                continue;\n            }\n            return mergeOthers(filteredValues, utils, meta);\n        }\n    }\n    switch (type) {\n        case 1 /* ObjectType.RECORD */: {\n            return mergeRecords(filteredValues, utils, meta);\n        }\n        case 2 /* ObjectType.ARRAY */: {\n            return mergeArrays(filteredValues, utils, meta);\n        }\n        case 3 /* ObjectType.SET */: {\n            return mergeSets(filteredValues, utils, meta);\n        }\n        case 4 /* ObjectType.MAP */: {\n            return mergeMaps(filteredValues, utils, meta);\n        }\n        default: {\n            return mergeOthers(filteredValues, utils, meta);\n        }\n    }\n}\n/**\n * Merge records.\n *\n * @param values - The records.\n */\nfunction mergeRecords(values, utils, meta) {\n    const result = utils.mergeFunctions.mergeRecords(values, utils, meta);\n    if (result === actions.defaultMerge ||\n        (utils.useImplicitDefaultMerging &&\n            result === undefined &&\n            utils.mergeFunctions.mergeRecords !== utils.defaultMergeFunctions.mergeRecords)) {\n        return utils.defaultMergeFunctions.mergeRecords(values, utils, meta);\n    }\n    return result;\n}\n/**\n * Merge arrays.\n *\n * @param values - The arrays.\n */\nfunction mergeArrays(values, utils, meta) {\n    const result = utils.mergeFunctions.mergeArrays(values, utils, meta);\n    if (result === actions.defaultMerge ||\n        (utils.useImplicitDefaultMerging &&\n            result === undefined &&\n            utils.mergeFunctions.mergeArrays !== utils.defaultMergeFunctions.mergeArrays)) {\n        return utils.defaultMergeFunctions.mergeArrays(values);\n    }\n    return result;\n}\n/**\n * Merge sets.\n *\n * @param values - The sets.\n */\nfunction mergeSets(values, utils, meta) {\n    const result = utils.mergeFunctions.mergeSets(values, utils, meta);\n    if (result === actions.defaultMerge ||\n        (utils.useImplicitDefaultMerging &&\n            result === undefined &&\n            utils.mergeFunctions.mergeSets !== utils.defaultMergeFunctions.mergeSets)) {\n        return utils.defaultMergeFunctions.mergeSets(values);\n    }\n    return result;\n}\n/**\n * Merge maps.\n *\n * @param values - The maps.\n */\nfunction mergeMaps(values, utils, meta) {\n    const result = utils.mergeFunctions.mergeMaps(values, utils, meta);\n    if (result === actions.defaultMerge ||\n        (utils.useImplicitDefaultMerging &&\n            result === undefined &&\n            utils.mergeFunctions.mergeMaps !== utils.defaultMergeFunctions.mergeMaps)) {\n        return utils.defaultMergeFunctions.mergeMaps(values);\n    }\n    return result;\n}\n/**\n * Merge other things.\n *\n * @param values - The other things.\n */\nfunction mergeOthers(values, utils, meta) {\n    const result = utils.mergeFunctions.mergeOthers(values, utils, meta);\n    if (result === actions.defaultMerge ||\n        (utils.useImplicitDefaultMerging &&\n            result === undefined &&\n            utils.mergeFunctions.mergeOthers !== utils.defaultMergeFunctions.mergeOthers)) {\n        return utils.defaultMergeFunctions.mergeOthers(values);\n    }\n    return result;\n}\n\n/**\n * The default strategy to merge records into a target record.\n *\n * @param mut_target - The result will be mutated into this record\n * @param values - The records (including the target's value if there is one).\n */\nfunction mergeRecordsInto$1(mut_target, values, utils, meta) {\n    for (const key of getKeys(values)) {\n        const propValues = [];\n        for (const value of values) {\n            if (objectHasProperty(value, key)) {\n                propValues.push(value[key]);\n            }\n        }\n        if (propValues.length === 0) {\n            continue;\n        }\n        const updatedMeta = utils.metaDataUpdater(meta, {\n            key,\n            parents: values,\n        });\n        const propertyTarget = { value: propValues[0] };\n        mergeUnknownsInto(propertyTarget, propValues, utils, updatedMeta);\n        if (key === \"__proto__\") {\n            Object.defineProperty(mut_target.value, key, {\n                value: propertyTarget.value,\n                configurable: true,\n                enumerable: true,\n                writable: true,\n            });\n        }\n        else {\n            mut_target.value[key] = propertyTarget.value;\n        }\n    }\n}\n/**\n * The default strategy to merge arrays into a target array.\n *\n * @param mut_target - The result will be mutated into this array\n * @param values - The arrays (including the target's value if there is one).\n */\nfunction mergeArraysInto$1(mut_target, values) {\n    mut_target.value.push(...values.slice(1).flat());\n}\n/**\n * The default strategy to merge sets into a target set.\n *\n * @param mut_target - The result will be mutated into this set\n * @param values - The sets (including the target's value if there is one).\n */\nfunction mergeSetsInto$1(mut_target, values) {\n    for (const value of getIterableOfIterables(values.slice(1))) {\n        mut_target.value.add(value);\n    }\n}\n/**\n * The default strategy to merge maps into a target map.\n *\n * @param mut_target - The result will be mutated into this map\n * @param values - The maps (including the target's value if there is one).\n */\nfunction mergeMapsInto$1(mut_target, values) {\n    for (const [key, value] of getIterableOfIterables(values.slice(1))) {\n        mut_target.value.set(key, value);\n    }\n}\n/**\n * Set the target to the last value.\n */\nfunction mergeOthersInto$1(mut_target, values) {\n    mut_target.value = values.at(-1);\n}\n/**\n * The merge functions.\n */\nconst mergeIntoFunctions = {\n    mergeRecords: mergeRecordsInto$1,\n    mergeArrays: mergeArraysInto$1,\n    mergeSets: mergeSetsInto$1,\n    mergeMaps: mergeMapsInto$1,\n    mergeOthers: mergeOthersInto$1,\n};\n\nfunction deepmergeInto(target, ...objects) {\n    return void deepmergeIntoCustom({})(target, ...objects);\n}\nfunction deepmergeIntoCustom(options, rootMetaData) {\n    const utils = getIntoUtils(options, customizedDeepmergeInto);\n    /**\n     * The customized deepmerge function.\n     */\n    function customizedDeepmergeInto(target, ...objects) {\n        mergeUnknownsInto({ value: target }, [target, ...objects], utils, rootMetaData);\n    }\n    return customizedDeepmergeInto;\n}\n/**\n * The the utils that are available to the merge functions.\n *\n * @param options - The options the user specified\n */\nfunction getIntoUtils(options, customizedDeepmergeInto) {\n    return {\n        defaultMergeFunctions: mergeIntoFunctions,\n        mergeFunctions: {\n            ...mergeIntoFunctions,\n            ...Object.fromEntries(Object.entries(options)\n                .filter(([key, option]) => Object.hasOwn(mergeIntoFunctions, key))\n                .map(([key, option]) => (option === false ? [key, mergeIntoFunctions.mergeOthers] : [key, option]))),\n        },\n        metaDataUpdater: (options.metaDataUpdater ?? defaultMetaDataUpdater),\n        deepmergeInto: customizedDeepmergeInto,\n        filterValues: options.filterValues === false ? undefined : (options.filterValues ?? defaultFilterValues),\n        actions: actionsInto,\n    };\n}\n/**\n * Merge unknown things into a target.\n *\n * @param mut_target - The target to merge into.\n * @param values - The values.\n */\nfunction mergeUnknownsInto(mut_target, values, utils, meta) {\n    const filteredValues = utils.filterValues?.(values, meta) ?? values;\n    if (filteredValues.length === 0) {\n        return;\n    }\n    if (filteredValues.length === 1) {\n        return void mergeOthersInto(mut_target, filteredValues, utils, meta);\n    }\n    const type = getObjectType(mut_target.value);\n    if (type !== 0 /* ObjectType.NOT */ && type !== 5 /* ObjectType.OTHER */) {\n        for (let mut_index = 1; mut_index < filteredValues.length; mut_index++) {\n            if (getObjectType(filteredValues[mut_index]) === type) {\n                continue;\n            }\n            return void mergeOthersInto(mut_target, filteredValues, utils, meta);\n        }\n    }\n    switch (type) {\n        case 1 /* ObjectType.RECORD */: {\n            return void mergeRecordsInto(mut_target, filteredValues, utils, meta);\n        }\n        case 2 /* ObjectType.ARRAY */: {\n            return void mergeArraysInto(mut_target, filteredValues, utils, meta);\n        }\n        case 3 /* ObjectType.SET */: {\n            return void mergeSetsInto(mut_target, filteredValues, utils, meta);\n        }\n        case 4 /* ObjectType.MAP */: {\n            return void mergeMapsInto(mut_target, filteredValues, utils, meta);\n        }\n        default: {\n            return void mergeOthersInto(mut_target, filteredValues, utils, meta);\n        }\n    }\n}\n/**\n * Merge records into a target record.\n *\n * @param mut_target - The target to merge into.\n * @param values - The records.\n */\nfunction mergeRecordsInto(mut_target, values, utils, meta) {\n    const action = utils.mergeFunctions.mergeRecords(mut_target, values, utils, meta);\n    if (action === actionsInto.defaultMerge) {\n        utils.defaultMergeFunctions.mergeRecords(mut_target, values, utils, meta);\n    }\n}\n/**\n * Merge arrays into a target array.\n *\n * @param mut_target - The target to merge into.\n * @param values - The arrays.\n */\nfunction mergeArraysInto(mut_target, values, utils, meta) {\n    const action = utils.mergeFunctions.mergeArrays(mut_target, values, utils, meta);\n    if (action === actionsInto.defaultMerge) {\n        utils.defaultMergeFunctions.mergeArrays(mut_target, values);\n    }\n}\n/**\n * Merge sets into a target set.\n *\n * @param mut_target - The target to merge into.\n * @param values - The sets.\n */\nfunction mergeSetsInto(mut_target, values, utils, meta) {\n    const action = utils.mergeFunctions.mergeSets(mut_target, values, utils, meta);\n    if (action === actionsInto.defaultMerge) {\n        utils.defaultMergeFunctions.mergeSets(mut_target, values);\n    }\n}\n/**\n * Merge maps into a target map.\n *\n * @param mut_target - The target to merge into.\n * @param values - The maps.\n */\nfunction mergeMapsInto(mut_target, values, utils, meta) {\n    const action = utils.mergeFunctions.mergeMaps(mut_target, values, utils, meta);\n    if (action === actionsInto.defaultMerge) {\n        utils.defaultMergeFunctions.mergeMaps(mut_target, values);\n    }\n}\n/**\n * Merge other things into a target.\n *\n * @param mut_target - The target to merge into.\n * @param values - The other things.\n */\nfunction mergeOthersInto(mut_target, values, utils, meta) {\n    const action = utils.mergeFunctions.mergeOthers(mut_target, values, utils, meta);\n    if (action === actionsInto.defaultMerge || mut_target.value === actionsInto.defaultMerge) {\n        utils.defaultMergeFunctions.mergeOthers(mut_target, values);\n    }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2RlZXBtZXJnZS10c0A3LjEuNS9ub2RlX21vZHVsZXMvZGVlcG1lcmdlLXRzL2Rpc3QvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxnQ0FBZ0M7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEIsaUJBQWlCO0FBQ2pCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksY0FBYztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLG1DQUFtQztBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixlQUFlO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLG1DQUFtQztBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRXFIIiwic291cmNlcyI6WyIvaG9tZS9ydW5uZXIvd29ya3NwYWNlL25vZGVfbW9kdWxlcy8ucG5wbS9kZWVwbWVyZ2UtdHNANy4xLjUvbm9kZV9tb2R1bGVzL2RlZXBtZXJnZS10cy9kaXN0L2luZGV4Lm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFNwZWNpYWwgdmFsdWVzIHRoYXQgdGVsbCBkZWVwbWVyZ2UgdG8gcGVyZm9ybSBhIGNlcnRhaW4gYWN0aW9uLlxuICovXG5jb25zdCBhY3Rpb25zID0ge1xuICAgIGRlZmF1bHRNZXJnZTogU3ltYm9sKFwiZGVlcG1lcmdlLXRzOiBkZWZhdWx0IG1lcmdlXCIpLFxuICAgIHNraXA6IFN5bWJvbChcImRlZXBtZXJnZS10czogc2tpcFwiKSxcbn07XG4vKipcbiAqIFNwZWNpYWwgdmFsdWVzIHRoYXQgdGVsbCBkZWVwbWVyZ2VJbnRvIHRvIHBlcmZvcm0gYSBjZXJ0YWluIGFjdGlvbi5cbiAqL1xuY29uc3QgYWN0aW9uc0ludG8gPSB7XG4gICAgZGVmYXVsdE1lcmdlOiBhY3Rpb25zLmRlZmF1bHRNZXJnZSxcbn07XG5cbi8qKlxuICogVGhlIGRlZmF1bHQgZnVuY3Rpb24gdG8gdXBkYXRlIG1ldGEgZGF0YS5cbiAqXG4gKiBJdCBkb2Vzbid0IHVwZGF0ZSB0aGUgbWV0YSBkYXRhLlxuICovXG5mdW5jdGlvbiBkZWZhdWx0TWV0YURhdGFVcGRhdGVyKHByZXZpb3VzTWV0YSwgbWV0YU1ldGEpIHtcbiAgICByZXR1cm4gbWV0YU1ldGE7XG59XG4vKipcbiAqIFRoZSBkZWZhdWx0IGZ1bmN0aW9uIHRvIGZpbHRlciB2YWx1ZXMuXG4gKlxuICogSXQgZmlsdGVycyBvdXQgdW5kZWZpbmVkIHZhbHVlcy5cbiAqL1xuZnVuY3Rpb24gZGVmYXVsdEZpbHRlclZhbHVlcyh2YWx1ZXMsIG1ldGEpIHtcbiAgICByZXR1cm4gdmFsdWVzLmZpbHRlcigodmFsdWUpID0+IHZhbHVlICE9PSB1bmRlZmluZWQpO1xufVxuXG4vKipcbiAqIFRoZSBkaWZmZXJlbnQgdHlwZXMgb2Ygb2JqZWN0cyBkZWVwbWVyZ2UtdHMgc3VwcG9ydC5cbiAqL1xudmFyIE9iamVjdFR5cGU7XG4oZnVuY3Rpb24gKE9iamVjdFR5cGUpIHtcbiAgICBPYmplY3RUeXBlW09iamVjdFR5cGVbXCJOT1RcIl0gPSAwXSA9IFwiTk9UXCI7XG4gICAgT2JqZWN0VHlwZVtPYmplY3RUeXBlW1wiUkVDT1JEXCJdID0gMV0gPSBcIlJFQ09SRFwiO1xuICAgIE9iamVjdFR5cGVbT2JqZWN0VHlwZVtcIkFSUkFZXCJdID0gMl0gPSBcIkFSUkFZXCI7XG4gICAgT2JqZWN0VHlwZVtPYmplY3RUeXBlW1wiU0VUXCJdID0gM10gPSBcIlNFVFwiO1xuICAgIE9iamVjdFR5cGVbT2JqZWN0VHlwZVtcIk1BUFwiXSA9IDRdID0gXCJNQVBcIjtcbiAgICBPYmplY3RUeXBlW09iamVjdFR5cGVbXCJPVEhFUlwiXSA9IDVdID0gXCJPVEhFUlwiO1xufSkoT2JqZWN0VHlwZSB8fCAoT2JqZWN0VHlwZSA9IHt9KSk7XG4vKipcbiAqIEdldCB0aGUgdHlwZSBvZiB0aGUgZ2l2ZW4gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSBvYmplY3QgLSBUaGUgb2JqZWN0IHRvIGdldCB0aGUgdHlwZSBvZi5cbiAqIEByZXR1cm5zIFRoZSB0eXBlIG9mIHRoZSBnaXZlbiBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGdldE9iamVjdFR5cGUob2JqZWN0KSB7XG4gICAgaWYgKHR5cGVvZiBvYmplY3QgIT09IFwib2JqZWN0XCIgfHwgb2JqZWN0ID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAwIC8qIE9iamVjdFR5cGUuTk9UICovO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheShvYmplY3QpKSB7XG4gICAgICAgIHJldHVybiAyIC8qIE9iamVjdFR5cGUuQVJSQVkgKi87XG4gICAgfVxuICAgIGlmIChpc1JlY29yZChvYmplY3QpKSB7XG4gICAgICAgIHJldHVybiAxIC8qIE9iamVjdFR5cGUuUkVDT1JEICovO1xuICAgIH1cbiAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgU2V0KSB7XG4gICAgICAgIHJldHVybiAzIC8qIE9iamVjdFR5cGUuU0VUICovO1xuICAgIH1cbiAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgTWFwKSB7XG4gICAgICAgIHJldHVybiA0IC8qIE9iamVjdFR5cGUuTUFQICovO1xuICAgIH1cbiAgICByZXR1cm4gNSAvKiBPYmplY3RUeXBlLk9USEVSICovO1xufVxuLyoqXG4gKiBHZXQgdGhlIGtleXMgb2YgdGhlIGdpdmVuIG9iamVjdHMgaW5jbHVkaW5nIHN5bWJvbCBrZXlzLlxuICpcbiAqIE5vdGU6IE9ubHkga2V5cyB0byBlbnVtZXJhYmxlIHByb3BlcnRpZXMgYXJlIHJldHVybmVkLlxuICpcbiAqIEBwYXJhbSBvYmplY3RzIC0gQW4gYXJyYXkgb2Ygb2JqZWN0cyB0byBnZXQgdGhlIGtleXMgb2YuXG4gKiBAcmV0dXJucyBBIHNldCBjb250YWluaW5nIGFsbCB0aGUga2V5cyBvZiBhbGwgdGhlIGdpdmVuIG9iamVjdHMuXG4gKi9cbmZ1bmN0aW9uIGdldEtleXMob2JqZWN0cykge1xuICAgIGNvbnN0IGtleXMgPSBuZXcgU2V0KCk7XG4gICAgZm9yIChjb25zdCBvYmplY3Qgb2Ygb2JqZWN0cykge1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBbLi4uT2JqZWN0LmtleXMob2JqZWN0KSwgLi4uT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpXSkge1xuICAgICAgICAgICAga2V5cy5hZGQoa2V5KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ga2V5cztcbn1cbi8qKlxuICogRG9lcyB0aGUgZ2l2ZW4gb2JqZWN0IGhhdmUgdGhlIGdpdmVuIHByb3BlcnR5LlxuICpcbiAqIEBwYXJhbSBvYmplY3QgLSBUaGUgb2JqZWN0IHRvIHRlc3QuXG4gKiBAcGFyYW0gcHJvcGVydHkgLSBUaGUgcHJvcGVydHkgdG8gdGVzdC5cbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIG9iamVjdCBoYXMgdGhlIHByb3BlcnR5LlxuICovXG5mdW5jdGlvbiBvYmplY3RIYXNQcm9wZXJ0eShvYmplY3QsIHByb3BlcnR5KSB7XG4gICAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09IFwib2JqZWN0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKG9iamVjdCwgcHJvcGVydHkpO1xufVxuLyoqXG4gKiBHZXQgYW4gaXRlcmFibGUgb2JqZWN0IHRoYXQgaXRlcmF0ZXMgb3ZlciB0aGUgZ2l2ZW4gaXRlcmFibGVzLlxuICovXG5mdW5jdGlvbiBnZXRJdGVyYWJsZU9mSXRlcmFibGVzKGl0ZXJhYmxlcykge1xuICAgIGxldCBtdXRfaXRlcmFibGVzSW5kZXggPSAwO1xuICAgIGxldCBtdXRfaXRlcmF0b3IgPSBpdGVyYWJsZXNbMF0/LltTeW1ib2wuaXRlcmF0b3JdKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG5leHQoKSB7XG4gICAgICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtdXRfaXRlcmF0b3IgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGRvbmU6IHRydWUsIHZhbHVlOiB1bmRlZmluZWQgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IG11dF9pdGVyYXRvci5uZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0LmRvbmUgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtdXRfaXRlcmFibGVzSW5kZXggKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtdXRfaXRlcmF0b3IgPSBpdGVyYWJsZXNbbXV0X2l0ZXJhYmxlc0luZGV4XT8uW1N5bWJvbC5pdGVyYXRvcl0oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9uZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHJlc3VsdC52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKHRydWUpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgIH07XG59XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgdW5pY29ybi9wcmVmZXItc2V0LWhhcyAtLSBBcnJheSBpcyBtb3JlIHBlcmZvcm1hbnQgZm9yIGEgbG93IG51bWJlciBvZiBlbGVtZW50cy5cbmNvbnN0IHZhbGlkUmVjb3JkVG9TdHJpbmdWYWx1ZXMgPSBbXCJbb2JqZWN0IE9iamVjdF1cIiwgXCJbb2JqZWN0IE1vZHVsZV1cIl07XG4vKipcbiAqIERvZXMgdGhlIGdpdmVuIG9iamVjdCBhcHBlYXIgdG8gYmUgYSByZWNvcmQuXG4gKi9cbmZ1bmN0aW9uIGlzUmVjb3JkKHZhbHVlKSB7XG4gICAgLy8gQWxsIHJlY29yZHMgYXJlIG9iamVjdHMuXG4gICAgaWYgKCF2YWxpZFJlY29yZFRvU3RyaW5nVmFsdWVzLmluY2x1ZGVzKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgeyBjb25zdHJ1Y3RvciB9ID0gdmFsdWU7XG4gICAgLy8gSWYgaGFzIG1vZGlmaWVkIGNvbnN0cnVjdG9yLlxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSB0cy9uby11bm5lY2Vzc2FyeS1jb25kaXRpb25cbiAgICBpZiAoY29uc3RydWN0b3IgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3QgcHJvdG90eXBlID0gY29uc3RydWN0b3IucHJvdG90eXBlO1xuICAgIC8vIElmIGhhcyBtb2RpZmllZCBwcm90b3R5cGUuXG4gICAgaWYgKHByb3RvdHlwZSA9PT0gbnVsbCB8fFxuICAgICAgICB0eXBlb2YgcHJvdG90eXBlICE9PSBcIm9iamVjdFwiIHx8XG4gICAgICAgICF2YWxpZFJlY29yZFRvU3RyaW5nVmFsdWVzLmluY2x1ZGVzKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChwcm90b3R5cGUpKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIElmIGNvbnN0cnVjdG9yIGRvZXMgbm90IGhhdmUgYW4gT2JqZWN0LXNwZWNpZmljIG1ldGhvZC5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgc29uYXIvcHJlZmVyLXNpbmdsZS1ib29sZWFuLXJldHVybiwgbm8tcHJvdG90eXBlLWJ1aWx0aW5zXG4gICAgaWYgKCFwcm90b3R5cGUuaGFzT3duUHJvcGVydHkoXCJpc1Byb3RvdHlwZU9mXCIpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gTW9zdCBsaWtlbHkgYSByZWNvcmQuXG4gICAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogVGhlIGRlZmF1bHQgc3RyYXRlZ3kgdG8gbWVyZ2UgcmVjb3Jkcy5cbiAqXG4gKiBAcGFyYW0gdmFsdWVzIC0gVGhlIHJlY29yZHMuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlUmVjb3JkcyQxKHZhbHVlcywgdXRpbHMsIG1ldGEpIHtcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBnZXRLZXlzKHZhbHVlcykpIHtcbiAgICAgICAgY29uc3QgcHJvcFZhbHVlcyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIHZhbHVlcykge1xuICAgICAgICAgICAgaWYgKG9iamVjdEhhc1Byb3BlcnR5KHZhbHVlLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgcHJvcFZhbHVlcy5wdXNoKHZhbHVlW2tleV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9wVmFsdWVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXBkYXRlZE1ldGEgPSB1dGlscy5tZXRhRGF0YVVwZGF0ZXIobWV0YSwge1xuICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgcGFyZW50czogdmFsdWVzLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcHJvcGVydHlSZXN1bHQgPSBtZXJnZVVua25vd25zKHByb3BWYWx1ZXMsIHV0aWxzLCB1cGRhdGVkTWV0YSk7XG4gICAgICAgIGlmIChwcm9wZXJ0eVJlc3VsdCA9PT0gYWN0aW9ucy5za2lwKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoa2V5ID09PSBcIl9fcHJvdG9fX1wiKSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVzdWx0LCBrZXksIHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogcHJvcGVydHlSZXN1bHQsXG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdFtrZXldID0gcHJvcGVydHlSZXN1bHQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogVGhlIGRlZmF1bHQgc3RyYXRlZ3kgdG8gbWVyZ2UgYXJyYXlzLlxuICpcbiAqIEBwYXJhbSB2YWx1ZXMgLSBUaGUgYXJyYXlzLlxuICovXG5mdW5jdGlvbiBtZXJnZUFycmF5cyQxKHZhbHVlcykge1xuICAgIHJldHVybiB2YWx1ZXMuZmxhdCgpO1xufVxuLyoqXG4gKiBUaGUgZGVmYXVsdCBzdHJhdGVneSB0byBtZXJnZSBzZXRzLlxuICpcbiAqIEBwYXJhbSB2YWx1ZXMgLSBUaGUgc2V0cy5cbiAqL1xuZnVuY3Rpb24gbWVyZ2VTZXRzJDEodmFsdWVzKSB7XG4gICAgcmV0dXJuIG5ldyBTZXQoZ2V0SXRlcmFibGVPZkl0ZXJhYmxlcyh2YWx1ZXMpKTtcbn1cbi8qKlxuICogVGhlIGRlZmF1bHQgc3RyYXRlZ3kgdG8gbWVyZ2UgbWFwcy5cbiAqXG4gKiBAcGFyYW0gdmFsdWVzIC0gVGhlIG1hcHMuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlTWFwcyQxKHZhbHVlcykge1xuICAgIHJldHVybiBuZXcgTWFwKGdldEl0ZXJhYmxlT2ZJdGVyYWJsZXModmFsdWVzKSk7XG59XG4vKipcbiAqIEdldCB0aGUgbGFzdCB2YWx1ZSBpbiB0aGUgZ2l2ZW4gYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlT3RoZXJzJDEodmFsdWVzKSB7XG4gICAgcmV0dXJuIHZhbHVlcy5hdCgtMSk7XG59XG4vKipcbiAqIFRoZSBtZXJnZSBmdW5jdGlvbnMuXG4gKi9cbmNvbnN0IG1lcmdlRnVuY3Rpb25zID0ge1xuICAgIG1lcmdlUmVjb3JkczogbWVyZ2VSZWNvcmRzJDEsXG4gICAgbWVyZ2VBcnJheXM6IG1lcmdlQXJyYXlzJDEsXG4gICAgbWVyZ2VTZXRzOiBtZXJnZVNldHMkMSxcbiAgICBtZXJnZU1hcHM6IG1lcmdlTWFwcyQxLFxuICAgIG1lcmdlT3RoZXJzOiBtZXJnZU90aGVycyQxLFxufTtcblxuLyoqXG4gKiBEZWVwbHkgbWVyZ2Ugb2JqZWN0cy5cbiAqXG4gKiBAcGFyYW0gb2JqZWN0cyAtIFRoZSBvYmplY3RzIHRvIG1lcmdlLlxuICovXG5mdW5jdGlvbiBkZWVwbWVyZ2UoLi4ub2JqZWN0cykge1xuICAgIHJldHVybiBkZWVwbWVyZ2VDdXN0b20oe30pKC4uLm9iamVjdHMpO1xufVxuZnVuY3Rpb24gZGVlcG1lcmdlQ3VzdG9tKG9wdGlvbnMsIHJvb3RNZXRhRGF0YSkge1xuICAgIGNvbnN0IHV0aWxzID0gZ2V0VXRpbHMob3B0aW9ucywgY3VzdG9taXplZERlZXBtZXJnZSk7XG4gICAgLyoqXG4gICAgICogVGhlIGN1c3RvbWl6ZWQgZGVlcG1lcmdlIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGN1c3RvbWl6ZWREZWVwbWVyZ2UoLi4ub2JqZWN0cykge1xuICAgICAgICByZXR1cm4gbWVyZ2VVbmtub3ducyhvYmplY3RzLCB1dGlscywgcm9vdE1ldGFEYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIGN1c3RvbWl6ZWREZWVwbWVyZ2U7XG59XG4vKipcbiAqIFRoZSB0aGUgdXRpbHMgdGhhdCBhcmUgYXZhaWxhYmxlIHRvIHRoZSBtZXJnZSBmdW5jdGlvbnMuXG4gKlxuICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgb3B0aW9ucyB0aGUgdXNlciBzcGVjaWZpZWRcbiAqL1xuZnVuY3Rpb24gZ2V0VXRpbHMob3B0aW9ucywgY3VzdG9taXplZERlZXBtZXJnZSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGRlZmF1bHRNZXJnZUZ1bmN0aW9uczogbWVyZ2VGdW5jdGlvbnMsXG4gICAgICAgIG1lcmdlRnVuY3Rpb25zOiB7XG4gICAgICAgICAgICAuLi5tZXJnZUZ1bmN0aW9ucyxcbiAgICAgICAgICAgIC4uLk9iamVjdC5mcm9tRW50cmllcyhPYmplY3QuZW50cmllcyhvcHRpb25zKVxuICAgICAgICAgICAgICAgIC5maWx0ZXIoKFtrZXksIG9wdGlvbl0pID0+IE9iamVjdC5oYXNPd24obWVyZ2VGdW5jdGlvbnMsIGtleSkpXG4gICAgICAgICAgICAgICAgLm1hcCgoW2tleSwgb3B0aW9uXSkgPT4gKG9wdGlvbiA9PT0gZmFsc2UgPyBba2V5LCBtZXJnZUZ1bmN0aW9ucy5tZXJnZU90aGVyc10gOiBba2V5LCBvcHRpb25dKSkpLFxuICAgICAgICB9LFxuICAgICAgICBtZXRhRGF0YVVwZGF0ZXI6IChvcHRpb25zLm1ldGFEYXRhVXBkYXRlciA/PyBkZWZhdWx0TWV0YURhdGFVcGRhdGVyKSxcbiAgICAgICAgZGVlcG1lcmdlOiBjdXN0b21pemVkRGVlcG1lcmdlLFxuICAgICAgICB1c2VJbXBsaWNpdERlZmF1bHRNZXJnaW5nOiBvcHRpb25zLmVuYWJsZUltcGxpY2l0RGVmYXVsdE1lcmdpbmcgPz8gZmFsc2UsXG4gICAgICAgIGZpbHRlclZhbHVlczogb3B0aW9ucy5maWx0ZXJWYWx1ZXMgPT09IGZhbHNlID8gdW5kZWZpbmVkIDogKG9wdGlvbnMuZmlsdGVyVmFsdWVzID8/IGRlZmF1bHRGaWx0ZXJWYWx1ZXMpLFxuICAgICAgICBhY3Rpb25zLFxuICAgIH07XG59XG4vKipcbiAqIE1lcmdlIHVua25vd24gdGhpbmdzLlxuICpcbiAqIEBwYXJhbSB2YWx1ZXMgLSBUaGUgdmFsdWVzLlxuICovXG5mdW5jdGlvbiBtZXJnZVVua25vd25zKHZhbHVlcywgdXRpbHMsIG1ldGEpIHtcbiAgICBjb25zdCBmaWx0ZXJlZFZhbHVlcyA9IHV0aWxzLmZpbHRlclZhbHVlcz8uKHZhbHVlcywgbWV0YSkgPz8gdmFsdWVzO1xuICAgIGlmIChmaWx0ZXJlZFZhbHVlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaWYgKGZpbHRlcmVkVmFsdWVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4gbWVyZ2VPdGhlcnMoZmlsdGVyZWRWYWx1ZXMsIHV0aWxzLCBtZXRhKTtcbiAgICB9XG4gICAgY29uc3QgdHlwZSA9IGdldE9iamVjdFR5cGUoZmlsdGVyZWRWYWx1ZXNbMF0pO1xuICAgIGlmICh0eXBlICE9PSAwIC8qIE9iamVjdFR5cGUuTk9UICovICYmIHR5cGUgIT09IDUgLyogT2JqZWN0VHlwZS5PVEhFUiAqLykge1xuICAgICAgICBmb3IgKGxldCBtdXRfaW5kZXggPSAxOyBtdXRfaW5kZXggPCBmaWx0ZXJlZFZhbHVlcy5sZW5ndGg7IG11dF9pbmRleCsrKSB7XG4gICAgICAgICAgICBpZiAoZ2V0T2JqZWN0VHlwZShmaWx0ZXJlZFZhbHVlc1ttdXRfaW5kZXhdKSA9PT0gdHlwZSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1lcmdlT3RoZXJzKGZpbHRlcmVkVmFsdWVzLCB1dGlscywgbWV0YSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgMSAvKiBPYmplY3RUeXBlLlJFQ09SRCAqLzoge1xuICAgICAgICAgICAgcmV0dXJuIG1lcmdlUmVjb3JkcyhmaWx0ZXJlZFZhbHVlcywgdXRpbHMsIG1ldGEpO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgMiAvKiBPYmplY3RUeXBlLkFSUkFZICovOiB7XG4gICAgICAgICAgICByZXR1cm4gbWVyZ2VBcnJheXMoZmlsdGVyZWRWYWx1ZXMsIHV0aWxzLCBtZXRhKTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIDMgLyogT2JqZWN0VHlwZS5TRVQgKi86IHtcbiAgICAgICAgICAgIHJldHVybiBtZXJnZVNldHMoZmlsdGVyZWRWYWx1ZXMsIHV0aWxzLCBtZXRhKTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIDQgLyogT2JqZWN0VHlwZS5NQVAgKi86IHtcbiAgICAgICAgICAgIHJldHVybiBtZXJnZU1hcHMoZmlsdGVyZWRWYWx1ZXMsIHV0aWxzLCBtZXRhKTtcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICByZXR1cm4gbWVyZ2VPdGhlcnMoZmlsdGVyZWRWYWx1ZXMsIHV0aWxzLCBtZXRhKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogTWVyZ2UgcmVjb3Jkcy5cbiAqXG4gKiBAcGFyYW0gdmFsdWVzIC0gVGhlIHJlY29yZHMuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlUmVjb3Jkcyh2YWx1ZXMsIHV0aWxzLCBtZXRhKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gdXRpbHMubWVyZ2VGdW5jdGlvbnMubWVyZ2VSZWNvcmRzKHZhbHVlcywgdXRpbHMsIG1ldGEpO1xuICAgIGlmIChyZXN1bHQgPT09IGFjdGlvbnMuZGVmYXVsdE1lcmdlIHx8XG4gICAgICAgICh1dGlscy51c2VJbXBsaWNpdERlZmF1bHRNZXJnaW5nICYmXG4gICAgICAgICAgICByZXN1bHQgPT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgdXRpbHMubWVyZ2VGdW5jdGlvbnMubWVyZ2VSZWNvcmRzICE9PSB1dGlscy5kZWZhdWx0TWVyZ2VGdW5jdGlvbnMubWVyZ2VSZWNvcmRzKSkge1xuICAgICAgICByZXR1cm4gdXRpbHMuZGVmYXVsdE1lcmdlRnVuY3Rpb25zLm1lcmdlUmVjb3Jkcyh2YWx1ZXMsIHV0aWxzLCBtZXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogTWVyZ2UgYXJyYXlzLlxuICpcbiAqIEBwYXJhbSB2YWx1ZXMgLSBUaGUgYXJyYXlzLlxuICovXG5mdW5jdGlvbiBtZXJnZUFycmF5cyh2YWx1ZXMsIHV0aWxzLCBtZXRhKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gdXRpbHMubWVyZ2VGdW5jdGlvbnMubWVyZ2VBcnJheXModmFsdWVzLCB1dGlscywgbWV0YSk7XG4gICAgaWYgKHJlc3VsdCA9PT0gYWN0aW9ucy5kZWZhdWx0TWVyZ2UgfHxcbiAgICAgICAgKHV0aWxzLnVzZUltcGxpY2l0RGVmYXVsdE1lcmdpbmcgJiZcbiAgICAgICAgICAgIHJlc3VsdCA9PT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICB1dGlscy5tZXJnZUZ1bmN0aW9ucy5tZXJnZUFycmF5cyAhPT0gdXRpbHMuZGVmYXVsdE1lcmdlRnVuY3Rpb25zLm1lcmdlQXJyYXlzKSkge1xuICAgICAgICByZXR1cm4gdXRpbHMuZGVmYXVsdE1lcmdlRnVuY3Rpb25zLm1lcmdlQXJyYXlzKHZhbHVlcyk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqIE1lcmdlIHNldHMuXG4gKlxuICogQHBhcmFtIHZhbHVlcyAtIFRoZSBzZXRzLlxuICovXG5mdW5jdGlvbiBtZXJnZVNldHModmFsdWVzLCB1dGlscywgbWV0YSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHV0aWxzLm1lcmdlRnVuY3Rpb25zLm1lcmdlU2V0cyh2YWx1ZXMsIHV0aWxzLCBtZXRhKTtcbiAgICBpZiAocmVzdWx0ID09PSBhY3Rpb25zLmRlZmF1bHRNZXJnZSB8fFxuICAgICAgICAodXRpbHMudXNlSW1wbGljaXREZWZhdWx0TWVyZ2luZyAmJlxuICAgICAgICAgICAgcmVzdWx0ID09PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIHV0aWxzLm1lcmdlRnVuY3Rpb25zLm1lcmdlU2V0cyAhPT0gdXRpbHMuZGVmYXVsdE1lcmdlRnVuY3Rpb25zLm1lcmdlU2V0cykpIHtcbiAgICAgICAgcmV0dXJuIHV0aWxzLmRlZmF1bHRNZXJnZUZ1bmN0aW9ucy5tZXJnZVNldHModmFsdWVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogTWVyZ2UgbWFwcy5cbiAqXG4gKiBAcGFyYW0gdmFsdWVzIC0gVGhlIG1hcHMuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlTWFwcyh2YWx1ZXMsIHV0aWxzLCBtZXRhKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gdXRpbHMubWVyZ2VGdW5jdGlvbnMubWVyZ2VNYXBzKHZhbHVlcywgdXRpbHMsIG1ldGEpO1xuICAgIGlmIChyZXN1bHQgPT09IGFjdGlvbnMuZGVmYXVsdE1lcmdlIHx8XG4gICAgICAgICh1dGlscy51c2VJbXBsaWNpdERlZmF1bHRNZXJnaW5nICYmXG4gICAgICAgICAgICByZXN1bHQgPT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgdXRpbHMubWVyZ2VGdW5jdGlvbnMubWVyZ2VNYXBzICE9PSB1dGlscy5kZWZhdWx0TWVyZ2VGdW5jdGlvbnMubWVyZ2VNYXBzKSkge1xuICAgICAgICByZXR1cm4gdXRpbHMuZGVmYXVsdE1lcmdlRnVuY3Rpb25zLm1lcmdlTWFwcyh2YWx1ZXMpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4gKiBNZXJnZSBvdGhlciB0aGluZ3MuXG4gKlxuICogQHBhcmFtIHZhbHVlcyAtIFRoZSBvdGhlciB0aGluZ3MuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlT3RoZXJzKHZhbHVlcywgdXRpbHMsIG1ldGEpIHtcbiAgICBjb25zdCByZXN1bHQgPSB1dGlscy5tZXJnZUZ1bmN0aW9ucy5tZXJnZU90aGVycyh2YWx1ZXMsIHV0aWxzLCBtZXRhKTtcbiAgICBpZiAocmVzdWx0ID09PSBhY3Rpb25zLmRlZmF1bHRNZXJnZSB8fFxuICAgICAgICAodXRpbHMudXNlSW1wbGljaXREZWZhdWx0TWVyZ2luZyAmJlxuICAgICAgICAgICAgcmVzdWx0ID09PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIHV0aWxzLm1lcmdlRnVuY3Rpb25zLm1lcmdlT3RoZXJzICE9PSB1dGlscy5kZWZhdWx0TWVyZ2VGdW5jdGlvbnMubWVyZ2VPdGhlcnMpKSB7XG4gICAgICAgIHJldHVybiB1dGlscy5kZWZhdWx0TWVyZ2VGdW5jdGlvbnMubWVyZ2VPdGhlcnModmFsdWVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBUaGUgZGVmYXVsdCBzdHJhdGVneSB0byBtZXJnZSByZWNvcmRzIGludG8gYSB0YXJnZXQgcmVjb3JkLlxuICpcbiAqIEBwYXJhbSBtdXRfdGFyZ2V0IC0gVGhlIHJlc3VsdCB3aWxsIGJlIG11dGF0ZWQgaW50byB0aGlzIHJlY29yZFxuICogQHBhcmFtIHZhbHVlcyAtIFRoZSByZWNvcmRzIChpbmNsdWRpbmcgdGhlIHRhcmdldCdzIHZhbHVlIGlmIHRoZXJlIGlzIG9uZSkuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlUmVjb3Jkc0ludG8kMShtdXRfdGFyZ2V0LCB2YWx1ZXMsIHV0aWxzLCBtZXRhKSB7XG4gICAgZm9yIChjb25zdCBrZXkgb2YgZ2V0S2V5cyh2YWx1ZXMpKSB7XG4gICAgICAgIGNvbnN0IHByb3BWYWx1ZXMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCB2YWx1ZSBvZiB2YWx1ZXMpIHtcbiAgICAgICAgICAgIGlmIChvYmplY3RIYXNQcm9wZXJ0eSh2YWx1ZSwga2V5KSkge1xuICAgICAgICAgICAgICAgIHByb3BWYWx1ZXMucHVzaCh2YWx1ZVtrZXldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvcFZhbHVlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVwZGF0ZWRNZXRhID0gdXRpbHMubWV0YURhdGFVcGRhdGVyKG1ldGEsIHtcbiAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgIHBhcmVudHM6IHZhbHVlcyxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHByb3BlcnR5VGFyZ2V0ID0geyB2YWx1ZTogcHJvcFZhbHVlc1swXSB9O1xuICAgICAgICBtZXJnZVVua25vd25zSW50byhwcm9wZXJ0eVRhcmdldCwgcHJvcFZhbHVlcywgdXRpbHMsIHVwZGF0ZWRNZXRhKTtcbiAgICAgICAgaWYgKGtleSA9PT0gXCJfX3Byb3RvX19cIikge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG11dF90YXJnZXQudmFsdWUsIGtleSwge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBwcm9wZXJ0eVRhcmdldC52YWx1ZSxcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbXV0X3RhcmdldC52YWx1ZVtrZXldID0gcHJvcGVydHlUYXJnZXQudmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIFRoZSBkZWZhdWx0IHN0cmF0ZWd5IHRvIG1lcmdlIGFycmF5cyBpbnRvIGEgdGFyZ2V0IGFycmF5LlxuICpcbiAqIEBwYXJhbSBtdXRfdGFyZ2V0IC0gVGhlIHJlc3VsdCB3aWxsIGJlIG11dGF0ZWQgaW50byB0aGlzIGFycmF5XG4gKiBAcGFyYW0gdmFsdWVzIC0gVGhlIGFycmF5cyAoaW5jbHVkaW5nIHRoZSB0YXJnZXQncyB2YWx1ZSBpZiB0aGVyZSBpcyBvbmUpLlxuICovXG5mdW5jdGlvbiBtZXJnZUFycmF5c0ludG8kMShtdXRfdGFyZ2V0LCB2YWx1ZXMpIHtcbiAgICBtdXRfdGFyZ2V0LnZhbHVlLnB1c2goLi4udmFsdWVzLnNsaWNlKDEpLmZsYXQoKSk7XG59XG4vKipcbiAqIFRoZSBkZWZhdWx0IHN0cmF0ZWd5IHRvIG1lcmdlIHNldHMgaW50byBhIHRhcmdldCBzZXQuXG4gKlxuICogQHBhcmFtIG11dF90YXJnZXQgLSBUaGUgcmVzdWx0IHdpbGwgYmUgbXV0YXRlZCBpbnRvIHRoaXMgc2V0XG4gKiBAcGFyYW0gdmFsdWVzIC0gVGhlIHNldHMgKGluY2x1ZGluZyB0aGUgdGFyZ2V0J3MgdmFsdWUgaWYgdGhlcmUgaXMgb25lKS5cbiAqL1xuZnVuY3Rpb24gbWVyZ2VTZXRzSW50byQxKG11dF90YXJnZXQsIHZhbHVlcykge1xuICAgIGZvciAoY29uc3QgdmFsdWUgb2YgZ2V0SXRlcmFibGVPZkl0ZXJhYmxlcyh2YWx1ZXMuc2xpY2UoMSkpKSB7XG4gICAgICAgIG11dF90YXJnZXQudmFsdWUuYWRkKHZhbHVlKTtcbiAgICB9XG59XG4vKipcbiAqIFRoZSBkZWZhdWx0IHN0cmF0ZWd5IHRvIG1lcmdlIG1hcHMgaW50byBhIHRhcmdldCBtYXAuXG4gKlxuICogQHBhcmFtIG11dF90YXJnZXQgLSBUaGUgcmVzdWx0IHdpbGwgYmUgbXV0YXRlZCBpbnRvIHRoaXMgbWFwXG4gKiBAcGFyYW0gdmFsdWVzIC0gVGhlIG1hcHMgKGluY2x1ZGluZyB0aGUgdGFyZ2V0J3MgdmFsdWUgaWYgdGhlcmUgaXMgb25lKS5cbiAqL1xuZnVuY3Rpb24gbWVyZ2VNYXBzSW50byQxKG11dF90YXJnZXQsIHZhbHVlcykge1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIGdldEl0ZXJhYmxlT2ZJdGVyYWJsZXModmFsdWVzLnNsaWNlKDEpKSkge1xuICAgICAgICBtdXRfdGFyZ2V0LnZhbHVlLnNldChrZXksIHZhbHVlKTtcbiAgICB9XG59XG4vKipcbiAqIFNldCB0aGUgdGFyZ2V0IHRvIHRoZSBsYXN0IHZhbHVlLlxuICovXG5mdW5jdGlvbiBtZXJnZU90aGVyc0ludG8kMShtdXRfdGFyZ2V0LCB2YWx1ZXMpIHtcbiAgICBtdXRfdGFyZ2V0LnZhbHVlID0gdmFsdWVzLmF0KC0xKTtcbn1cbi8qKlxuICogVGhlIG1lcmdlIGZ1bmN0aW9ucy5cbiAqL1xuY29uc3QgbWVyZ2VJbnRvRnVuY3Rpb25zID0ge1xuICAgIG1lcmdlUmVjb3JkczogbWVyZ2VSZWNvcmRzSW50byQxLFxuICAgIG1lcmdlQXJyYXlzOiBtZXJnZUFycmF5c0ludG8kMSxcbiAgICBtZXJnZVNldHM6IG1lcmdlU2V0c0ludG8kMSxcbiAgICBtZXJnZU1hcHM6IG1lcmdlTWFwc0ludG8kMSxcbiAgICBtZXJnZU90aGVyczogbWVyZ2VPdGhlcnNJbnRvJDEsXG59O1xuXG5mdW5jdGlvbiBkZWVwbWVyZ2VJbnRvKHRhcmdldCwgLi4ub2JqZWN0cykge1xuICAgIHJldHVybiB2b2lkIGRlZXBtZXJnZUludG9DdXN0b20oe30pKHRhcmdldCwgLi4ub2JqZWN0cyk7XG59XG5mdW5jdGlvbiBkZWVwbWVyZ2VJbnRvQ3VzdG9tKG9wdGlvbnMsIHJvb3RNZXRhRGF0YSkge1xuICAgIGNvbnN0IHV0aWxzID0gZ2V0SW50b1V0aWxzKG9wdGlvbnMsIGN1c3RvbWl6ZWREZWVwbWVyZ2VJbnRvKTtcbiAgICAvKipcbiAgICAgKiBUaGUgY3VzdG9taXplZCBkZWVwbWVyZ2UgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3VzdG9taXplZERlZXBtZXJnZUludG8odGFyZ2V0LCAuLi5vYmplY3RzKSB7XG4gICAgICAgIG1lcmdlVW5rbm93bnNJbnRvKHsgdmFsdWU6IHRhcmdldCB9LCBbdGFyZ2V0LCAuLi5vYmplY3RzXSwgdXRpbHMsIHJvb3RNZXRhRGF0YSk7XG4gICAgfVxuICAgIHJldHVybiBjdXN0b21pemVkRGVlcG1lcmdlSW50bztcbn1cbi8qKlxuICogVGhlIHRoZSB1dGlscyB0aGF0IGFyZSBhdmFpbGFibGUgdG8gdGhlIG1lcmdlIGZ1bmN0aW9ucy5cbiAqXG4gKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBvcHRpb25zIHRoZSB1c2VyIHNwZWNpZmllZFxuICovXG5mdW5jdGlvbiBnZXRJbnRvVXRpbHMob3B0aW9ucywgY3VzdG9taXplZERlZXBtZXJnZUludG8pIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBkZWZhdWx0TWVyZ2VGdW5jdGlvbnM6IG1lcmdlSW50b0Z1bmN0aW9ucyxcbiAgICAgICAgbWVyZ2VGdW5jdGlvbnM6IHtcbiAgICAgICAgICAgIC4uLm1lcmdlSW50b0Z1bmN0aW9ucyxcbiAgICAgICAgICAgIC4uLk9iamVjdC5mcm9tRW50cmllcyhPYmplY3QuZW50cmllcyhvcHRpb25zKVxuICAgICAgICAgICAgICAgIC5maWx0ZXIoKFtrZXksIG9wdGlvbl0pID0+IE9iamVjdC5oYXNPd24obWVyZ2VJbnRvRnVuY3Rpb25zLCBrZXkpKVxuICAgICAgICAgICAgICAgIC5tYXAoKFtrZXksIG9wdGlvbl0pID0+IChvcHRpb24gPT09IGZhbHNlID8gW2tleSwgbWVyZ2VJbnRvRnVuY3Rpb25zLm1lcmdlT3RoZXJzXSA6IFtrZXksIG9wdGlvbl0pKSksXG4gICAgICAgIH0sXG4gICAgICAgIG1ldGFEYXRhVXBkYXRlcjogKG9wdGlvbnMubWV0YURhdGFVcGRhdGVyID8/IGRlZmF1bHRNZXRhRGF0YVVwZGF0ZXIpLFxuICAgICAgICBkZWVwbWVyZ2VJbnRvOiBjdXN0b21pemVkRGVlcG1lcmdlSW50byxcbiAgICAgICAgZmlsdGVyVmFsdWVzOiBvcHRpb25zLmZpbHRlclZhbHVlcyA9PT0gZmFsc2UgPyB1bmRlZmluZWQgOiAob3B0aW9ucy5maWx0ZXJWYWx1ZXMgPz8gZGVmYXVsdEZpbHRlclZhbHVlcyksXG4gICAgICAgIGFjdGlvbnM6IGFjdGlvbnNJbnRvLFxuICAgIH07XG59XG4vKipcbiAqIE1lcmdlIHVua25vd24gdGhpbmdzIGludG8gYSB0YXJnZXQuXG4gKlxuICogQHBhcmFtIG11dF90YXJnZXQgLSBUaGUgdGFyZ2V0IHRvIG1lcmdlIGludG8uXG4gKiBAcGFyYW0gdmFsdWVzIC0gVGhlIHZhbHVlcy5cbiAqL1xuZnVuY3Rpb24gbWVyZ2VVbmtub3duc0ludG8obXV0X3RhcmdldCwgdmFsdWVzLCB1dGlscywgbWV0YSkge1xuICAgIGNvbnN0IGZpbHRlcmVkVmFsdWVzID0gdXRpbHMuZmlsdGVyVmFsdWVzPy4odmFsdWVzLCBtZXRhKSA/PyB2YWx1ZXM7XG4gICAgaWYgKGZpbHRlcmVkVmFsdWVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChmaWx0ZXJlZFZhbHVlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIHZvaWQgbWVyZ2VPdGhlcnNJbnRvKG11dF90YXJnZXQsIGZpbHRlcmVkVmFsdWVzLCB1dGlscywgbWV0YSk7XG4gICAgfVxuICAgIGNvbnN0IHR5cGUgPSBnZXRPYmplY3RUeXBlKG11dF90YXJnZXQudmFsdWUpO1xuICAgIGlmICh0eXBlICE9PSAwIC8qIE9iamVjdFR5cGUuTk9UICovICYmIHR5cGUgIT09IDUgLyogT2JqZWN0VHlwZS5PVEhFUiAqLykge1xuICAgICAgICBmb3IgKGxldCBtdXRfaW5kZXggPSAxOyBtdXRfaW5kZXggPCBmaWx0ZXJlZFZhbHVlcy5sZW5ndGg7IG11dF9pbmRleCsrKSB7XG4gICAgICAgICAgICBpZiAoZ2V0T2JqZWN0VHlwZShmaWx0ZXJlZFZhbHVlc1ttdXRfaW5kZXhdKSA9PT0gdHlwZSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHZvaWQgbWVyZ2VPdGhlcnNJbnRvKG11dF90YXJnZXQsIGZpbHRlcmVkVmFsdWVzLCB1dGlscywgbWV0YSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgMSAvKiBPYmplY3RUeXBlLlJFQ09SRCAqLzoge1xuICAgICAgICAgICAgcmV0dXJuIHZvaWQgbWVyZ2VSZWNvcmRzSW50byhtdXRfdGFyZ2V0LCBmaWx0ZXJlZFZhbHVlcywgdXRpbHMsIG1ldGEpO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgMiAvKiBPYmplY3RUeXBlLkFSUkFZICovOiB7XG4gICAgICAgICAgICByZXR1cm4gdm9pZCBtZXJnZUFycmF5c0ludG8obXV0X3RhcmdldCwgZmlsdGVyZWRWYWx1ZXMsIHV0aWxzLCBtZXRhKTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIDMgLyogT2JqZWN0VHlwZS5TRVQgKi86IHtcbiAgICAgICAgICAgIHJldHVybiB2b2lkIG1lcmdlU2V0c0ludG8obXV0X3RhcmdldCwgZmlsdGVyZWRWYWx1ZXMsIHV0aWxzLCBtZXRhKTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIDQgLyogT2JqZWN0VHlwZS5NQVAgKi86IHtcbiAgICAgICAgICAgIHJldHVybiB2b2lkIG1lcmdlTWFwc0ludG8obXV0X3RhcmdldCwgZmlsdGVyZWRWYWx1ZXMsIHV0aWxzLCBtZXRhKTtcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICByZXR1cm4gdm9pZCBtZXJnZU90aGVyc0ludG8obXV0X3RhcmdldCwgZmlsdGVyZWRWYWx1ZXMsIHV0aWxzLCBtZXRhKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogTWVyZ2UgcmVjb3JkcyBpbnRvIGEgdGFyZ2V0IHJlY29yZC5cbiAqXG4gKiBAcGFyYW0gbXV0X3RhcmdldCAtIFRoZSB0YXJnZXQgdG8gbWVyZ2UgaW50by5cbiAqIEBwYXJhbSB2YWx1ZXMgLSBUaGUgcmVjb3Jkcy5cbiAqL1xuZnVuY3Rpb24gbWVyZ2VSZWNvcmRzSW50byhtdXRfdGFyZ2V0LCB2YWx1ZXMsIHV0aWxzLCBtZXRhKSB7XG4gICAgY29uc3QgYWN0aW9uID0gdXRpbHMubWVyZ2VGdW5jdGlvbnMubWVyZ2VSZWNvcmRzKG11dF90YXJnZXQsIHZhbHVlcywgdXRpbHMsIG1ldGEpO1xuICAgIGlmIChhY3Rpb24gPT09IGFjdGlvbnNJbnRvLmRlZmF1bHRNZXJnZSkge1xuICAgICAgICB1dGlscy5kZWZhdWx0TWVyZ2VGdW5jdGlvbnMubWVyZ2VSZWNvcmRzKG11dF90YXJnZXQsIHZhbHVlcywgdXRpbHMsIG1ldGEpO1xuICAgIH1cbn1cbi8qKlxuICogTWVyZ2UgYXJyYXlzIGludG8gYSB0YXJnZXQgYXJyYXkuXG4gKlxuICogQHBhcmFtIG11dF90YXJnZXQgLSBUaGUgdGFyZ2V0IHRvIG1lcmdlIGludG8uXG4gKiBAcGFyYW0gdmFsdWVzIC0gVGhlIGFycmF5cy5cbiAqL1xuZnVuY3Rpb24gbWVyZ2VBcnJheXNJbnRvKG11dF90YXJnZXQsIHZhbHVlcywgdXRpbHMsIG1ldGEpIHtcbiAgICBjb25zdCBhY3Rpb24gPSB1dGlscy5tZXJnZUZ1bmN0aW9ucy5tZXJnZUFycmF5cyhtdXRfdGFyZ2V0LCB2YWx1ZXMsIHV0aWxzLCBtZXRhKTtcbiAgICBpZiAoYWN0aW9uID09PSBhY3Rpb25zSW50by5kZWZhdWx0TWVyZ2UpIHtcbiAgICAgICAgdXRpbHMuZGVmYXVsdE1lcmdlRnVuY3Rpb25zLm1lcmdlQXJyYXlzKG11dF90YXJnZXQsIHZhbHVlcyk7XG4gICAgfVxufVxuLyoqXG4gKiBNZXJnZSBzZXRzIGludG8gYSB0YXJnZXQgc2V0LlxuICpcbiAqIEBwYXJhbSBtdXRfdGFyZ2V0IC0gVGhlIHRhcmdldCB0byBtZXJnZSBpbnRvLlxuICogQHBhcmFtIHZhbHVlcyAtIFRoZSBzZXRzLlxuICovXG5mdW5jdGlvbiBtZXJnZVNldHNJbnRvKG11dF90YXJnZXQsIHZhbHVlcywgdXRpbHMsIG1ldGEpIHtcbiAgICBjb25zdCBhY3Rpb24gPSB1dGlscy5tZXJnZUZ1bmN0aW9ucy5tZXJnZVNldHMobXV0X3RhcmdldCwgdmFsdWVzLCB1dGlscywgbWV0YSk7XG4gICAgaWYgKGFjdGlvbiA9PT0gYWN0aW9uc0ludG8uZGVmYXVsdE1lcmdlKSB7XG4gICAgICAgIHV0aWxzLmRlZmF1bHRNZXJnZUZ1bmN0aW9ucy5tZXJnZVNldHMobXV0X3RhcmdldCwgdmFsdWVzKTtcbiAgICB9XG59XG4vKipcbiAqIE1lcmdlIG1hcHMgaW50byBhIHRhcmdldCBtYXAuXG4gKlxuICogQHBhcmFtIG11dF90YXJnZXQgLSBUaGUgdGFyZ2V0IHRvIG1lcmdlIGludG8uXG4gKiBAcGFyYW0gdmFsdWVzIC0gVGhlIG1hcHMuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlTWFwc0ludG8obXV0X3RhcmdldCwgdmFsdWVzLCB1dGlscywgbWV0YSkge1xuICAgIGNvbnN0IGFjdGlvbiA9IHV0aWxzLm1lcmdlRnVuY3Rpb25zLm1lcmdlTWFwcyhtdXRfdGFyZ2V0LCB2YWx1ZXMsIHV0aWxzLCBtZXRhKTtcbiAgICBpZiAoYWN0aW9uID09PSBhY3Rpb25zSW50by5kZWZhdWx0TWVyZ2UpIHtcbiAgICAgICAgdXRpbHMuZGVmYXVsdE1lcmdlRnVuY3Rpb25zLm1lcmdlTWFwcyhtdXRfdGFyZ2V0LCB2YWx1ZXMpO1xuICAgIH1cbn1cbi8qKlxuICogTWVyZ2Ugb3RoZXIgdGhpbmdzIGludG8gYSB0YXJnZXQuXG4gKlxuICogQHBhcmFtIG11dF90YXJnZXQgLSBUaGUgdGFyZ2V0IHRvIG1lcmdlIGludG8uXG4gKiBAcGFyYW0gdmFsdWVzIC0gVGhlIG90aGVyIHRoaW5ncy5cbiAqL1xuZnVuY3Rpb24gbWVyZ2VPdGhlcnNJbnRvKG11dF90YXJnZXQsIHZhbHVlcywgdXRpbHMsIG1ldGEpIHtcbiAgICBjb25zdCBhY3Rpb24gPSB1dGlscy5tZXJnZUZ1bmN0aW9ucy5tZXJnZU90aGVycyhtdXRfdGFyZ2V0LCB2YWx1ZXMsIHV0aWxzLCBtZXRhKTtcbiAgICBpZiAoYWN0aW9uID09PSBhY3Rpb25zSW50by5kZWZhdWx0TWVyZ2UgfHwgbXV0X3RhcmdldC52YWx1ZSA9PT0gYWN0aW9uc0ludG8uZGVmYXVsdE1lcmdlKSB7XG4gICAgICAgIHV0aWxzLmRlZmF1bHRNZXJnZUZ1bmN0aW9ucy5tZXJnZU90aGVycyhtdXRfdGFyZ2V0LCB2YWx1ZXMpO1xuICAgIH1cbn1cblxuZXhwb3J0IHsgZGVlcG1lcmdlLCBkZWVwbWVyZ2VDdXN0b20sIGRlZXBtZXJnZUludG8sIGRlZXBtZXJnZUludG9DdXN0b20sIGdldEtleXMsIGdldE9iamVjdFR5cGUsIG9iamVjdEhhc1Byb3BlcnR5IH07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/deepmerge-ts@7.1.5/node_modules/deepmerge-ts/dist/index.mjs\n");

/***/ })

};
;
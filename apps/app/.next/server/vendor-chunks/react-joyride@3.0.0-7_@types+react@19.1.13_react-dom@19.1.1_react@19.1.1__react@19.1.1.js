"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-joyride@3.0.0-7_@types+react@19.1.13_react-dom@19.1.1_react@19.1.1__react@19.1.1";
exports.ids = ["vendor-chunks/react-joyride@3.0.0-7_@types+react@19.1.13_react-dom@19.1.1_react@19.1.1__react@19.1.1"];
exports.modules = {

/***/ "(ssr)/../../node_modules/.pnpm/react-joyride@3.0.0-7_@types+react@19.1.13_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/react-joyride/dist/index.mjs":
/*!*****************************************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/react-joyride@3.0.0-7_@types+react@19.1.13_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/react-joyride/dist/index.mjs ***!
  \*****************************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ACTIONS: () => (/* binding */ ACTIONS),\n/* harmony export */   EVENTS: () => (/* binding */ EVENTS),\n/* harmony export */   Joyride: () => (/* binding */ Joyride),\n/* harmony export */   LIFECYCLE: () => (/* binding */ LIFECYCLE),\n/* harmony export */   ORIGIN: () => (/* binding */ ORIGIN),\n/* harmony export */   PORTAL_ELEMENT_ID: () => (/* binding */ PORTAL_ELEMENT_ID),\n/* harmony export */   STATUS: () => (/* binding */ STATUS),\n/* harmony export */   \"default\": () => (/* binding */ ReactJoyride)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/../../node_modules/.pnpm/next@15.5.3_@babel+core@7.28.4_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _gilbarbara_hooks__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @gilbarbara/hooks */ \"(ssr)/../../node_modules/.pnpm/@gilbarbara+hooks@0.8.2_react@19.1.1/node_modules/@gilbarbara/hooks/dist/index.mjs\");\n/* harmony import */ var scroll__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! scroll */ \"(ssr)/../../node_modules/.pnpm/scroll@3.0.1/node_modules/scroll/index.js\");\n/* harmony import */ var scrollparent__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! scrollparent */ \"(ssr)/../../node_modules/.pnpm/scrollparent@2.1.0/node_modules/scrollparent/scrollparent.js\");\n/* harmony import */ var react_innertext__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react-innertext */ \"(ssr)/../../node_modules/.pnpm/react-innertext@1.1.5_@types+react@19.1.13_react@19.1.1/node_modules/react-innertext/index.js\");\n/* harmony import */ var is_lite__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! is-lite */ \"(ssr)/../../node_modules/.pnpm/is-lite@1.2.1/node_modules/is-lite/dist/index.mjs\");\n/* harmony import */ var deepmerge__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! deepmerge */ \"(ssr)/../../node_modules/.pnpm/deepmerge@4.3.1/node_modules/deepmerge/dist/cjs.js\");\n/* harmony import */ var _gilbarbara_deep_equal__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @gilbarbara/deep-equal */ \"(ssr)/../../node_modules/.pnpm/@gilbarbara+deep-equal@0.3.1/node_modules/@gilbarbara/deep-equal/dist/index.mjs\");\n/* harmony import */ var tree_changes_hook__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! tree-changes-hook */ \"(ssr)/../../node_modules/.pnpm/tree-changes-hook@0.11.3_react@19.1.1/node_modules/tree-changes-hook/dist/index.mjs\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/../../node_modules/.pnpm/next@15.5.3_@babel+core@7.28.4_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! react-dom */ \"(ssr)/../../node_modules/.pnpm/next@15.5.3_@babel+core@7.28.4_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-dom.js\");\n/* harmony import */ var react_floater__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! react-floater */ \"(ssr)/../../node_modules/.pnpm/react-floater@0.9.5-4_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/react-floater/dist/index.mjs\");\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n\n// src/index.tsx\n\n\n\n// src/modules/dom.ts\n\n\nfunction canUseDOM() {\n  var _a;\n  return !!(typeof window !== \"undefined\" && ((_a = window.document) == null ? void 0 : _a.createElement));\n}\nfunction getClientRect(element) {\n  if (!element) {\n    return null;\n  }\n  return element.getBoundingClientRect();\n}\nfunction getDocumentHeight(median = false) {\n  const { body, documentElement } = document;\n  if (!body || !documentElement) {\n    return 0;\n  }\n  if (median) {\n    const heights = [\n      body.scrollHeight,\n      body.offsetHeight,\n      documentElement.clientHeight,\n      documentElement.scrollHeight,\n      documentElement.offsetHeight\n    ].sort((a, b) => a - b);\n    const middle = Math.floor(heights.length / 2);\n    if (heights.length % 2 === 0) {\n      return (heights[middle - 1] + heights[middle]) / 2;\n    }\n    return heights[middle];\n  }\n  return Math.max(\n    body.scrollHeight,\n    body.offsetHeight,\n    documentElement.clientHeight,\n    documentElement.scrollHeight,\n    documentElement.offsetHeight\n  );\n}\nfunction getElement(element) {\n  if (!element) {\n    return null;\n  }\n  if (typeof element === \"string\") {\n    try {\n      return document.querySelector(element);\n    } catch (error) {\n      if (true) {\n        console.error(error);\n      }\n      return null;\n    }\n  }\n  return element;\n}\nfunction getStyleComputedProperty(el) {\n  if (!el || el.nodeType !== 1) {\n    return null;\n  }\n  return getComputedStyle(el);\n}\nfunction getScrollParent(element, skipFix, forListener) {\n  if (!element) {\n    return scrollDocument();\n  }\n  const parent = scrollparent__WEBPACK_IMPORTED_MODULE_2__(element);\n  if (parent) {\n    if (parent.isSameNode(scrollDocument())) {\n      if (forListener) {\n        return document;\n      }\n      return scrollDocument();\n    }\n    const hasScrolling = parent.scrollHeight > parent.offsetHeight;\n    if (!hasScrolling && !skipFix) {\n      parent.style.overflow = \"initial\";\n      return scrollDocument();\n    }\n  }\n  return parent;\n}\nfunction hasCustomScrollParent(element, skipFix) {\n  if (!element) {\n    return false;\n  }\n  const parent = getScrollParent(element, skipFix);\n  return parent ? !parent.isSameNode(scrollDocument()) : false;\n}\nfunction hasCustomOffsetParent(element) {\n  return element.offsetParent !== document.body;\n}\nfunction hasPosition(el, type = \"fixed\") {\n  if (!el || !(el instanceof HTMLElement)) {\n    return false;\n  }\n  const { nodeName } = el;\n  const styles = getStyleComputedProperty(el);\n  if (nodeName === \"BODY\" || nodeName === \"HTML\") {\n    return false;\n  }\n  if (styles && styles.position === type) {\n    return true;\n  }\n  if (!el.parentNode) {\n    return false;\n  }\n  return hasPosition(el.parentNode, type);\n}\nfunction isElementVisible(element) {\n  var _a;\n  if (!element) {\n    return false;\n  }\n  let parentElement = element;\n  while (parentElement) {\n    if (parentElement === document.body) {\n      break;\n    }\n    if (parentElement instanceof HTMLElement) {\n      const { display, visibility } = getComputedStyle(parentElement);\n      if (display === \"none\" || visibility === \"hidden\") {\n        return false;\n      }\n    }\n    parentElement = (_a = parentElement.parentElement) != null ? _a : null;\n  }\n  return true;\n}\nfunction getElementPosition(element, offset, skipFix) {\n  var _a, _b, _c;\n  const elementRect = getClientRect(element);\n  const parent = getScrollParent(element, skipFix);\n  const hasScrollParent = hasCustomScrollParent(element, skipFix);\n  const isFixedTarget = hasPosition(element);\n  let parentTop = 0;\n  let top = (_a = elementRect == null ? void 0 : elementRect.top) != null ? _a : 0;\n  if (hasScrollParent && isFixedTarget) {\n    const offsetTop = (_b = element == null ? void 0 : element.offsetTop) != null ? _b : 0;\n    const parentScrollTop = (_c = parent == null ? void 0 : parent.scrollTop) != null ? _c : 0;\n    top = offsetTop - parentScrollTop;\n  } else if (parent instanceof HTMLElement) {\n    parentTop = parent.scrollTop;\n    if (!hasScrollParent && !hasPosition(element)) {\n      top += parentTop;\n    }\n    if (!parent.isSameNode(scrollDocument())) {\n      top += scrollDocument().scrollTop;\n    }\n  }\n  return Math.floor(top - offset);\n}\nfunction getScrollTo(element, offset, skipFix) {\n  var _a;\n  if (!element) {\n    return 0;\n  }\n  const { offsetTop = 0, scrollTop = 0 } = (_a = scrollparent__WEBPACK_IMPORTED_MODULE_2__(element)) != null ? _a : {};\n  let top = element.getBoundingClientRect().top + scrollTop;\n  if (!!offsetTop && (hasCustomScrollParent(element, skipFix) || hasCustomOffsetParent(element))) {\n    top -= offsetTop;\n  }\n  const output = Math.floor(top - offset);\n  return output < 0 ? 0 : output;\n}\nfunction scrollDocument() {\n  var _a;\n  return (_a = document.scrollingElement) != null ? _a : document.documentElement;\n}\nfunction scrollTo(value, options) {\n  const { duration, element } = options;\n  return new Promise((resolve, reject) => {\n    const { scrollTop } = element;\n    const limit = value > scrollTop ? value - scrollTop : scrollTop - value;\n    scroll__WEBPACK_IMPORTED_MODULE_1__.top(element, value, { duration: limit < 100 ? 50 : duration }, (error) => {\n      if (error && error.message !== \"Element already at target scroll position\") {\n        return reject(error);\n      }\n      return resolve();\n    });\n  });\n}\n\n// src/modules/helpers.tsx\n\n\n\n\n// src/literals/index.ts\nvar ACTIONS = {\n  INIT: \"init\",\n  START: \"start\",\n  STOP: \"stop\",\n  RESET: \"reset\",\n  PREV: \"prev\",\n  NEXT: \"next\",\n  GO: \"go\",\n  CLOSE: \"close\",\n  SKIP: \"skip\",\n  UPDATE: \"update\",\n  COMPLETE: \"complete\"\n};\nvar EVENTS = {\n  TOUR_START: \"tour:start\",\n  STEP_BEFORE: \"step:before\",\n  BEACON: \"beacon\",\n  TOOLTIP: \"tooltip\",\n  STEP_AFTER: \"step:after\",\n  TOUR_END: \"tour:end\",\n  TOUR_STATUS: \"tour:status\",\n  TARGET_NOT_FOUND: \"error:target_not_found\",\n  ERROR: \"error\"\n};\nvar LIFECYCLE = {\n  INIT: \"init\",\n  READY: \"ready\",\n  BEACON: \"beacon\",\n  TOOLTIP: \"tooltip\",\n  COMPLETE: \"complete\",\n  ERROR: \"error\"\n};\nvar ORIGIN = {\n  BUTTON_CLOSE: \"button_close\",\n  BUTTON_PRIMARY: \"button_primary\",\n  KEYBOARD: \"keyboard\",\n  OVERLAY: \"overlay\"\n};\nvar STATUS = {\n  IDLE: \"idle\",\n  READY: \"ready\",\n  WAITING: \"waiting\",\n  RUNNING: \"running\",\n  PAUSED: \"paused\",\n  SKIPPED: \"skipped\",\n  FINISHED: \"finished\",\n  ERROR: \"error\"\n};\nvar PORTAL_ELEMENT_ID = \"react-joyride-portal\";\n\n// src/modules/helpers.tsx\nfunction cleanUpObject(input) {\n  const output = {};\n  for (const key in input) {\n    if (input[key] !== void 0) {\n      output[key] = input[key];\n    }\n  }\n  return output;\n}\nfunction getBrowser(userAgent = navigator.userAgent) {\n  let browser = userAgent;\n  if (typeof window === \"undefined\") {\n    browser = \"node\";\n  } else if (document.documentMode) {\n    browser = \"ie\";\n  } else if (/Edge/.test(userAgent)) {\n    browser = \"edge\";\n  } else if (Boolean(window.opera) || userAgent.includes(\" OPR/\")) {\n    browser = \"opera\";\n  } else if (typeof window.InstallTrigger !== \"undefined\") {\n    browser = \"firefox\";\n  } else if (window.chrome) {\n    browser = \"chrome\";\n  } else if (/(Version\\/([\\d._]+).*Safari|CriOS|FxiOS| Mobile\\/)/.test(userAgent)) {\n    browser = \"safari\";\n  }\n  return browser;\n}\nfunction getObjectType(value) {\n  return Object.prototype.toString.call(value).slice(8, -1).toLowerCase();\n}\nfunction getReactNodeText(input, options = {}) {\n  const { defaultValue, step, steps } = options;\n  let text = react_innertext__WEBPACK_IMPORTED_MODULE_3__(input);\n  if (!text) {\n    if ((0,react__WEBPACK_IMPORTED_MODULE_0__.isValidElement)(input) && !Object.values(input.props).length && getObjectType(input.type) === \"function\") {\n      const component = input.type({});\n      text = getReactNodeText(component, options);\n    } else {\n      text = react_innertext__WEBPACK_IMPORTED_MODULE_3__(defaultValue);\n    }\n  } else if ((text.includes(\"{step}\") || text.includes(\"{steps}\")) && step && steps) {\n    text = text.replace(\"{step}\", step.toString()).replace(\"{steps}\", steps.toString());\n  }\n  return text;\n}\nfunction hexToRGB(hex) {\n  const shorthandRegex = /^#?([\\da-f])([\\da-f])([\\da-f])$/i;\n  const properHex = hex.replace(shorthandRegex, (_m, r, g, b) => r + r + g + g + b + b);\n  const result = /^#?([\\da-f]{2})([\\da-f]{2})([\\da-f]{2})$/i.exec(properHex);\n  return result ? [parseInt(result[1], 16), parseInt(result[2], 16), parseInt(result[3], 16)] : [];\n}\nfunction hideBeacon(step, state, continuous) {\n  const { action } = state;\n  const withContinuous = continuous && [ACTIONS.PREV, ACTIONS.NEXT].includes(action);\n  return step.disableBeacon || step.placement === \"center\" || withContinuous;\n}\nfunction isLegacy() {\n  return ![\"chrome\", \"safari\", \"firefox\", \"opera\"].includes(getBrowser());\n}\nfunction log({ data, debug = false, title, warn = false }) {\n  var _a;\n  const logFn = warn ? (_a = console.warn) != null ? _a : console.error : console.log;\n  if (debug) {\n    if (title && data) {\n      console.groupCollapsed(\n        `%creact-joyride: ${title}`,\n        \"color: #ff0044; font-weight: bold; font-size: 12px;\"\n      );\n      if (Array.isArray(data)) {\n        data.forEach((d) => {\n          if (is_lite__WEBPACK_IMPORTED_MODULE_4__[\"default\"].plainObject(d) && d.key) {\n            logFn.apply(console, [d.key, d.value]);\n          } else {\n            logFn.apply(console, [d]);\n          }\n        });\n      } else {\n        logFn.apply(console, [data]);\n      }\n      console.groupEnd();\n    } else {\n      console.error(\"Missing title or data props\");\n    }\n  }\n}\nfunction mergeProps(defaultProps2, props) {\n  const cleanProps = cleanUpObject(props);\n  return { ...defaultProps2, ...cleanProps };\n}\nfunction noop() {\n  return void 0;\n}\nfunction omit(input, ...filter) {\n  if (!is_lite__WEBPACK_IMPORTED_MODULE_4__[\"default\"].plainObject(input)) {\n    throw new TypeError(\"Expected an object\");\n  }\n  const output = {};\n  for (const key in input) {\n    if ({}.hasOwnProperty.call(input, key)) {\n      if (!filter.includes(key)) {\n        output[key] = input[key];\n      }\n    }\n  }\n  return output;\n}\nfunction pick(input, ...filter) {\n  if (!is_lite__WEBPACK_IMPORTED_MODULE_4__[\"default\"].plainObject(input)) {\n    throw new TypeError(\"Expected an object\");\n  }\n  if (!filter.length) {\n    return input;\n  }\n  const output = {};\n  for (const key in input) {\n    if ({}.hasOwnProperty.call(input, key)) {\n      if (filter.includes(key)) {\n        output[key] = input[key];\n      }\n    }\n  }\n  return output;\n}\nfunction replaceLocaleContent(input, step, steps) {\n  const replacer = (text) => text.replace(\"{step}\", String(step)).replace(\"{steps}\", String(steps));\n  if (getObjectType(input) === \"string\") {\n    return replacer(input);\n  }\n  if (!(0,react__WEBPACK_IMPORTED_MODULE_0__.isValidElement)(input)) {\n    return input;\n  }\n  const { children } = input.props;\n  if (getObjectType(children) === \"string\" && children.includes(\"{step}\")) {\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.cloneElement)(input, {\n      children: replacer(children)\n    });\n  }\n  if (Array.isArray(children)) {\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.cloneElement)(input, {\n      children: children.map((child) => {\n        if (typeof child === \"string\") {\n          return replacer(child);\n        }\n        return replaceLocaleContent(child, step, steps);\n      })\n    });\n  }\n  if (getObjectType(input.type) === \"function\" && !Object.values(input.props).length) {\n    const component = input.type({});\n    return replaceLocaleContent(component, step, steps);\n  }\n  return input;\n}\nfunction shouldScroll(options) {\n  const { isFirstStep, lifecycle, previousLifecycle, scrollToFirstStep, step, target } = options;\n  return !step.disableScrolling && (!isFirstStep || scrollToFirstStep || lifecycle === LIFECYCLE.TOOLTIP) && step.placement !== \"center\" && (!step.isFixed || !hasPosition(target)) && // fixed steps don't need to scroll\n  previousLifecycle !== lifecycle && [LIFECYCLE.BEACON, LIFECYCLE.TOOLTIP].includes(lifecycle);\n}\n\n// src/modules/step.ts\n\n\n\n// src/defaults.ts\nvar defaultFloaterProps = {\n  modifiers: {\n    preventOverflow: {\n      options: {\n        rootBoundary: \"viewport\"\n      }\n    }\n  },\n  wrapperOptions: {\n    offset: -18,\n    position: true\n  }\n};\nvar defaultLocale = {\n  back: \"Back\",\n  close: \"Close\",\n  last: \"Last\",\n  next: \"Next\",\n  nextLabelWithProgress: \"Next (Step {step} of {steps})\",\n  open: \"Open the dialog\",\n  skip: \"Skip\"\n};\nvar defaultStep = {\n  event: \"click\",\n  placement: \"bottom\",\n  offset: 10,\n  disableBeacon: false,\n  disableCloseOnEsc: false,\n  disableOverlay: false,\n  disableOverlayClose: false,\n  disableScrollParentFix: false,\n  disableScrolling: false,\n  hideBackButton: false,\n  hideCloseButton: false,\n  hideFooter: false,\n  isFixed: false,\n  locale: defaultLocale,\n  showProgress: false,\n  showSkipButton: false,\n  spotlightClicks: false,\n  spotlightPadding: 10\n};\nvar defaultProps = {\n  continuous: false,\n  debug: false,\n  disableCloseOnEsc: false,\n  disableOverlay: false,\n  disableOverlayClose: false,\n  disableScrolling: false,\n  disableScrollParentFix: false,\n  getHelpers: noop(),\n  hideBackButton: false,\n  run: true,\n  scrollOffset: 20,\n  scrollDuration: 300,\n  scrollToFirstStep: false,\n  showSkipButton: false,\n  showProgress: false,\n  spotlightClicks: false,\n  spotlightPadding: 10,\n  steps: []\n};\nvar defaultState = {\n  action: ACTIONS.INIT,\n  controlled: false,\n  index: 0,\n  lifecycle: LIFECYCLE.INIT,\n  origin: null,\n  size: 0,\n  status: STATUS.IDLE\n};\n\n// src/styles.ts\n\nvar defaultOptions = {\n  arrowColor: \"#fff\",\n  backgroundColor: \"#fff\",\n  beaconSize: 36,\n  overlayColor: \"rgba(0, 0, 0, 0.5)\",\n  primaryColor: \"#f04\",\n  spotlightShadow: \"0 0 15px rgba(0, 0, 0, 0.5)\",\n  textColor: \"#333\",\n  width: 380,\n  zIndex: 100\n};\nvar buttonBase = {\n  backgroundColor: \"transparent\",\n  border: 0,\n  borderRadius: 0,\n  color: \"#555\",\n  cursor: \"pointer\",\n  fontSize: 16,\n  lineHeight: 1,\n  padding: 8,\n  WebkitAppearance: \"none\"\n};\nvar spotlight = {\n  borderRadius: 4,\n  position: \"absolute\"\n};\nfunction getStyles(props, step) {\n  var _a, _b, _c, _d, _e;\n  const { floaterProps, styles } = props;\n  const mergedFloaterProps = deepmerge__WEBPACK_IMPORTED_MODULE_5__((_a = step.floaterProps) != null ? _a : {}, floaterProps != null ? floaterProps : {});\n  const mergedStyles = deepmerge__WEBPACK_IMPORTED_MODULE_5__(styles != null ? styles : {}, (_b = step.styles) != null ? _b : {});\n  const options = deepmerge__WEBPACK_IMPORTED_MODULE_5__(defaultOptions, mergedStyles.options || {});\n  const hideBeacon2 = step.placement === \"center\" || step.disableBeacon;\n  let { width } = options;\n  if (window.innerWidth > 480) {\n    width = 380;\n  }\n  if (\"width\" in options) {\n    width = typeof options.width === \"number\" && window.innerWidth < options.width ? window.innerWidth - 30 : options.width;\n  }\n  const overlay = {\n    bottom: 0,\n    left: 0,\n    overflow: \"hidden\",\n    position: \"absolute\",\n    right: 0,\n    top: 0,\n    zIndex: options.zIndex\n  };\n  const defaultStyles = {\n    beacon: {\n      ...buttonBase,\n      display: hideBeacon2 ? \"none\" : \"inline-block\",\n      height: options.beaconSize,\n      position: \"relative\",\n      width: options.beaconSize,\n      zIndex: options.zIndex\n    },\n    beaconInner: {\n      animation: \"joyride-beacon-inner 1.2s infinite ease-in-out\",\n      backgroundColor: options.primaryColor,\n      borderRadius: \"50%\",\n      display: \"block\",\n      height: \"50%\",\n      left: \"50%\",\n      opacity: 0.7,\n      position: \"absolute\",\n      top: \"50%\",\n      transform: \"translate(-50%, -50%)\",\n      width: \"50%\"\n    },\n    beaconOuter: {\n      animation: \"joyride-beacon-outer 1.2s infinite ease-in-out\",\n      backgroundColor: `rgba(${hexToRGB(options.primaryColor).join(\",\")}, 0.2)`,\n      border: `2px solid ${options.primaryColor}`,\n      borderRadius: \"50%\",\n      boxSizing: \"border-box\",\n      display: \"block\",\n      height: \"100%\",\n      left: 0,\n      opacity: 0.9,\n      position: \"absolute\",\n      top: 0,\n      transformOrigin: \"center\",\n      width: \"100%\"\n    },\n    tooltip: {\n      backgroundColor: options.backgroundColor,\n      borderRadius: 5,\n      boxSizing: \"border-box\",\n      color: options.textColor,\n      fontSize: 16,\n      maxWidth: \"100%\",\n      padding: 15,\n      position: \"relative\",\n      width\n    },\n    tooltipContainer: {\n      lineHeight: 1.4,\n      textAlign: \"center\"\n    },\n    tooltipTitle: {\n      fontSize: 18,\n      margin: 0\n    },\n    tooltipContent: {\n      padding: \"20px 10px\"\n    },\n    tooltipFooter: {\n      alignItems: \"center\",\n      display: \"flex\",\n      justifyContent: \"flex-end\",\n      marginTop: 15\n    },\n    tooltipFooterSpacer: {\n      flex: 1\n    },\n    buttonNext: {\n      ...buttonBase,\n      backgroundColor: options.primaryColor,\n      borderRadius: 4,\n      color: \"#fff\"\n    },\n    buttonBack: {\n      ...buttonBase,\n      color: options.primaryColor,\n      marginLeft: \"auto\",\n      marginRight: 5\n    },\n    buttonClose: {\n      ...buttonBase,\n      color: options.textColor,\n      height: 14,\n      padding: 15,\n      position: \"absolute\",\n      right: 0,\n      top: 0,\n      width: 14\n    },\n    buttonSkip: {\n      ...buttonBase,\n      color: options.textColor,\n      fontSize: 14\n    },\n    overlay: {\n      ...overlay,\n      backgroundColor: options.overlayColor,\n      mixBlendMode: \"hard-light\"\n    },\n    overlayLegacy: {\n      ...overlay\n    },\n    overlayLegacyCenter: {\n      ...overlay,\n      backgroundColor: options.overlayColor\n    },\n    spotlight: {\n      ...spotlight,\n      backgroundColor: \"gray\"\n    },\n    spotlightLegacy: {\n      ...spotlight,\n      boxShadow: `0 0 0 9999px ${options.overlayColor}, ${options.spotlightShadow}`\n    },\n    floaterStyles: {\n      arrow: {\n        color: (_e = (_d = (_c = mergedFloaterProps == null ? void 0 : mergedFloaterProps.styles) == null ? void 0 : _c.arrow) == null ? void 0 : _d.color) != null ? _e : options.arrowColor\n      },\n      options: {\n        zIndex: options.zIndex + 100\n      }\n    },\n    options\n  };\n  return deepmerge__WEBPACK_IMPORTED_MODULE_5__(defaultStyles, mergedStyles);\n}\n\n// src/modules/step.ts\nfunction getTourProps(props) {\n  return pick(\n    props,\n    \"beaconComponent\",\n    \"disableCloseOnEsc\",\n    \"disableOverlay\",\n    \"disableOverlayClose\",\n    \"disableScrolling\",\n    \"disableScrollParentFix\",\n    \"floaterProps\",\n    \"hideBackButton\",\n    \"hideCloseButton\",\n    \"locale\",\n    \"showProgress\",\n    \"showSkipButton\",\n    \"spotlightClicks\",\n    \"spotlightPadding\",\n    \"styles\",\n    \"tooltipComponent\"\n  );\n}\nfunction getMergedStep(props, currentStep) {\n  var _a, _b, _c, _d, _e, _f;\n  if (!currentStep) {\n    return null;\n  }\n  const step = currentStep != null ? currentStep : {};\n  const mergedStep = deepmerge__WEBPACK_IMPORTED_MODULE_5__.all([defaultStep, getTourProps(props), step], {\n    isMergeableObject: is_lite__WEBPACK_IMPORTED_MODULE_4__[\"default\"].plainObject\n  });\n  const mergedStyles = getStyles(props, mergedStep);\n  const scrollParent2 = hasCustomScrollParent(\n    getElement(mergedStep.target),\n    mergedStep.disableScrollParentFix\n  );\n  const floaterProps = deepmerge__WEBPACK_IMPORTED_MODULE_5__.all([\n    defaultFloaterProps,\n    (_a = props.floaterProps) != null ? _a : {},\n    (_b = mergedStep.floaterProps) != null ? _b : {}\n  ]);\n  floaterProps.offset = mergedStep.offset;\n  floaterProps.styles = deepmerge__WEBPACK_IMPORTED_MODULE_5__((_c = floaterProps.styles) != null ? _c : {}, mergedStyles.floaterStyles);\n  floaterProps.offset += (_e = (_d = props.spotlightPadding) != null ? _d : mergedStep.spotlightPadding) != null ? _e : 0;\n  if (mergedStep.placementBeacon && floaterProps.wrapperOptions) {\n    floaterProps.wrapperOptions.placement = mergedStep.placementBeacon;\n  }\n  if (scrollParent2 && floaterProps.modifiers.preventOverflow) {\n    floaterProps.modifiers.preventOverflow.options = {\n      ...floaterProps.modifiers.preventOverflow.options,\n      rootBoundary: \"viewport\",\n      boundary: \"clippingParents\"\n    };\n  }\n  return {\n    ...mergedStep,\n    locale: deepmerge__WEBPACK_IMPORTED_MODULE_5__.all([defaultLocale, (_f = props.locale) != null ? _f : {}, mergedStep.locale || {}]),\n    floaterProps,\n    styles: omit(mergedStyles, \"floaterStyles\")\n  };\n}\nfunction validateStep(step, debug = false) {\n  if (!is_lite__WEBPACK_IMPORTED_MODULE_4__[\"default\"].plainObject(step)) {\n    log({\n      title: \"validateStep\",\n      data: \"step must be an object\",\n      warn: true,\n      debug\n    });\n    return false;\n  }\n  if (!step.target) {\n    log({\n      title: \"validateStep\",\n      data: \"target is missing from the step\",\n      warn: true,\n      debug\n    });\n    return false;\n  }\n  return true;\n}\nfunction validateSteps(steps, debug = false) {\n  if (!is_lite__WEBPACK_IMPORTED_MODULE_4__[\"default\"].array(steps)) {\n    log({\n      title: \"validateSteps\",\n      data: \"steps must be an array\",\n      warn: true,\n      debug\n    });\n    return false;\n  }\n  return steps.every((d) => validateStep(d, debug));\n}\n\n// src/modules/useJoyrideData.ts\n\n\n\n\n\n\n// src/modules/store.ts\n\n\nvar defaultState2 = {\n  action: \"init\",\n  controlled: false,\n  index: 0,\n  lifecycle: LIFECYCLE.INIT,\n  origin: null,\n  size: 0,\n  status: STATUS.IDLE\n};\nvar Store = class {\n  constructor(options) {\n    __publicField(this, \"beaconPopper\");\n    __publicField(this, \"tooltipPopper\");\n    __publicField(this, \"data\", /* @__PURE__ */ new Map());\n    __publicField(this, \"listener\");\n    __publicField(this, \"props\");\n    __publicField(this, \"store\", /* @__PURE__ */ new Map());\n    __publicField(this, \"updateState\", (patch, forceIndex = false) => {\n      this.setState({\n        ...this.getState(),\n        ...this.prepareState(patch, forceIndex)\n      });\n    });\n    __publicField(this, \"cleanupPoppers\", () => {\n      this.beaconPopper = null;\n      this.tooltipPopper = null;\n    });\n    __publicField(this, \"getPopper\", (name) => {\n      if (name === \"beacon\") {\n        return this.beaconPopper;\n      }\n      return this.tooltipPopper;\n    });\n    __publicField(this, \"setPopper\", (popper, type) => {\n      var _a, _b;\n      if (type === \"wrapper\") {\n        this.beaconPopper = popper;\n      } else {\n        this.tooltipPopper = popper;\n      }\n      if (popper && this.store.get(\"lifecycle\") === LIFECYCLE.COMPLETE) {\n        this.updateState({\n          action: ACTIONS.UPDATE,\n          lifecycle: LIFECYCLE.INIT\n        });\n      }\n      const getPopper = (_b = (_a = this.getStep()) == null ? void 0 : _a.floaterProps) == null ? void 0 : _b.getPopper;\n      if (getPopper) {\n        getPopper(popper, type);\n      }\n    });\n    __publicField(this, \"addListener\", (listener) => {\n      this.listener = listener;\n    });\n    __publicField(this, \"setSteps\", (steps) => {\n      const { size, status } = this.getState();\n      const state = {\n        size: steps.length,\n        status\n      };\n      this.data.set(\"steps\", steps);\n      if (status === STATUS.WAITING && !size && steps.length) {\n        state.status = STATUS.RUNNING;\n      }\n      this.updateState(state);\n    });\n    __publicField(this, \"close\", (origin = null) => {\n      const { index, status } = this.getState();\n      if (status !== STATUS.RUNNING) {\n        return;\n      }\n      this.updateState({\n        action: ACTIONS.CLOSE,\n        index: index + 1,\n        origin,\n        lifecycle: LIFECYCLE.COMPLETE\n      });\n    });\n    __publicField(this, \"go\", (nextIndex) => {\n      const { controlled, status } = this.getState();\n      if (controlled || status !== STATUS.RUNNING) {\n        return;\n      }\n      const step = this.getStep(nextIndex);\n      this.updateState({\n        action: ACTIONS.GO,\n        index: nextIndex,\n        lifecycle: LIFECYCLE.COMPLETE,\n        status: step ? status : STATUS.FINISHED\n      });\n    });\n    __publicField(this, \"info\", () => this.getState());\n    __publicField(this, \"next\", () => {\n      const { index, status } = this.getState();\n      if (status !== STATUS.RUNNING) {\n        return;\n      }\n      this.updateState({\n        action: ACTIONS.NEXT,\n        index: this.getUpdatedIndex(index + 1),\n        lifecycle: LIFECYCLE.COMPLETE\n      });\n    });\n    __publicField(this, \"open\", () => {\n      const { status } = this.getState();\n      if (status !== STATUS.RUNNING) {\n        return;\n      }\n      this.updateState({ action: ACTIONS.UPDATE, lifecycle: LIFECYCLE.TOOLTIP });\n    });\n    __publicField(this, \"prev\", () => {\n      const { index, status } = this.getState();\n      if (status !== STATUS.RUNNING) {\n        return;\n      }\n      this.updateState({\n        action: ACTIONS.PREV,\n        index: this.getUpdatedIndex(index - 1),\n        lifecycle: LIFECYCLE.COMPLETE\n      });\n    });\n    __publicField(this, \"reset\", (restart = false) => {\n      const { controlled } = this.getState();\n      if (controlled) {\n        return;\n      }\n      this.updateState({\n        action: ACTIONS.RESET,\n        index: 0,\n        lifecycle: LIFECYCLE.COMPLETE,\n        status: restart ? STATUS.RUNNING : STATUS.READY\n      });\n    });\n    __publicField(this, \"skip\", () => {\n      const { status } = this.getState();\n      if (status !== STATUS.RUNNING) {\n        return;\n      }\n      this.updateState({\n        action: ACTIONS.SKIP,\n        lifecycle: LIFECYCLE.COMPLETE,\n        status: STATUS.SKIPPED\n      });\n    });\n    __publicField(this, \"start\", (nextIndex) => {\n      const { index, size } = this.getState();\n      this.updateState(\n        {\n          action: ACTIONS.START,\n          index: is_lite__WEBPACK_IMPORTED_MODULE_4__[\"default\"].number(nextIndex) ? nextIndex : index,\n          status: size ? STATUS.RUNNING : STATUS.WAITING\n        },\n        true\n      );\n    });\n    __publicField(this, \"stop\", (advance = false) => {\n      const { index, status } = this.getState();\n      if ([STATUS.FINISHED, STATUS.SKIPPED].includes(status)) {\n        return;\n      }\n      this.updateState({\n        action: ACTIONS.STOP,\n        index: index + (advance ? 1 : 0),\n        lifecycle: LIFECYCLE.COMPLETE,\n        status: STATUS.PAUSED\n      });\n    });\n    const { continuous = false, stepIndex, steps = [] } = options != null ? options : {};\n    this.setState(\n      {\n        action: ACTIONS.INIT,\n        controlled: is_lite__WEBPACK_IMPORTED_MODULE_4__[\"default\"].number(stepIndex),\n        continuous,\n        index: is_lite__WEBPACK_IMPORTED_MODULE_4__[\"default\"].number(stepIndex) ? stepIndex : 0,\n        lifecycle: LIFECYCLE.INIT,\n        origin: null,\n        status: steps.length ? STATUS.READY : STATUS.IDLE\n      },\n      true\n    );\n    this.setSteps(steps);\n    this.beaconPopper = null;\n    this.tooltipPopper = null;\n    this.listener = null;\n    this.props = options != null ? options : { steps: [] };\n  }\n  getStep(nextIndex) {\n    const steps = this.data.get(\"steps\");\n    const { index } = this.getState();\n    return getMergedStep(this.props, steps[nextIndex != null ? nextIndex : index]);\n  }\n  getUpdatedIndex(nextIndex) {\n    const { size } = this.getState();\n    return Math.min(Math.max(nextIndex, 0), size);\n  }\n  hasUpdatedState(oldState) {\n    return !(0,_gilbarbara_deep_equal__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(oldState, this.getState());\n  }\n  prepareState(patch, forceIndex = false) {\n    var _a, _b, _c, _d, _e, _f;\n    const { action, controlled, index, size, status } = this.getState();\n    const newIndex = (_a = patch.index) != null ? _a : index;\n    return {\n      action: (_b = patch.action) != null ? _b : action,\n      controlled,\n      index: controlled && !forceIndex ? index : newIndex,\n      lifecycle: (_c = patch.lifecycle) != null ? _c : LIFECYCLE.INIT,\n      origin: (_d = patch.origin) != null ? _d : null,\n      size: (_e = patch.size) != null ? _e : size,\n      status: (_f = patch.status) != null ? _f : status\n    };\n  }\n  setState(patch, initial = false) {\n    const state = this.getState();\n    const {\n      action,\n      index,\n      lifecycle,\n      origin = null,\n      size,\n      status\n    } = {\n      ...state,\n      ...patch\n    };\n    this.store.set(\"action\", action);\n    this.store.set(\"index\", index);\n    this.store.set(\"lifecycle\", lifecycle);\n    this.store.set(\"origin\", origin);\n    this.store.set(\"size\", size);\n    this.store.set(\"status\", status);\n    if (initial) {\n      this.store.set(\"controlled\", patch.controlled);\n      this.store.set(\"continuous\", patch.continuous);\n    }\n    if (this.listener && this.hasUpdatedState(state)) {\n      this.listener(this.getState());\n    }\n  }\n  getState() {\n    var _a;\n    if (!((_a = this == null ? void 0 : this.store) == null ? void 0 : _a.size)) {\n      return { ...defaultState2 };\n    }\n    return {\n      action: this.store.get(\"action\") || \"\",\n      controlled: this.store.get(\"controlled\") || false,\n      index: parseInt(this.store.get(\"index\"), 10),\n      lifecycle: this.store.get(\"lifecycle\") || \"\",\n      origin: this.store.get(\"origin\") || null,\n      size: this.store.get(\"size\") || 0,\n      status: this.store.get(\"status\") || \"\"\n    };\n  }\n  getHelpers() {\n    return {\n      close: this.close,\n      go: this.go,\n      info: this.info,\n      next: this.next,\n      open: this.open,\n      prev: this.prev,\n      reset: this.reset,\n      skip: this.skip\n    };\n  }\n};\nfunction createStore(options) {\n  return new Store(options);\n}\n\n// src/modules/useJoyrideData.ts\nfunction useJoyrideData(props) {\n  const {\n    callback,\n    continuous,\n    debug,\n    disableScrollParentFix,\n    getHelpers,\n    run,\n    scrollDuration,\n    scrollOffset,\n    scrollToFirstStep,\n    stepIndex,\n    steps\n  } = props;\n  const store = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(createStore(props));\n  const [state, setState] = (0,_gilbarbara_hooks__WEBPACK_IMPORTED_MODULE_7__.useSetState)(store.current.getState());\n  const { action, controlled, index, lifecycle, size, status } = state;\n  const lastAction = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  const previousProps = (0,_gilbarbara_hooks__WEBPACK_IMPORTED_MODULE_7__.usePrevious)(props);\n  const previousState = (0,_gilbarbara_hooks__WEBPACK_IMPORTED_MODULE_7__.usePrevious)(state);\n  const { changed: changedProps } = (0,tree_changes_hook__WEBPACK_IMPORTED_MODULE_8__[\"default\"])(props);\n  const { changed: changedState, changedFrom: changedStateFrom } = (0,tree_changes_hook__WEBPACK_IMPORTED_MODULE_8__[\"default\"])(state);\n  const step = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => getMergedStep(props, steps[index]), [index, props, steps]);\n  const previousStep = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => getMergedStep(props, steps[index - 1]), [index, props, steps]);\n  (0,_gilbarbara_hooks__WEBPACK_IMPORTED_MODULE_7__.useSingleton)(() => {\n    store.current.addListener((newState) => {\n      setState(newState);\n    });\n  });\n  const scrollToStep = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (lastState) => {\n      var _a, _b, _c, _d, _e, _f;\n      if (!step) {\n        return;\n      }\n      const target = getElement(step.target);\n      const shouldScrollToStep = shouldScroll({\n        isFirstStep: index === 0,\n        lifecycle,\n        previousLifecycle: lastState.lifecycle,\n        scrollToFirstStep,\n        step,\n        target\n      });\n      const beaconPopper = store.current.getPopper(\"beacon\");\n      const tooltipPopper = store.current.getPopper(\"tooltip\");\n      if (status === STATUS.RUNNING && shouldScrollToStep) {\n        const hasCustomScroll = hasCustomScrollParent(target, disableScrollParentFix);\n        const scrollParent2 = getScrollParent(target, disableScrollParentFix);\n        let scrollY = Math.floor(getScrollTo(target, scrollOffset, disableScrollParentFix)) || 0;\n        log({\n          title: \"scrollToStep\",\n          data: [\n            { key: \"index\", value: index },\n            { key: \"lifecycle\", value: lifecycle },\n            { key: \"status\", value: status }\n          ],\n          debug\n        });\n        if (lifecycle === LIFECYCLE.BEACON && beaconPopper) {\n          const { modifiersData, placement } = (_a = beaconPopper.state) != null ? _a : {};\n          const { offset } = modifiersData != null ? modifiersData : {};\n          const y = (_c = (_b = offset == null ? void 0 : offset.top) == null ? void 0 : _b.y) != null ? _c : 0;\n          if (![\"bottom\"].includes(placement) && !hasCustomScroll) {\n            scrollY = Math.floor(y - scrollOffset);\n          }\n        } else if (lifecycle === LIFECYCLE.TOOLTIP && tooltipPopper) {\n          const { modifiersData, placement } = (_d = tooltipPopper.state) != null ? _d : {};\n          const { offset } = modifiersData != null ? modifiersData : {};\n          const y = (_f = (_e = offset == null ? void 0 : offset.top) == null ? void 0 : _e.y) != null ? _f : 0;\n          const flipped = !!placement && placement !== step.placement;\n          if ([\"top\", \"right\", \"left\"].includes(placement) && !flipped && !hasCustomScroll) {\n            scrollY = Math.floor(y - scrollOffset);\n          } else {\n            scrollY -= step.spotlightPadding;\n          }\n        }\n        scrollY = scrollY >= 0 ? scrollY : 0;\n        if (status === STATUS.RUNNING) {\n          scrollTo(scrollY, { element: scrollParent2, duration: scrollDuration }).then(\n            () => {\n              setTimeout(() => {\n                var _a2;\n                (_a2 = store.current.getPopper(\"tooltip\")) == null ? void 0 : _a2.update();\n              }, 10);\n            }\n          );\n        }\n      }\n    },\n    [\n      debug,\n      disableScrollParentFix,\n      index,\n      lifecycle,\n      scrollDuration,\n      scrollOffset,\n      scrollToFirstStep,\n      status,\n      step\n    ]\n  );\n  (0,_gilbarbara_hooks__WEBPACK_IMPORTED_MODULE_7__.useMount)(() => {\n    if (run && size && validateSteps(steps, debug)) {\n      store.current.start();\n    }\n    if (getHelpers) {\n      getHelpers(store.current.getHelpers());\n    }\n  });\n  (0,_gilbarbara_hooks__WEBPACK_IMPORTED_MODULE_7__.useUpdateEffect)(() => {\n    if (run && size && status === STATUS.IDLE) {\n      store.current.updateState({ status: STATUS.READY });\n    }\n    if (getHelpers) {\n      getHelpers(store.current.getHelpers());\n    }\n  }, [getHelpers, run, size, status]);\n  (0,_gilbarbara_hooks__WEBPACK_IMPORTED_MODULE_7__.useDeepCompareEffect)(() => {\n    var _a, _b, _c, _d;\n    if (!previousProps || !previousState) {\n      return;\n    }\n    const isAfterAction = changedState(\"action\", [\n      ACTIONS.NEXT,\n      ACTIONS.PREV,\n      ACTIONS.SKIP,\n      ACTIONS.CLOSE\n    ]);\n    if (isAfterAction || lastAction.current === ACTIONS.CLOSE && action === ACTIONS.START) {\n      lastAction.current = action;\n    }\n    if (status === STATUS.RUNNING && step && lifecycle === LIFECYCLE.INIT) {\n      store.current.updateState({\n        action: (_a = lastAction.current) != null ? _a : ACTIONS.UPDATE,\n        lifecycle: LIFECYCLE.READY\n      });\n    }\n    if (size && !step && lifecycle === LIFECYCLE.INIT) {\n      store.current.updateState({\n        action: ACTIONS.UPDATE,\n        lifecycle: LIFECYCLE.COMPLETE,\n        status: STATUS.FINISHED\n      });\n    }\n    if (status === STATUS.RUNNING && (step == null ? void 0 : step.placement) === \"center\" && changedState(\"lifecycle\", LIFECYCLE.COMPLETE)) {\n      store.current.updateState({ action: ACTIONS.UPDATE, lifecycle: LIFECYCLE.INIT });\n    }\n    const element = getElement(step == null ? void 0 : step.target);\n    const elementExists = !!element;\n    if (step && elementExists && isElementVisible(element)) {\n      if (changedStateFrom(\"lifecycle\", LIFECYCLE.INIT, LIFECYCLE.READY)) {\n        callback == null ? void 0 : callback({\n          ...state,\n          action: (_b = lastAction.current) != null ? _b : action,\n          step,\n          type: EVENTS.STEP_BEFORE\n        });\n      }\n    } else if (step && status === STATUS.RUNNING) {\n      console.warn(elementExists ? \"Target not visible\" : \"Target not mounted\", step);\n      callback == null ? void 0 : callback({\n        ...state,\n        type: EVENTS.TARGET_NOT_FOUND,\n        step\n      });\n      if (!controlled) {\n        store.current.updateState({\n          action: ACTIONS.UPDATE,\n          index: index + (action === ACTIONS.PREV ? -1 : 1)\n        });\n      }\n    }\n    if (step && changedState(\"lifecycle\", LIFECYCLE.READY)) {\n      store.current.updateState({\n        action: ACTIONS.UPDATE,\n        lifecycle: hideBeacon(step, state, continuous) ? LIFECYCLE.TOOLTIP : LIFECYCLE.BEACON\n      });\n    }\n    if (step && changedState(\"lifecycle\", LIFECYCLE.BEACON)) {\n      callback == null ? void 0 : callback({\n        ...state,\n        step,\n        type: EVENTS.BEACON\n      });\n    }\n    if (step && changedState(\"lifecycle\", LIFECYCLE.TOOLTIP)) {\n      callback == null ? void 0 : callback({\n        ...state,\n        step,\n        type: EVENTS.TOOLTIP\n      });\n    }\n    const isRunningOrPausedWithStep = status === STATUS.RUNNING || controlled && status === STATUS.PAUSED && !!step;\n    const callbackStep = step != null ? step : previousStep;\n    const shouldSendCallback = isRunningOrPausedWithStep && callbackStep && changedState(\"lifecycle\", LIFECYCLE.COMPLETE, LIFECYCLE.TOOLTIP) && (elementExists || !step);\n    if (shouldSendCallback) {\n      callback == null ? void 0 : callback({\n        ...state,\n        action: (_c = lastAction.current) != null ? _c : ACTIONS.UPDATE,\n        index: (_d = previousState.index) != null ? _d : index,\n        lifecycle,\n        step: callbackStep,\n        type: EVENTS.STEP_AFTER\n      });\n    }\n    if (status === STATUS.WAITING) {\n      store.current.updateState({ status: STATUS.RUNNING });\n    }\n    if (changedProps()) {\n      const { stepIndex: previousStepIndex, steps: previousSteps } = previousProps;\n      if (!(0,_gilbarbara_deep_equal__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(previousSteps, steps)) {\n        if (validateSteps(steps, debug)) {\n          store.current.updateState({ size: steps.length });\n        } else {\n          console.warn(\"Steps are not valid\", steps);\n        }\n      }\n      if (changedProps(\"run\")) {\n        if (run) {\n          if (store.current.getState().size) {\n            store.current.start(stepIndex);\n          }\n        } else {\n          store.current.stop();\n        }\n      } else if (is_lite__WEBPACK_IMPORTED_MODULE_4__[\"default\"].number(stepIndex) && changedProps(\"stepIndex\")) {\n        const nextAction = is_lite__WEBPACK_IMPORTED_MODULE_4__[\"default\"].number(previousStepIndex) && previousStepIndex < stepIndex ? ACTIONS.NEXT : ACTIONS.PREV;\n        if (![STATUS.FINISHED, STATUS.SKIPPED].includes(status)) {\n          store.current.updateState({ action: nextAction, index: stepIndex }, true);\n        }\n      }\n    }\n    if (changedState(\"index\")) {\n      log({\n        title: `step:${lifecycle}`,\n        data: [{ key: \"props\", value: props }],\n        debug\n      });\n    }\n    if (changedState(\"lifecycle\", LIFECYCLE.COMPLETE) && index && index >= size) {\n      store.current.updateState({\n        action: ACTIONS.UPDATE,\n        lifecycle: LIFECYCLE.COMPLETE,\n        status: STATUS.FINISHED\n      });\n    }\n    if (previousStep && changedState(\"status\", [STATUS.FINISHED, STATUS.SKIPPED])) {\n      callback == null ? void 0 : callback({\n        ...state,\n        index: index - 1,\n        // Return the last step when the tour is finished\n        step: previousStep,\n        type: EVENTS.TOUR_END\n      });\n      store.current.reset();\n    }\n    if (step && changedStateFrom(\"status\", [STATUS.IDLE, STATUS.READY, STATUS.PAUSED], STATUS.RUNNING)) {\n      callback == null ? void 0 : callback({\n        ...state,\n        step,\n        type: EVENTS.TOUR_START\n      });\n    }\n    if (step && changedState(\"action\", ACTIONS.STOP)) {\n      callback == null ? void 0 : callback({\n        ...state,\n        step,\n        type: EVENTS.TOUR_STATUS\n      });\n    }\n    if (step && changedState(\"action\", ACTIONS.RESET)) {\n      callback == null ? void 0 : callback({\n        ...state,\n        step,\n        type: EVENTS.TOUR_STATUS\n      });\n    }\n    scrollToStep(previousState);\n  }, [\n    action,\n    callback,\n    changedProps,\n    changedState,\n    changedStateFrom,\n    continuous,\n    controlled,\n    debug,\n    index,\n    lifecycle,\n    previousProps,\n    previousState,\n    previousStep,\n    props,\n    run,\n    scrollToStep,\n    size,\n    state,\n    status,\n    step,\n    stepIndex,\n    steps\n  ]);\n  return store;\n}\n\n// src/modules/usePortalElement.ts\n\n\nfunction usePortalElement(portalElement) {\n  const [{ element, useExternalPortal }, setState] = (0,_gilbarbara_hooks__WEBPACK_IMPORTED_MODULE_7__.useSetState)({\n    useExternalPortal: false,\n    element: null\n  });\n  (0,_gilbarbara_hooks__WEBPACK_IMPORTED_MODULE_7__.useMount)(() => {\n    if (portalElement) {\n      if (is_lite__WEBPACK_IMPORTED_MODULE_4__[\"default\"].domElement(portalElement)) {\n        setState({ element: portalElement, useExternalPortal: true });\n      } else {\n        const portal = document.querySelector(portalElement);\n        if (portal) {\n          setState({ element: portal });\n        }\n      }\n    }\n    if (!portalElement) {\n      const portal = document.createElement(\"div\");\n      portal.id = PORTAL_ELEMENT_ID;\n      document.body.appendChild(portal);\n      setState({ element: portal });\n    }\n  });\n  (0,_gilbarbara_hooks__WEBPACK_IMPORTED_MODULE_7__.useUnmount)(() => {\n    if (!element || useExternalPortal) {\n      return;\n    }\n    if (element.parentNode === document.body) {\n      document.body.removeChild(element);\n    }\n  });\n  return element;\n}\n\n// src/components/Overlay.tsx\n\n\n\n\n// src/components/Spotlight.tsx\n\nfunction JoyrideSpotlight({ styles }) {\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsx)(\n    \"div\",\n    {\n      className: \"react-joyride__spotlight\",\n      \"data-test-id\": \"spotlight\",\n      style: styles\n    },\n    \"JoyrideSpotlight\"\n  );\n}\n\n// src/components/Overlay.tsx\n\nfunction JoyrideOverlay(props) {\n  const {\n    continuous,\n    debug,\n    disableOverlay,\n    disableOverlayClose,\n    disableScrolling,\n    disableScrollParentFix = false,\n    lifecycle,\n    onClickOverlay,\n    placement,\n    spotlightClicks,\n    spotlightPadding = 0,\n    styles,\n    target\n  } = props;\n  const isMounted = (0,_gilbarbara_hooks__WEBPACK_IMPORTED_MODULE_7__.useIsMounted)();\n  const { changed } = (0,tree_changes_hook__WEBPACK_IMPORTED_MODULE_8__[\"default\"])(props);\n  const resizeTimeoutRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n  const scrollTimeoutRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n  const scrollParentRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  const [{ isScrolling, mouseOverSpotlight, showSpotlight }, setState] = (0,_gilbarbara_hooks__WEBPACK_IMPORTED_MODULE_7__.useSetState)({\n    isScrolling: false,\n    mouseOverSpotlight: false,\n    resizedAt: 0,\n    showSpotlight: true\n  });\n  const updateState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (state) => {\n      if (!isMounted) {\n        return;\n      }\n      setState(state);\n    },\n    [isMounted, setState]\n  );\n  const overlayStyles = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    let baseStyles = styles.overlay;\n    if (isLegacy()) {\n      baseStyles = placement === \"center\" ? styles.overlayLegacyCenter : styles.overlayLegacy;\n    }\n    return {\n      cursor: disableOverlayClose ? \"default\" : \"pointer\",\n      height: getDocumentHeight(),\n      pointerEvents: mouseOverSpotlight ? \"none\" : \"auto\",\n      ...baseStyles\n    };\n  }, [\n    disableOverlayClose,\n    mouseOverSpotlight,\n    placement,\n    styles.overlay,\n    styles.overlayLegacy,\n    styles.overlayLegacyCenter\n  ]);\n  const spotlightStyles = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    var _a, _b, _c;\n    const element = getElement(target);\n    const elementRect = getClientRect(element);\n    const isFixedTarget = hasPosition(element);\n    const top = getElementPosition(element, spotlightPadding, disableScrollParentFix);\n    return {\n      height: Math.round(((_a = elementRect == null ? void 0 : elementRect.height) != null ? _a : 0) + spotlightPadding * 2),\n      left: Math.round(((_b = elementRect == null ? void 0 : elementRect.left) != null ? _b : 0) - spotlightPadding),\n      opacity: showSpotlight ? 1 : 0,\n      pointerEvents: spotlightClicks ? \"none\" : \"auto\",\n      position: isFixedTarget ? \"fixed\" : \"absolute\",\n      top,\n      transition: \"opacity 0.2s\",\n      width: Math.round(((_c = elementRect == null ? void 0 : elementRect.width) != null ? _c : 0) + spotlightPadding * 2),\n      ...isLegacy() ? styles.spotlightLegacy : styles.spotlight\n    };\n  }, [\n    disableScrollParentFix,\n    showSpotlight,\n    spotlightClicks,\n    spotlightPadding,\n    styles.spotlight,\n    styles.spotlightLegacy,\n    target\n  ]);\n  const handleMouseMove = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (event) => {\n      const { height, left, position, top, width } = spotlightStyles;\n      const offsetY = position === \"fixed\" ? event.clientY : event.pageY;\n      const offsetX = position === \"fixed\" ? event.clientX : event.pageX;\n      const inSpotlightHeight = offsetY >= top && offsetY <= top + height;\n      const inSpotlightWidth = offsetX >= left && offsetX <= left + width;\n      const inSpotlight = inSpotlightWidth && inSpotlightHeight;\n      if (inSpotlight !== mouseOverSpotlight) {\n        updateState({ mouseOverSpotlight: inSpotlight });\n      }\n    },\n    [spotlightStyles, mouseOverSpotlight, updateState]\n  );\n  const handleResize = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n    clearTimeout(resizeTimeoutRef.current);\n    resizeTimeoutRef.current = window.setTimeout(() => {\n      if (!isMounted) {\n        return;\n      }\n      setState({ resizedAt: Date.now() });\n    }, 100);\n  }, [isMounted, setState]);\n  const handleScroll = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n    const element = getElement(target);\n    if (scrollParentRef.current !== document) {\n      if (!isScrolling) {\n        updateState({ isScrolling: true, showSpotlight: false });\n      }\n      clearTimeout(scrollTimeoutRef.current);\n      scrollTimeoutRef.current = window.setTimeout(() => {\n        updateState({ isScrolling: false, showSpotlight: true });\n      }, 50);\n    } else if (hasPosition(element, \"sticky\")) {\n      updateState({});\n    }\n  }, [isScrolling, target, updateState]);\n  (0,_gilbarbara_hooks__WEBPACK_IMPORTED_MODULE_7__.useMount)(() => {\n    const element = getElement(target);\n    scrollParentRef.current = getScrollParent(\n      element != null ? element : document.body,\n      disableScrollParentFix,\n      true\n    );\n    if (true) {\n      if (!disableScrolling && hasCustomScrollParent(element, true)) {\n        log({\n          title: \"step has a custom scroll parent and can cause trouble with scrolling\",\n          data: [{ key: \"parent\", value: scrollParentRef }],\n          debug\n        });\n      }\n    }\n    window.addEventListener(\"resize\", handleResize);\n  });\n  (0,_gilbarbara_hooks__WEBPACK_IMPORTED_MODULE_7__.useUnmount)(() => {\n    var _a;\n    window.removeEventListener(\"mousemove\", handleMouseMove);\n    window.removeEventListener(\"resize\", handleResize);\n    clearTimeout(resizeTimeoutRef.current);\n    clearTimeout(scrollTimeoutRef.current);\n    (_a = scrollParentRef == null ? void 0 : scrollParentRef.current) == null ? void 0 : _a.removeEventListener(\"scroll\", handleScroll);\n  });\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    var _a;\n    if (changed(\"lifecycle\", LIFECYCLE.TOOLTIP)) {\n      (_a = scrollParentRef == null ? void 0 : scrollParentRef.current) == null ? void 0 : _a.addEventListener(\"scroll\", handleScroll, { passive: true });\n      setTimeout(() => {\n        if (!isScrolling) {\n          updateState({ showSpotlight: true });\n        }\n      }, 100);\n    }\n  }, [changed, handleScroll, isScrolling, updateState]);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (changed(\"spotlightClicks\") || changed(\"disableOverlay\") || changed(\"lifecycle\")) {\n      if (spotlightClicks && lifecycle === LIFECYCLE.TOOLTIP) {\n        window.addEventListener(\"mousemove\", handleMouseMove, false);\n      } else if (lifecycle !== LIFECYCLE.TOOLTIP) {\n        window.removeEventListener(\"mousemove\", handleMouseMove);\n      }\n    }\n  }, [changed, handleMouseMove, lifecycle, spotlightClicks]);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (changed(\"target\") || changed(\"disableScrollParentFix\")) {\n      const element = getElement(target);\n      scrollParentRef.current = getScrollParent(\n        element != null ? element : document.body,\n        disableScrollParentFix,\n        true\n      );\n    }\n  }, [changed, disableScrollParentFix, target]);\n  const hiddenLifecycles = [\n    LIFECYCLE.INIT,\n    LIFECYCLE.BEACON,\n    LIFECYCLE.COMPLETE,\n    LIFECYCLE.ERROR\n  ];\n  if (disableOverlay || (continuous ? hiddenLifecycles.includes(lifecycle) : lifecycle !== LIFECYCLE.TOOLTIP)) {\n    return null;\n  }\n  let spotlight2 = placement !== \"center\" && showSpotlight && /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsx)(JoyrideSpotlight, { styles: spotlightStyles });\n  const actualOverlayStyles = { ...overlayStyles };\n  if (getBrowser() === \"safari\") {\n    const { mixBlendMode, zIndex, ...safariOverlay } = overlayStyles;\n    spotlight2 = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsx)(\"div\", { style: { ...safariOverlay }, children: spotlight2 });\n    delete actualOverlayStyles.backgroundColor;\n  }\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsx)(\n    \"div\",\n    {\n      className: \"react-joyride__overlay\",\n      \"data-test-id\": \"overlay\",\n      onClick: onClickOverlay,\n      role: \"presentation\",\n      style: actualOverlayStyles,\n      children: spotlight2\n    }\n  );\n}\n\n// src/components/Portal.tsx\n\nfunction JoyridePortal(props) {\n  const { children, element } = props;\n  if (!element) {\n    return null;\n  }\n  return (0,react_dom__WEBPACK_IMPORTED_MODULE_10__.createPortal)(children, element);\n}\n\n// src/components/Step.tsx\n\n\n\n\n\n\n// src/modules/scope.ts\nvar Scope = class {\n  constructor(element, options) {\n    __publicField(this, \"element\");\n    __publicField(this, \"options\");\n    __publicField(this, \"canBeTabbed\", (element) => {\n      const { tabIndex } = element;\n      if (tabIndex === null || tabIndex < 0) {\n        return false;\n      }\n      return this.canHaveFocus(element);\n    });\n    __publicField(this, \"canHaveFocus\", (element) => {\n      const validTabNodes = /input|select|textarea|button|object/;\n      const nodeName = element.nodeName.toLowerCase();\n      const isValid = validTabNodes.test(nodeName) && !element.getAttribute(\"disabled\") || nodeName === \"a\" && !!element.getAttribute(\"href\");\n      return isValid && this.isVisible(element);\n    });\n    __publicField(this, \"findValidTabElements\", () => [].slice.call(this.element.querySelectorAll(\"*\"), 0).filter(this.canBeTabbed));\n    __publicField(this, \"handleKeyDown\", (event) => {\n      const { code = \"Tab\" } = this.options;\n      if (event.code === code) {\n        this.interceptTab(event);\n      }\n    });\n    __publicField(this, \"interceptTab\", (event) => {\n      event.preventDefault();\n      const elements = this.findValidTabElements();\n      const { shiftKey } = event;\n      if (!elements.length) {\n        return;\n      }\n      let x = document.activeElement ? elements.indexOf(document.activeElement) : 0;\n      if (x === -1 || !shiftKey && x + 1 === elements.length) {\n        x = 0;\n      } else if (shiftKey && x === 0) {\n        x = elements.length - 1;\n      } else {\n        x += shiftKey ? -1 : 1;\n      }\n      elements[x].focus();\n    });\n    // eslint-disable-next-line class-methods-use-this\n    __publicField(this, \"isHidden\", (element) => {\n      const noSize = element.offsetWidth <= 0 && element.offsetHeight <= 0;\n      const style = window.getComputedStyle(element);\n      if (noSize && !element.innerHTML) {\n        return true;\n      }\n      return noSize && style.getPropertyValue(\"overflow\") !== \"visible\" || style.getPropertyValue(\"display\") === \"none\";\n    });\n    __publicField(this, \"isVisible\", (element) => {\n      let parentElement = element;\n      while (parentElement) {\n        if (parentElement instanceof HTMLElement) {\n          if (parentElement === document.body) {\n            break;\n          }\n          if (this.isHidden(parentElement)) {\n            return false;\n          }\n          parentElement = parentElement.parentNode;\n        }\n      }\n      return true;\n    });\n    __publicField(this, \"removeScope\", () => {\n      window.removeEventListener(\"keydown\", this.handleKeyDown);\n    });\n    __publicField(this, \"checkFocus\", (target) => {\n      if (document.activeElement !== target) {\n        target.focus();\n        window.requestAnimationFrame(() => this.checkFocus(target));\n      }\n    });\n    __publicField(this, \"setFocus\", () => {\n      const { selector } = this.options;\n      if (!selector) {\n        return;\n      }\n      const target = this.element.querySelector(selector);\n      if (target) {\n        window.requestAnimationFrame(() => this.checkFocus(target));\n      }\n    });\n    if (!(element instanceof HTMLElement)) {\n      throw new TypeError(\"Invalid parameter: element must be an HTMLElement\");\n    }\n    this.element = element;\n    this.options = options;\n    window.addEventListener(\"keydown\", this.handleKeyDown, false);\n    this.setFocus();\n  }\n};\n\n// src/components/Beacon.tsx\n\n\n\n\nfunction JoyrideBeacon(props) {\n  const {\n    beaconComponent,\n    continuous,\n    index,\n    isLastStep,\n    locale,\n    onClickOrHover,\n    shouldFocus,\n    size,\n    step,\n    styles\n  } = props;\n  const beaconRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  (0,_gilbarbara_hooks__WEBPACK_IMPORTED_MODULE_7__.useSingleton)(() => {\n    if (beaconComponent) {\n      return;\n    }\n    const head = document.head || document.getElementsByTagName(\"head\")[0];\n    const style = document.createElement(\"style\");\n    style.id = \"joyride-beacon-animation\";\n    if (props.nonce) {\n      style.setAttribute(\"nonce\", props.nonce);\n    }\n    const css = `\n        @keyframes joyride-beacon-inner {\n          20% {\n            opacity: 0.9;\n          }\n        \n          90% {\n            opacity: 0.7;\n          }\n        }\n        \n        @keyframes joyride-beacon-outer {\n          0% {\n            transform: scale(1);\n          }\n        \n          45% {\n            opacity: 0.7;\n            transform: scale(0.75);\n          }\n        \n          100% {\n            opacity: 0.9;\n            transform: scale(1);\n          }\n        }\n      `;\n    style.appendChild(document.createTextNode(css));\n    head.appendChild(style);\n  });\n  (0,_gilbarbara_hooks__WEBPACK_IMPORTED_MODULE_7__.useMount)(() => {\n    if (true) {\n      if (!is_lite__WEBPACK_IMPORTED_MODULE_4__[\"default\"].domElement(beaconRef.current)) {\n        console.warn(\"beacon is not a valid DOM element\");\n      }\n    }\n    setTimeout(() => {\n      if (is_lite__WEBPACK_IMPORTED_MODULE_4__[\"default\"].domElement(beaconRef.current) && shouldFocus) {\n        beaconRef.current.focus();\n      }\n    }, 0);\n  });\n  (0,_gilbarbara_hooks__WEBPACK_IMPORTED_MODULE_7__.useUnmount)(() => {\n    const style = document.getElementById(\"joyride-beacon-animation\");\n    if (style == null ? void 0 : style.parentNode) {\n      style.parentNode.removeChild(style);\n    }\n  });\n  const setBeaconRef = (el) => {\n    beaconRef.current = el;\n  };\n  const title = getReactNodeText(locale.open);\n  const sharedProps = {\n    \"aria-label\": title,\n    onClick: onClickOrHover,\n    onMouseEnter: onClickOrHover,\n    ref: setBeaconRef,\n    title\n  };\n  let component;\n  if (beaconComponent) {\n    const BeaconComponent = beaconComponent;\n    component = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsx)(\n      BeaconComponent,\n      {\n        continuous,\n        index,\n        isLastStep,\n        size,\n        step,\n        ...sharedProps\n      }\n    );\n  } else {\n    component = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsxs)(\n      \"button\",\n      {\n        className: \"react-joyride__beacon\",\n        \"data-test-id\": \"button-beacon\",\n        style: styles.beacon,\n        type: \"button\",\n        ...sharedProps,\n        children: [\n          /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsx)(\"span\", { style: styles.beaconInner }),\n          /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsx)(\"span\", { style: styles.beaconOuter })\n        ]\n      },\n      \"JoyrideBeacon\"\n    );\n  }\n  return component;\n}\n\n// src/components/Tooltip/CloseButton.tsx\n\nfunction JoyrideTooltipCloseButton({ styles, ...props }) {\n  const { color, height, width, ...style } = styles;\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsx)(\"button\", { style, type: \"button\", ...props, children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsx)(\n    \"svg\",\n    {\n      height: typeof height === \"number\" ? `${height}px` : height,\n      preserveAspectRatio: \"xMidYMid\",\n      version: \"1.1\",\n      viewBox: \"0 0 18 18\",\n      width: typeof width === \"number\" ? `${width}px` : width,\n      xmlns: \"http://www.w3.org/2000/svg\",\n      children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsx)(\"g\", { children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsx)(\n        \"path\",\n        {\n          d: \"M8.13911129,9.00268191 L0.171521827,17.0258467 C-0.0498027049,17.248715 -0.0498027049,17.6098394 0.171521827,17.8327545 C0.28204354,17.9443526 0.427188206,17.9998706 0.572051765,17.9998706 C0.71714958,17.9998706 0.862013139,17.9443526 0.972581703,17.8327545 L9.0000937,9.74924618 L17.0276057,17.8327545 C17.1384085,17.9443526 17.2832721,17.9998706 17.4281356,17.9998706 C17.5729992,17.9998706 17.718097,17.9443526 17.8286656,17.8327545 C18.0499901,17.6098862 18.0499901,17.2487618 17.8286656,17.0258467 L9.86135722,9.00268191 L17.8340066,0.973848225 C18.0553311,0.750979934 18.0553311,0.389855532 17.8340066,0.16694039 C17.6126821,-0.0556467968 17.254037,-0.0556467968 17.0329467,0.16694039 L9.00042166,8.25611765 L0.967006424,0.167268345 C0.745681892,-0.0553188426 0.387317931,-0.0553188426 0.165993399,0.167268345 C-0.0553311331,0.390136635 -0.0553311331,0.751261038 0.165993399,0.974176179 L8.13920499,9.00268191 L8.13911129,9.00268191 Z\",\n          fill: color\n        }\n      ) })\n    }\n  ) });\n}\n\n// src/components/Tooltip/Container.tsx\n\nfunction JoyrideTooltipContainer(props) {\n  const { backProps, closeProps, index, isLastStep, primaryProps, skipProps, step, tooltipProps } = props;\n  const { content, hideBackButton, hideCloseButton, hideFooter, showSkipButton, styles, title } = step;\n  const output = {};\n  output.primary = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsx)(\n    \"button\",\n    {\n      \"data-test-id\": \"button-primary\",\n      style: styles.buttonNext,\n      type: \"button\",\n      ...primaryProps\n    }\n  );\n  if (showSkipButton && !isLastStep) {\n    output.skip = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsx)(\n      \"button\",\n      {\n        \"aria-live\": \"off\",\n        \"data-test-id\": \"button-skip\",\n        style: styles.buttonSkip,\n        type: \"button\",\n        ...skipProps\n      }\n    );\n  }\n  if (!hideBackButton && index > 0) {\n    output.back = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsx)(\"button\", { \"data-test-id\": \"button-back\", style: styles.buttonBack, type: \"button\", ...backProps });\n  }\n  output.close = !hideCloseButton && /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsx)(JoyrideTooltipCloseButton, { \"data-test-id\": \"button-close\", styles: styles.buttonClose, ...closeProps });\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsxs)(\n    \"div\",\n    {\n      \"aria-label\": getReactNodeText(title != null ? title : content),\n      className: \"react-joyride__tooltip\",\n      style: styles.tooltip,\n      ...tooltipProps,\n      children: [\n        /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsxs)(\"div\", { style: styles.tooltipContainer, children: [\n          title && /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsx)(\"h1\", { \"aria-label\": getReactNodeText(title), style: styles.tooltipTitle, children: title }),\n          /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsx)(\"div\", { style: styles.tooltipContent, children: content })\n        ] }),\n        !hideFooter && /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsxs)(\"div\", { style: styles.tooltipFooter, children: [\n          /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsx)(\"div\", { style: styles.tooltipFooterSpacer, children: output.skip }),\n          output.back,\n          output.primary\n        ] }),\n        output.close\n      ]\n    },\n    \"JoyrideTooltip\"\n  );\n}\n\n// src/components/Tooltip/index.tsx\n\nfunction Tooltip(props) {\n  const { continuous, helpers, index, isLastStep, setTooltipRef, size, step } = props;\n  const handleClickBack = (event) => {\n    event.preventDefault();\n    helpers.prev();\n  };\n  const handleClickClose = (event) => {\n    event.preventDefault();\n    helpers.close(\"button_close\");\n  };\n  const handleClickPrimary = (event) => {\n    event.preventDefault();\n    if (!continuous) {\n      helpers.close(\"button_primary\");\n      return;\n    }\n    helpers.next();\n  };\n  const handleClickSkip = (event) => {\n    event.preventDefault();\n    helpers.skip();\n  };\n  const getElementsProps = () => {\n    const { back, close, last, next, nextLabelWithProgress, skip } = step.locale;\n    const backText = getReactNodeText(back);\n    const closeText = getReactNodeText(close);\n    const lastText = getReactNodeText(last);\n    const nextText = getReactNodeText(next);\n    const skipText = getReactNodeText(skip);\n    let primary = close;\n    let primaryText = closeText;\n    if (continuous) {\n      primary = next;\n      primaryText = nextText;\n      if (step.showProgress && !isLastStep) {\n        const labelWithProgress = getReactNodeText(nextLabelWithProgress, {\n          step: index + 1,\n          steps: size\n        });\n        primary = replaceLocaleContent(nextLabelWithProgress, index + 1, size);\n        primaryText = labelWithProgress;\n      }\n      if (isLastStep) {\n        primary = last;\n        primaryText = lastText;\n      }\n    }\n    return {\n      backProps: {\n        \"aria-label\": backText,\n        children: back,\n        \"data-action\": \"back\",\n        onClick: handleClickBack,\n        role: \"button\",\n        title: backText\n      },\n      closeProps: {\n        \"aria-label\": closeText,\n        children: close,\n        \"data-action\": \"close\",\n        onClick: handleClickClose,\n        role: \"button\",\n        title: closeText\n      },\n      primaryProps: {\n        \"aria-label\": primaryText,\n        children: primary,\n        \"data-action\": \"primary\",\n        onClick: handleClickPrimary,\n        role: \"button\",\n        title: primaryText\n      },\n      skipProps: {\n        \"aria-label\": skipText,\n        children: skip,\n        \"data-action\": \"skip\",\n        onClick: handleClickSkip,\n        role: \"button\",\n        title: skipText\n      },\n      tooltipProps: {\n        \"aria-modal\": true,\n        ref: setTooltipRef,\n        role: \"alertdialog\"\n      }\n    };\n  };\n  const { beaconComponent, tooltipComponent, ...cleanStep } = step;\n  let component;\n  if (tooltipComponent) {\n    const renderProps = {\n      ...getElementsProps(),\n      continuous,\n      index,\n      isLastStep,\n      size,\n      step: cleanStep,\n      setTooltipRef\n    };\n    const TooltipComponent = tooltipComponent;\n    component = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsx)(TooltipComponent, { ...renderProps });\n  } else {\n    component = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsx)(\n      JoyrideTooltipContainer,\n      {\n        ...getElementsProps(),\n        continuous,\n        index,\n        isLastStep,\n        size,\n        step\n      }\n    );\n  }\n  return component;\n}\n\n// src/components/Step.tsx\n\nfunction JoyrideStep(props) {\n  const {\n    cleanupPoppers,\n    continuous,\n    debug,\n    helpers,\n    index,\n    lifecycle,\n    nonce,\n    setPopper,\n    shouldScroll: shouldScroll2,\n    size,\n    step,\n    updateState\n  } = props;\n  const scopeRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  const tooltipRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  const { changed, changedFrom } = (0,tree_changes_hook__WEBPACK_IMPORTED_MODULE_8__[\"default\"])(props);\n  (0,_gilbarbara_hooks__WEBPACK_IMPORTED_MODULE_7__.useMount)(() => {\n    log({\n      title: `step:${index}`,\n      data: [{ key: \"props\", value: props }],\n      debug\n    });\n  });\n  (0,_gilbarbara_hooks__WEBPACK_IMPORTED_MODULE_7__.useUnmount)(() => {\n    var _a;\n    (_a = scopeRef.current) == null ? void 0 : _a.removeScope();\n  });\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    var _a;\n    if (changed(\"lifecycle\", LIFECYCLE.TOOLTIP)) {\n      if (shouldScroll2 && tooltipRef.current) {\n        scopeRef.current = new Scope(tooltipRef.current, { selector: \"[data-action=primary]\" });\n        scopeRef.current.setFocus();\n      }\n    }\n    if (changedFrom(\"lifecycle\", [LIFECYCLE.TOOLTIP, LIFECYCLE.INIT], LIFECYCLE.INIT)) {\n      (_a = scopeRef.current) == null ? void 0 : _a.removeScope();\n      cleanupPoppers();\n    }\n  }, [changed, changedFrom, cleanupPoppers, shouldScroll2]);\n  const handleClickHoverBeacon = (event) => {\n    if (event.type === \"mouseenter\" && step.event !== \"hover\") {\n      return;\n    }\n    updateState({ lifecycle: LIFECYCLE.TOOLTIP });\n  };\n  const setTooltipRef = (element) => {\n    tooltipRef.current = element;\n  };\n  const target = getElement(step.target);\n  if (!validateStep(step) || !is_lite__WEBPACK_IMPORTED_MODULE_4__[\"default\"].domElement(target)) {\n    return null;\n  }\n  const tooltip = (renderProps) => {\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsx)(\n      Tooltip,\n      {\n        continuous,\n        helpers,\n        index,\n        isLastStep: index + 1 === size,\n        setTooltipRef,\n        size,\n        step,\n        ...renderProps\n      }\n    );\n  };\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsx)(\"div\", { className: \"react-joyride__step\", children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsx)(\n    react_floater__WEBPACK_IMPORTED_MODULE_11__[\"default\"],\n    {\n      ...step.floaterProps,\n      component: tooltip,\n      debug,\n      getPopper: setPopper,\n      id: `react-joyride-step-${index}`,\n      open: lifecycle === LIFECYCLE.TOOLTIP,\n      placement: step.placement,\n      portalElement: `#${PORTAL_ELEMENT_ID}`,\n      target: step.target,\n      children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsx)(\n        JoyrideBeacon,\n        {\n          beaconComponent: step.beaconComponent,\n          continuous,\n          index,\n          isLastStep: index + 1 === size,\n          locale: step.locale,\n          nonce,\n          onClickOrHover: handleClickHoverBeacon,\n          shouldFocus: shouldScroll2,\n          size,\n          step,\n          styles: step.styles\n        }\n      )\n    },\n    `JoyrideStep-${index}`\n  ) });\n}\n\n// src/index.tsx\n\nfunction Joyride(props) {\n  const mergedProps = mergeProps(defaultProps, props);\n  const { continuous, debug, disableCloseOnEsc, nonce, portalElement, scrollToFirstStep, steps } = mergedProps;\n  const store = useJoyrideData(mergedProps);\n  const element = usePortalElement(portalElement);\n  (0,_gilbarbara_hooks__WEBPACK_IMPORTED_MODULE_7__.useSingleton)(() => {\n    log({\n      title: \"init\",\n      data: [\n        { key: \"props\", value: props },\n        { key: \"state\", value: store.current.getState() }\n      ],\n      debug\n    });\n  });\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    const handleKeyboard = (event) => {\n      const { index: index2, lifecycle: lifecycle2 } = store.current.getState();\n      const step2 = steps[index2];\n      if (lifecycle2 === LIFECYCLE.TOOLTIP) {\n        if (event.code === \"Escape\" && !step2.disableCloseOnEsc) {\n          store.current.close(\"keyboard\");\n        }\n      }\n    };\n    if (!disableCloseOnEsc) {\n      document.body.addEventListener(\"keydown\", handleKeyboard, { passive: true });\n    }\n    return () => {\n      if (!disableCloseOnEsc) {\n        document.body.removeEventListener(\"keydown\", handleKeyboard);\n      }\n    };\n  }, [disableCloseOnEsc, steps, store]);\n  const { index, lifecycle, status } = store.current.getState();\n  const isRunning = status === STATUS.RUNNING;\n  const content = {};\n  const step = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => getMergedStep(props, steps[index]), [index, props, steps]);\n  const handleClickOverlay = () => {\n    if (!(step == null ? void 0 : step.disableOverlayClose)) {\n      store.current.close(\"overlay\");\n    }\n  };\n  if (!step) {\n    return null;\n  }\n  if (isRunning) {\n    content.step = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsx)(\n      JoyrideStep,\n      {\n        ...store.current.getState(),\n        cleanupPoppers: store.current.cleanupPoppers,\n        continuous,\n        debug,\n        helpers: store.current.getHelpers(),\n        nonce,\n        setPopper: store.current.setPopper,\n        shouldScroll: !step.disableScrolling && (index !== 0 || scrollToFirstStep),\n        step,\n        updateState: store.current.updateState\n      }\n    );\n    content.overlay = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsx)(JoyridePortal, { element, children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsx)(\n      JoyrideOverlay,\n      {\n        ...step,\n        continuous,\n        debug,\n        lifecycle,\n        onClickOverlay: handleClickOverlay\n      }\n    ) });\n  }\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsxs)(\"div\", { className: \"react-joyride\", children: [\n    content.step,\n    content.overlay\n  ] });\n}\nfunction ReactJoyride(props) {\n  if (!canUseDOM()) {\n    return null;\n  }\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsx)(Joyride, { ...props });\n}\n\n//# sourceMappingURL=index.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3JlYWN0LWpveXJpZGVAMy4wLjAtN19AdHlwZXMrcmVhY3RAMTkuMS4xM19yZWFjdC1kb21AMTkuMS4xX3JlYWN0QDE5LjEuMV9fcmVhY3RAMTkuMS4xL25vZGVfbW9kdWxlcy9yZWFjdC1qb3lyaWRlL2Rpc3QvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQSw4RUFBOEUsNkRBQTZEO0FBQzNJOztBQUVBO0FBQ3FFO0FBQ0g7O0FBRWxFO0FBQzRCO0FBQ1k7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsd0JBQXdCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sVUFBVSxJQUFxQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHlDQUFZO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFdBQVc7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLHlCQUF5Qix1REFBSyxVQUFVO0FBQ3hDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixzREFBSSxZQUFZLFVBQVU7QUFDbkQ7QUFVRTtBQUNGIiwic291cmNlcyI6WyIvaG9tZS9ydW5uZXIvd29ya3NwYWNlL25vZGVfbW9kdWxlcy8ucG5wbS9yZWFjdC1qb3lyaWRlQDMuMC4wLTdfQHR5cGVzK3JlYWN0QDE5LjEuMTNfcmVhY3QtZG9tQDE5LjEuMV9yZWFjdEAxOS4xLjFfX3JlYWN0QDE5LjEuMS9ub2RlX21vZHVsZXMvcmVhY3Qtam95cmlkZS9kaXN0L2luZGV4Lm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZGVmTm9ybWFsUHJvcCA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3Aob2JqLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xudmFyIF9fcHVibGljRmllbGQgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBfX2RlZk5vcm1hbFByb3Aob2JqLCB0eXBlb2Yga2V5ICE9PSBcInN5bWJvbFwiID8ga2V5ICsgXCJcIiA6IGtleSwgdmFsdWUpO1xuXG4vLyBzcmMvaW5kZXgudHN4XG5pbXBvcnQgeyB1c2VFZmZlY3QgYXMgdXNlRWZmZWN0MywgdXNlTWVtbyBhcyB1c2VNZW1vMyB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgdXNlU2luZ2xldG9uIGFzIHVzZVNpbmdsZXRvbjMgfSBmcm9tIFwiQGdpbGJhcmJhcmEvaG9va3NcIjtcblxuLy8gc3JjL21vZHVsZXMvZG9tLnRzXG5pbXBvcnQgc2Nyb2xsIGZyb20gXCJzY3JvbGxcIjtcbmltcG9ydCBzY3JvbGxQYXJlbnQgZnJvbSBcInNjcm9sbHBhcmVudFwiO1xuZnVuY3Rpb24gY2FuVXNlRE9NKCkge1xuICB2YXIgX2E7XG4gIHJldHVybiAhISh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmICgoX2EgPSB3aW5kb3cuZG9jdW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfYS5jcmVhdGVFbGVtZW50KSk7XG59XG5mdW5jdGlvbiBnZXRDbGllbnRSZWN0KGVsZW1lbnQpIHtcbiAgaWYgKCFlbGVtZW50KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG59XG5mdW5jdGlvbiBnZXREb2N1bWVudEhlaWdodChtZWRpYW4gPSBmYWxzZSkge1xuICBjb25zdCB7IGJvZHksIGRvY3VtZW50RWxlbWVudCB9ID0gZG9jdW1lbnQ7XG4gIGlmICghYm9keSB8fCAhZG9jdW1lbnRFbGVtZW50KSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgaWYgKG1lZGlhbikge1xuICAgIGNvbnN0IGhlaWdodHMgPSBbXG4gICAgICBib2R5LnNjcm9sbEhlaWdodCxcbiAgICAgIGJvZHkub2Zmc2V0SGVpZ2h0LFxuICAgICAgZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodCxcbiAgICAgIGRvY3VtZW50RWxlbWVudC5zY3JvbGxIZWlnaHQsXG4gICAgICBkb2N1bWVudEVsZW1lbnQub2Zmc2V0SGVpZ2h0XG4gICAgXS5zb3J0KChhLCBiKSA9PiBhIC0gYik7XG4gICAgY29uc3QgbWlkZGxlID0gTWF0aC5mbG9vcihoZWlnaHRzLmxlbmd0aCAvIDIpO1xuICAgIGlmIChoZWlnaHRzLmxlbmd0aCAlIDIgPT09IDApIHtcbiAgICAgIHJldHVybiAoaGVpZ2h0c1ttaWRkbGUgLSAxXSArIGhlaWdodHNbbWlkZGxlXSkgLyAyO1xuICAgIH1cbiAgICByZXR1cm4gaGVpZ2h0c1ttaWRkbGVdO1xuICB9XG4gIHJldHVybiBNYXRoLm1heChcbiAgICBib2R5LnNjcm9sbEhlaWdodCxcbiAgICBib2R5Lm9mZnNldEhlaWdodCxcbiAgICBkb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0LFxuICAgIGRvY3VtZW50RWxlbWVudC5zY3JvbGxIZWlnaHQsXG4gICAgZG9jdW1lbnRFbGVtZW50Lm9mZnNldEhlaWdodFxuICApO1xufVxuZnVuY3Rpb24gZ2V0RWxlbWVudChlbGVtZW50KSB7XG4gIGlmICghZWxlbWVudCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmICh0eXBlb2YgZWxlbWVudCA9PT0gXCJzdHJpbmdcIikge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihlbGVtZW50KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZWxlbWVudDtcbn1cbmZ1bmN0aW9uIGdldFN0eWxlQ29tcHV0ZWRQcm9wZXJ0eShlbCkge1xuICBpZiAoIWVsIHx8IGVsLm5vZGVUeXBlICE9PSAxKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIGdldENvbXB1dGVkU3R5bGUoZWwpO1xufVxuZnVuY3Rpb24gZ2V0U2Nyb2xsUGFyZW50KGVsZW1lbnQsIHNraXBGaXgsIGZvckxpc3RlbmVyKSB7XG4gIGlmICghZWxlbWVudCkge1xuICAgIHJldHVybiBzY3JvbGxEb2N1bWVudCgpO1xuICB9XG4gIGNvbnN0IHBhcmVudCA9IHNjcm9sbFBhcmVudChlbGVtZW50KTtcbiAgaWYgKHBhcmVudCkge1xuICAgIGlmIChwYXJlbnQuaXNTYW1lTm9kZShzY3JvbGxEb2N1bWVudCgpKSkge1xuICAgICAgaWYgKGZvckxpc3RlbmVyKSB7XG4gICAgICAgIHJldHVybiBkb2N1bWVudDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzY3JvbGxEb2N1bWVudCgpO1xuICAgIH1cbiAgICBjb25zdCBoYXNTY3JvbGxpbmcgPSBwYXJlbnQuc2Nyb2xsSGVpZ2h0ID4gcGFyZW50Lm9mZnNldEhlaWdodDtcbiAgICBpZiAoIWhhc1Njcm9sbGluZyAmJiAhc2tpcEZpeCkge1xuICAgICAgcGFyZW50LnN0eWxlLm92ZXJmbG93ID0gXCJpbml0aWFsXCI7XG4gICAgICByZXR1cm4gc2Nyb2xsRG9jdW1lbnQoKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHBhcmVudDtcbn1cbmZ1bmN0aW9uIGhhc0N1c3RvbVNjcm9sbFBhcmVudChlbGVtZW50LCBza2lwRml4KSB7XG4gIGlmICghZWxlbWVudCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBwYXJlbnQgPSBnZXRTY3JvbGxQYXJlbnQoZWxlbWVudCwgc2tpcEZpeCk7XG4gIHJldHVybiBwYXJlbnQgPyAhcGFyZW50LmlzU2FtZU5vZGUoc2Nyb2xsRG9jdW1lbnQoKSkgOiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGhhc0N1c3RvbU9mZnNldFBhcmVudChlbGVtZW50KSB7XG4gIHJldHVybiBlbGVtZW50Lm9mZnNldFBhcmVudCAhPT0gZG9jdW1lbnQuYm9keTtcbn1cbmZ1bmN0aW9uIGhhc1Bvc2l0aW9uKGVsLCB0eXBlID0gXCJmaXhlZFwiKSB7XG4gIGlmICghZWwgfHwgIShlbCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCB7IG5vZGVOYW1lIH0gPSBlbDtcbiAgY29uc3Qgc3R5bGVzID0gZ2V0U3R5bGVDb21wdXRlZFByb3BlcnR5KGVsKTtcbiAgaWYgKG5vZGVOYW1lID09PSBcIkJPRFlcIiB8fCBub2RlTmFtZSA9PT0gXCJIVE1MXCIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHN0eWxlcyAmJiBzdHlsZXMucG9zaXRpb24gPT09IHR5cGUpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoIWVsLnBhcmVudE5vZGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGhhc1Bvc2l0aW9uKGVsLnBhcmVudE5vZGUsIHR5cGUpO1xufVxuZnVuY3Rpb24gaXNFbGVtZW50VmlzaWJsZShlbGVtZW50KSB7XG4gIHZhciBfYTtcbiAgaWYgKCFlbGVtZW50KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGxldCBwYXJlbnRFbGVtZW50ID0gZWxlbWVudDtcbiAgd2hpbGUgKHBhcmVudEVsZW1lbnQpIHtcbiAgICBpZiAocGFyZW50RWxlbWVudCA9PT0gZG9jdW1lbnQuYm9keSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmIChwYXJlbnRFbGVtZW50IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHtcbiAgICAgIGNvbnN0IHsgZGlzcGxheSwgdmlzaWJpbGl0eSB9ID0gZ2V0Q29tcHV0ZWRTdHlsZShwYXJlbnRFbGVtZW50KTtcbiAgICAgIGlmIChkaXNwbGF5ID09PSBcIm5vbmVcIiB8fCB2aXNpYmlsaXR5ID09PSBcImhpZGRlblwiKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcGFyZW50RWxlbWVudCA9IChfYSA9IHBhcmVudEVsZW1lbnQucGFyZW50RWxlbWVudCkgIT0gbnVsbCA/IF9hIDogbnVsbDtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGdldEVsZW1lbnRQb3NpdGlvbihlbGVtZW50LCBvZmZzZXQsIHNraXBGaXgpIHtcbiAgdmFyIF9hLCBfYiwgX2M7XG4gIGNvbnN0IGVsZW1lbnRSZWN0ID0gZ2V0Q2xpZW50UmVjdChlbGVtZW50KTtcbiAgY29uc3QgcGFyZW50ID0gZ2V0U2Nyb2xsUGFyZW50KGVsZW1lbnQsIHNraXBGaXgpO1xuICBjb25zdCBoYXNTY3JvbGxQYXJlbnQgPSBoYXNDdXN0b21TY3JvbGxQYXJlbnQoZWxlbWVudCwgc2tpcEZpeCk7XG4gIGNvbnN0IGlzRml4ZWRUYXJnZXQgPSBoYXNQb3NpdGlvbihlbGVtZW50KTtcbiAgbGV0IHBhcmVudFRvcCA9IDA7XG4gIGxldCB0b3AgPSAoX2EgPSBlbGVtZW50UmVjdCA9PSBudWxsID8gdm9pZCAwIDogZWxlbWVudFJlY3QudG9wKSAhPSBudWxsID8gX2EgOiAwO1xuICBpZiAoaGFzU2Nyb2xsUGFyZW50ICYmIGlzRml4ZWRUYXJnZXQpIHtcbiAgICBjb25zdCBvZmZzZXRUb3AgPSAoX2IgPSBlbGVtZW50ID09IG51bGwgPyB2b2lkIDAgOiBlbGVtZW50Lm9mZnNldFRvcCkgIT0gbnVsbCA/IF9iIDogMDtcbiAgICBjb25zdCBwYXJlbnRTY3JvbGxUb3AgPSAoX2MgPSBwYXJlbnQgPT0gbnVsbCA/IHZvaWQgMCA6IHBhcmVudC5zY3JvbGxUb3ApICE9IG51bGwgPyBfYyA6IDA7XG4gICAgdG9wID0gb2Zmc2V0VG9wIC0gcGFyZW50U2Nyb2xsVG9wO1xuICB9IGVsc2UgaWYgKHBhcmVudCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XG4gICAgcGFyZW50VG9wID0gcGFyZW50LnNjcm9sbFRvcDtcbiAgICBpZiAoIWhhc1Njcm9sbFBhcmVudCAmJiAhaGFzUG9zaXRpb24oZWxlbWVudCkpIHtcbiAgICAgIHRvcCArPSBwYXJlbnRUb3A7XG4gICAgfVxuICAgIGlmICghcGFyZW50LmlzU2FtZU5vZGUoc2Nyb2xsRG9jdW1lbnQoKSkpIHtcbiAgICAgIHRvcCArPSBzY3JvbGxEb2N1bWVudCgpLnNjcm9sbFRvcDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIE1hdGguZmxvb3IodG9wIC0gb2Zmc2V0KTtcbn1cbmZ1bmN0aW9uIGdldFNjcm9sbFRvKGVsZW1lbnQsIG9mZnNldCwgc2tpcEZpeCkge1xuICB2YXIgX2E7XG4gIGlmICghZWxlbWVudCkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIGNvbnN0IHsgb2Zmc2V0VG9wID0gMCwgc2Nyb2xsVG9wID0gMCB9ID0gKF9hID0gc2Nyb2xsUGFyZW50KGVsZW1lbnQpKSAhPSBudWxsID8gX2EgOiB7fTtcbiAgbGV0IHRvcCA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wICsgc2Nyb2xsVG9wO1xuICBpZiAoISFvZmZzZXRUb3AgJiYgKGhhc0N1c3RvbVNjcm9sbFBhcmVudChlbGVtZW50LCBza2lwRml4KSB8fCBoYXNDdXN0b21PZmZzZXRQYXJlbnQoZWxlbWVudCkpKSB7XG4gICAgdG9wIC09IG9mZnNldFRvcDtcbiAgfVxuICBjb25zdCBvdXRwdXQgPSBNYXRoLmZsb29yKHRvcCAtIG9mZnNldCk7XG4gIHJldHVybiBvdXRwdXQgPCAwID8gMCA6IG91dHB1dDtcbn1cbmZ1bmN0aW9uIHNjcm9sbERvY3VtZW50KCkge1xuICB2YXIgX2E7XG4gIHJldHVybiAoX2EgPSBkb2N1bWVudC5zY3JvbGxpbmdFbGVtZW50KSAhPSBudWxsID8gX2EgOiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG59XG5mdW5jdGlvbiBzY3JvbGxUbyh2YWx1ZSwgb3B0aW9ucykge1xuICBjb25zdCB7IGR1cmF0aW9uLCBlbGVtZW50IH0gPSBvcHRpb25zO1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGNvbnN0IHsgc2Nyb2xsVG9wIH0gPSBlbGVtZW50O1xuICAgIGNvbnN0IGxpbWl0ID0gdmFsdWUgPiBzY3JvbGxUb3AgPyB2YWx1ZSAtIHNjcm9sbFRvcCA6IHNjcm9sbFRvcCAtIHZhbHVlO1xuICAgIHNjcm9sbC50b3AoZWxlbWVudCwgdmFsdWUsIHsgZHVyYXRpb246IGxpbWl0IDwgMTAwID8gNTAgOiBkdXJhdGlvbiB9LCAoZXJyb3IpID0+IHtcbiAgICAgIGlmIChlcnJvciAmJiBlcnJvci5tZXNzYWdlICE9PSBcIkVsZW1lbnQgYWxyZWFkeSBhdCB0YXJnZXQgc2Nyb2xsIHBvc2l0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIHJlamVjdChlcnJvcik7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzb2x2ZSgpO1xuICAgIH0pO1xuICB9KTtcbn1cblxuLy8gc3JjL21vZHVsZXMvaGVscGVycy50c3hcbmltcG9ydCB7IGNsb25lRWxlbWVudCwgaXNWYWxpZEVsZW1lbnQgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCBpbm5lclRleHQgZnJvbSBcInJlYWN0LWlubmVydGV4dFwiO1xuaW1wb3J0IGlzIGZyb20gXCJpcy1saXRlXCI7XG5cbi8vIHNyYy9saXRlcmFscy9pbmRleC50c1xudmFyIEFDVElPTlMgPSB7XG4gIElOSVQ6IFwiaW5pdFwiLFxuICBTVEFSVDogXCJzdGFydFwiLFxuICBTVE9QOiBcInN0b3BcIixcbiAgUkVTRVQ6IFwicmVzZXRcIixcbiAgUFJFVjogXCJwcmV2XCIsXG4gIE5FWFQ6IFwibmV4dFwiLFxuICBHTzogXCJnb1wiLFxuICBDTE9TRTogXCJjbG9zZVwiLFxuICBTS0lQOiBcInNraXBcIixcbiAgVVBEQVRFOiBcInVwZGF0ZVwiLFxuICBDT01QTEVURTogXCJjb21wbGV0ZVwiXG59O1xudmFyIEVWRU5UUyA9IHtcbiAgVE9VUl9TVEFSVDogXCJ0b3VyOnN0YXJ0XCIsXG4gIFNURVBfQkVGT1JFOiBcInN0ZXA6YmVmb3JlXCIsXG4gIEJFQUNPTjogXCJiZWFjb25cIixcbiAgVE9PTFRJUDogXCJ0b29sdGlwXCIsXG4gIFNURVBfQUZURVI6IFwic3RlcDphZnRlclwiLFxuICBUT1VSX0VORDogXCJ0b3VyOmVuZFwiLFxuICBUT1VSX1NUQVRVUzogXCJ0b3VyOnN0YXR1c1wiLFxuICBUQVJHRVRfTk9UX0ZPVU5EOiBcImVycm9yOnRhcmdldF9ub3RfZm91bmRcIixcbiAgRVJST1I6IFwiZXJyb3JcIlxufTtcbnZhciBMSUZFQ1lDTEUgPSB7XG4gIElOSVQ6IFwiaW5pdFwiLFxuICBSRUFEWTogXCJyZWFkeVwiLFxuICBCRUFDT046IFwiYmVhY29uXCIsXG4gIFRPT0xUSVA6IFwidG9vbHRpcFwiLFxuICBDT01QTEVURTogXCJjb21wbGV0ZVwiLFxuICBFUlJPUjogXCJlcnJvclwiXG59O1xudmFyIE9SSUdJTiA9IHtcbiAgQlVUVE9OX0NMT1NFOiBcImJ1dHRvbl9jbG9zZVwiLFxuICBCVVRUT05fUFJJTUFSWTogXCJidXR0b25fcHJpbWFyeVwiLFxuICBLRVlCT0FSRDogXCJrZXlib2FyZFwiLFxuICBPVkVSTEFZOiBcIm92ZXJsYXlcIlxufTtcbnZhciBTVEFUVVMgPSB7XG4gIElETEU6IFwiaWRsZVwiLFxuICBSRUFEWTogXCJyZWFkeVwiLFxuICBXQUlUSU5HOiBcIndhaXRpbmdcIixcbiAgUlVOTklORzogXCJydW5uaW5nXCIsXG4gIFBBVVNFRDogXCJwYXVzZWRcIixcbiAgU0tJUFBFRDogXCJza2lwcGVkXCIsXG4gIEZJTklTSEVEOiBcImZpbmlzaGVkXCIsXG4gIEVSUk9SOiBcImVycm9yXCJcbn07XG52YXIgUE9SVEFMX0VMRU1FTlRfSUQgPSBcInJlYWN0LWpveXJpZGUtcG9ydGFsXCI7XG5cbi8vIHNyYy9tb2R1bGVzL2hlbHBlcnMudHN4XG5mdW5jdGlvbiBjbGVhblVwT2JqZWN0KGlucHV0KSB7XG4gIGNvbnN0IG91dHB1dCA9IHt9O1xuICBmb3IgKGNvbnN0IGtleSBpbiBpbnB1dCkge1xuICAgIGlmIChpbnB1dFtrZXldICE9PSB2b2lkIDApIHtcbiAgICAgIG91dHB1dFtrZXldID0gaW5wdXRba2V5XTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG91dHB1dDtcbn1cbmZ1bmN0aW9uIGdldEJyb3dzZXIodXNlckFnZW50ID0gbmF2aWdhdG9yLnVzZXJBZ2VudCkge1xuICBsZXQgYnJvd3NlciA9IHVzZXJBZ2VudDtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBicm93c2VyID0gXCJub2RlXCI7XG4gIH0gZWxzZSBpZiAoZG9jdW1lbnQuZG9jdW1lbnRNb2RlKSB7XG4gICAgYnJvd3NlciA9IFwiaWVcIjtcbiAgfSBlbHNlIGlmICgvRWRnZS8udGVzdCh1c2VyQWdlbnQpKSB7XG4gICAgYnJvd3NlciA9IFwiZWRnZVwiO1xuICB9IGVsc2UgaWYgKEJvb2xlYW4od2luZG93Lm9wZXJhKSB8fCB1c2VyQWdlbnQuaW5jbHVkZXMoXCIgT1BSL1wiKSkge1xuICAgIGJyb3dzZXIgPSBcIm9wZXJhXCI7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHdpbmRvdy5JbnN0YWxsVHJpZ2dlciAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIGJyb3dzZXIgPSBcImZpcmVmb3hcIjtcbiAgfSBlbHNlIGlmICh3aW5kb3cuY2hyb21lKSB7XG4gICAgYnJvd3NlciA9IFwiY2hyb21lXCI7XG4gIH0gZWxzZSBpZiAoLyhWZXJzaW9uXFwvKFtcXGQuX10rKS4qU2FmYXJpfENyaU9TfEZ4aU9TfCBNb2JpbGVcXC8pLy50ZXN0KHVzZXJBZ2VudCkpIHtcbiAgICBicm93c2VyID0gXCJzYWZhcmlcIjtcbiAgfVxuICByZXR1cm4gYnJvd3Nlcjtcbn1cbmZ1bmN0aW9uIGdldE9iamVjdFR5cGUodmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkuc2xpY2UoOCwgLTEpLnRvTG93ZXJDYXNlKCk7XG59XG5mdW5jdGlvbiBnZXRSZWFjdE5vZGVUZXh0KGlucHV0LCBvcHRpb25zID0ge30pIHtcbiAgY29uc3QgeyBkZWZhdWx0VmFsdWUsIHN0ZXAsIHN0ZXBzIH0gPSBvcHRpb25zO1xuICBsZXQgdGV4dCA9IGlubmVyVGV4dChpbnB1dCk7XG4gIGlmICghdGV4dCkge1xuICAgIGlmIChpc1ZhbGlkRWxlbWVudChpbnB1dCkgJiYgIU9iamVjdC52YWx1ZXMoaW5wdXQucHJvcHMpLmxlbmd0aCAmJiBnZXRPYmplY3RUeXBlKGlucHV0LnR5cGUpID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGNvbnN0IGNvbXBvbmVudCA9IGlucHV0LnR5cGUoe30pO1xuICAgICAgdGV4dCA9IGdldFJlYWN0Tm9kZVRleHQoY29tcG9uZW50LCBvcHRpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGV4dCA9IGlubmVyVGV4dChkZWZhdWx0VmFsdWUpO1xuICAgIH1cbiAgfSBlbHNlIGlmICgodGV4dC5pbmNsdWRlcyhcIntzdGVwfVwiKSB8fCB0ZXh0LmluY2x1ZGVzKFwie3N0ZXBzfVwiKSkgJiYgc3RlcCAmJiBzdGVwcykge1xuICAgIHRleHQgPSB0ZXh0LnJlcGxhY2UoXCJ7c3RlcH1cIiwgc3RlcC50b1N0cmluZygpKS5yZXBsYWNlKFwie3N0ZXBzfVwiLCBzdGVwcy50b1N0cmluZygpKTtcbiAgfVxuICByZXR1cm4gdGV4dDtcbn1cbmZ1bmN0aW9uIGhleFRvUkdCKGhleCkge1xuICBjb25zdCBzaG9ydGhhbmRSZWdleCA9IC9eIz8oW1xcZGEtZl0pKFtcXGRhLWZdKShbXFxkYS1mXSkkL2k7XG4gIGNvbnN0IHByb3BlckhleCA9IGhleC5yZXBsYWNlKHNob3J0aGFuZFJlZ2V4LCAoX20sIHIsIGcsIGIpID0+IHIgKyByICsgZyArIGcgKyBiICsgYik7XG4gIGNvbnN0IHJlc3VsdCA9IC9eIz8oW1xcZGEtZl17Mn0pKFtcXGRhLWZdezJ9KShbXFxkYS1mXXsyfSkkL2kuZXhlYyhwcm9wZXJIZXgpO1xuICByZXR1cm4gcmVzdWx0ID8gW3BhcnNlSW50KHJlc3VsdFsxXSwgMTYpLCBwYXJzZUludChyZXN1bHRbMl0sIDE2KSwgcGFyc2VJbnQocmVzdWx0WzNdLCAxNildIDogW107XG59XG5mdW5jdGlvbiBoaWRlQmVhY29uKHN0ZXAsIHN0YXRlLCBjb250aW51b3VzKSB7XG4gIGNvbnN0IHsgYWN0aW9uIH0gPSBzdGF0ZTtcbiAgY29uc3Qgd2l0aENvbnRpbnVvdXMgPSBjb250aW51b3VzICYmIFtBQ1RJT05TLlBSRVYsIEFDVElPTlMuTkVYVF0uaW5jbHVkZXMoYWN0aW9uKTtcbiAgcmV0dXJuIHN0ZXAuZGlzYWJsZUJlYWNvbiB8fCBzdGVwLnBsYWNlbWVudCA9PT0gXCJjZW50ZXJcIiB8fCB3aXRoQ29udGludW91cztcbn1cbmZ1bmN0aW9uIGlzTGVnYWN5KCkge1xuICByZXR1cm4gIVtcImNocm9tZVwiLCBcInNhZmFyaVwiLCBcImZpcmVmb3hcIiwgXCJvcGVyYVwiXS5pbmNsdWRlcyhnZXRCcm93c2VyKCkpO1xufVxuZnVuY3Rpb24gbG9nKHsgZGF0YSwgZGVidWcgPSBmYWxzZSwgdGl0bGUsIHdhcm4gPSBmYWxzZSB9KSB7XG4gIHZhciBfYTtcbiAgY29uc3QgbG9nRm4gPSB3YXJuID8gKF9hID0gY29uc29sZS53YXJuKSAhPSBudWxsID8gX2EgOiBjb25zb2xlLmVycm9yIDogY29uc29sZS5sb2c7XG4gIGlmIChkZWJ1Zykge1xuICAgIGlmICh0aXRsZSAmJiBkYXRhKSB7XG4gICAgICBjb25zb2xlLmdyb3VwQ29sbGFwc2VkKFxuICAgICAgICBgJWNyZWFjdC1qb3lyaWRlOiAke3RpdGxlfWAsXG4gICAgICAgIFwiY29sb3I6ICNmZjAwNDQ7IGZvbnQtd2VpZ2h0OiBib2xkOyBmb250LXNpemU6IDEycHg7XCJcbiAgICAgICk7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgICAgICBkYXRhLmZvckVhY2goKGQpID0+IHtcbiAgICAgICAgICBpZiAoaXMucGxhaW5PYmplY3QoZCkgJiYgZC5rZXkpIHtcbiAgICAgICAgICAgIGxvZ0ZuLmFwcGx5KGNvbnNvbGUsIFtkLmtleSwgZC52YWx1ZV0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsb2dGbi5hcHBseShjb25zb2xlLCBbZF0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsb2dGbi5hcHBseShjb25zb2xlLCBbZGF0YV0pO1xuICAgICAgfVxuICAgICAgY29uc29sZS5ncm91cEVuZCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiTWlzc2luZyB0aXRsZSBvciBkYXRhIHByb3BzXCIpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gbWVyZ2VQcm9wcyhkZWZhdWx0UHJvcHMyLCBwcm9wcykge1xuICBjb25zdCBjbGVhblByb3BzID0gY2xlYW5VcE9iamVjdChwcm9wcyk7XG4gIHJldHVybiB7IC4uLmRlZmF1bHRQcm9wczIsIC4uLmNsZWFuUHJvcHMgfTtcbn1cbmZ1bmN0aW9uIG5vb3AoKSB7XG4gIHJldHVybiB2b2lkIDA7XG59XG5mdW5jdGlvbiBvbWl0KGlucHV0LCAuLi5maWx0ZXIpIHtcbiAgaWYgKCFpcy5wbGFpbk9iamVjdChpbnB1dCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRXhwZWN0ZWQgYW4gb2JqZWN0XCIpO1xuICB9XG4gIGNvbnN0IG91dHB1dCA9IHt9O1xuICBmb3IgKGNvbnN0IGtleSBpbiBpbnB1dCkge1xuICAgIGlmICh7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGlucHV0LCBrZXkpKSB7XG4gICAgICBpZiAoIWZpbHRlci5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgIG91dHB1dFtrZXldID0gaW5wdXRba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG91dHB1dDtcbn1cbmZ1bmN0aW9uIHBpY2soaW5wdXQsIC4uLmZpbHRlcikge1xuICBpZiAoIWlzLnBsYWluT2JqZWN0KGlucHV0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCBhbiBvYmplY3RcIik7XG4gIH1cbiAgaWYgKCFmaWx0ZXIubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGlucHV0O1xuICB9XG4gIGNvbnN0IG91dHB1dCA9IHt9O1xuICBmb3IgKGNvbnN0IGtleSBpbiBpbnB1dCkge1xuICAgIGlmICh7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGlucHV0LCBrZXkpKSB7XG4gICAgICBpZiAoZmlsdGVyLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgb3V0cHV0W2tleV0gPSBpbnB1dFtrZXldO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gb3V0cHV0O1xufVxuZnVuY3Rpb24gcmVwbGFjZUxvY2FsZUNvbnRlbnQoaW5wdXQsIHN0ZXAsIHN0ZXBzKSB7XG4gIGNvbnN0IHJlcGxhY2VyID0gKHRleHQpID0+IHRleHQucmVwbGFjZShcIntzdGVwfVwiLCBTdHJpbmcoc3RlcCkpLnJlcGxhY2UoXCJ7c3RlcHN9XCIsIFN0cmluZyhzdGVwcykpO1xuICBpZiAoZ2V0T2JqZWN0VHlwZShpbnB1dCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gcmVwbGFjZXIoaW5wdXQpO1xuICB9XG4gIGlmICghaXNWYWxpZEVsZW1lbnQoaW5wdXQpKSB7XG4gICAgcmV0dXJuIGlucHV0O1xuICB9XG4gIGNvbnN0IHsgY2hpbGRyZW4gfSA9IGlucHV0LnByb3BzO1xuICBpZiAoZ2V0T2JqZWN0VHlwZShjaGlsZHJlbikgPT09IFwic3RyaW5nXCIgJiYgY2hpbGRyZW4uaW5jbHVkZXMoXCJ7c3RlcH1cIikpIHtcbiAgICByZXR1cm4gY2xvbmVFbGVtZW50KGlucHV0LCB7XG4gICAgICBjaGlsZHJlbjogcmVwbGFjZXIoY2hpbGRyZW4pXG4gICAgfSk7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgcmV0dXJuIGNsb25lRWxlbWVudChpbnB1dCwge1xuICAgICAgY2hpbGRyZW46IGNoaWxkcmVuLm1hcCgoY2hpbGQpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjaGlsZCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIHJldHVybiByZXBsYWNlcihjaGlsZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcGxhY2VMb2NhbGVDb250ZW50KGNoaWxkLCBzdGVwLCBzdGVwcyk7XG4gICAgICB9KVxuICAgIH0pO1xuICB9XG4gIGlmIChnZXRPYmplY3RUeXBlKGlucHV0LnR5cGUpID09PSBcImZ1bmN0aW9uXCIgJiYgIU9iamVjdC52YWx1ZXMoaW5wdXQucHJvcHMpLmxlbmd0aCkge1xuICAgIGNvbnN0IGNvbXBvbmVudCA9IGlucHV0LnR5cGUoe30pO1xuICAgIHJldHVybiByZXBsYWNlTG9jYWxlQ29udGVudChjb21wb25lbnQsIHN0ZXAsIHN0ZXBzKTtcbiAgfVxuICByZXR1cm4gaW5wdXQ7XG59XG5mdW5jdGlvbiBzaG91bGRTY3JvbGwob3B0aW9ucykge1xuICBjb25zdCB7IGlzRmlyc3RTdGVwLCBsaWZlY3ljbGUsIHByZXZpb3VzTGlmZWN5Y2xlLCBzY3JvbGxUb0ZpcnN0U3RlcCwgc3RlcCwgdGFyZ2V0IH0gPSBvcHRpb25zO1xuICByZXR1cm4gIXN0ZXAuZGlzYWJsZVNjcm9sbGluZyAmJiAoIWlzRmlyc3RTdGVwIHx8IHNjcm9sbFRvRmlyc3RTdGVwIHx8IGxpZmVjeWNsZSA9PT0gTElGRUNZQ0xFLlRPT0xUSVApICYmIHN0ZXAucGxhY2VtZW50ICE9PSBcImNlbnRlclwiICYmICghc3RlcC5pc0ZpeGVkIHx8ICFoYXNQb3NpdGlvbih0YXJnZXQpKSAmJiAvLyBmaXhlZCBzdGVwcyBkb24ndCBuZWVkIHRvIHNjcm9sbFxuICBwcmV2aW91c0xpZmVjeWNsZSAhPT0gbGlmZWN5Y2xlICYmIFtMSUZFQ1lDTEUuQkVBQ09OLCBMSUZFQ1lDTEUuVE9PTFRJUF0uaW5jbHVkZXMobGlmZWN5Y2xlKTtcbn1cblxuLy8gc3JjL21vZHVsZXMvc3RlcC50c1xuaW1wb3J0IGRlZXBtZXJnZTIgZnJvbSBcImRlZXBtZXJnZVwiO1xuaW1wb3J0IGlzMiBmcm9tIFwiaXMtbGl0ZVwiO1xuXG4vLyBzcmMvZGVmYXVsdHMudHNcbnZhciBkZWZhdWx0RmxvYXRlclByb3BzID0ge1xuICBtb2RpZmllcnM6IHtcbiAgICBwcmV2ZW50T3ZlcmZsb3c6IHtcbiAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgcm9vdEJvdW5kYXJ5OiBcInZpZXdwb3J0XCJcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIHdyYXBwZXJPcHRpb25zOiB7XG4gICAgb2Zmc2V0OiAtMTgsXG4gICAgcG9zaXRpb246IHRydWVcbiAgfVxufTtcbnZhciBkZWZhdWx0TG9jYWxlID0ge1xuICBiYWNrOiBcIkJhY2tcIixcbiAgY2xvc2U6IFwiQ2xvc2VcIixcbiAgbGFzdDogXCJMYXN0XCIsXG4gIG5leHQ6IFwiTmV4dFwiLFxuICBuZXh0TGFiZWxXaXRoUHJvZ3Jlc3M6IFwiTmV4dCAoU3RlcCB7c3RlcH0gb2Yge3N0ZXBzfSlcIixcbiAgb3BlbjogXCJPcGVuIHRoZSBkaWFsb2dcIixcbiAgc2tpcDogXCJTa2lwXCJcbn07XG52YXIgZGVmYXVsdFN0ZXAgPSB7XG4gIGV2ZW50OiBcImNsaWNrXCIsXG4gIHBsYWNlbWVudDogXCJib3R0b21cIixcbiAgb2Zmc2V0OiAxMCxcbiAgZGlzYWJsZUJlYWNvbjogZmFsc2UsXG4gIGRpc2FibGVDbG9zZU9uRXNjOiBmYWxzZSxcbiAgZGlzYWJsZU92ZXJsYXk6IGZhbHNlLFxuICBkaXNhYmxlT3ZlcmxheUNsb3NlOiBmYWxzZSxcbiAgZGlzYWJsZVNjcm9sbFBhcmVudEZpeDogZmFsc2UsXG4gIGRpc2FibGVTY3JvbGxpbmc6IGZhbHNlLFxuICBoaWRlQmFja0J1dHRvbjogZmFsc2UsXG4gIGhpZGVDbG9zZUJ1dHRvbjogZmFsc2UsXG4gIGhpZGVGb290ZXI6IGZhbHNlLFxuICBpc0ZpeGVkOiBmYWxzZSxcbiAgbG9jYWxlOiBkZWZhdWx0TG9jYWxlLFxuICBzaG93UHJvZ3Jlc3M6IGZhbHNlLFxuICBzaG93U2tpcEJ1dHRvbjogZmFsc2UsXG4gIHNwb3RsaWdodENsaWNrczogZmFsc2UsXG4gIHNwb3RsaWdodFBhZGRpbmc6IDEwXG59O1xudmFyIGRlZmF1bHRQcm9wcyA9IHtcbiAgY29udGludW91czogZmFsc2UsXG4gIGRlYnVnOiBmYWxzZSxcbiAgZGlzYWJsZUNsb3NlT25Fc2M6IGZhbHNlLFxuICBkaXNhYmxlT3ZlcmxheTogZmFsc2UsXG4gIGRpc2FibGVPdmVybGF5Q2xvc2U6IGZhbHNlLFxuICBkaXNhYmxlU2Nyb2xsaW5nOiBmYWxzZSxcbiAgZGlzYWJsZVNjcm9sbFBhcmVudEZpeDogZmFsc2UsXG4gIGdldEhlbHBlcnM6IG5vb3AoKSxcbiAgaGlkZUJhY2tCdXR0b246IGZhbHNlLFxuICBydW46IHRydWUsXG4gIHNjcm9sbE9mZnNldDogMjAsXG4gIHNjcm9sbER1cmF0aW9uOiAzMDAsXG4gIHNjcm9sbFRvRmlyc3RTdGVwOiBmYWxzZSxcbiAgc2hvd1NraXBCdXR0b246IGZhbHNlLFxuICBzaG93UHJvZ3Jlc3M6IGZhbHNlLFxuICBzcG90bGlnaHRDbGlja3M6IGZhbHNlLFxuICBzcG90bGlnaHRQYWRkaW5nOiAxMCxcbiAgc3RlcHM6IFtdXG59O1xudmFyIGRlZmF1bHRTdGF0ZSA9IHtcbiAgYWN0aW9uOiBBQ1RJT05TLklOSVQsXG4gIGNvbnRyb2xsZWQ6IGZhbHNlLFxuICBpbmRleDogMCxcbiAgbGlmZWN5Y2xlOiBMSUZFQ1lDTEUuSU5JVCxcbiAgb3JpZ2luOiBudWxsLFxuICBzaXplOiAwLFxuICBzdGF0dXM6IFNUQVRVUy5JRExFXG59O1xuXG4vLyBzcmMvc3R5bGVzLnRzXG5pbXBvcnQgZGVlcG1lcmdlIGZyb20gXCJkZWVwbWVyZ2VcIjtcbnZhciBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgYXJyb3dDb2xvcjogXCIjZmZmXCIsXG4gIGJhY2tncm91bmRDb2xvcjogXCIjZmZmXCIsXG4gIGJlYWNvblNpemU6IDM2LFxuICBvdmVybGF5Q29sb3I6IFwicmdiYSgwLCAwLCAwLCAwLjUpXCIsXG4gIHByaW1hcnlDb2xvcjogXCIjZjA0XCIsXG4gIHNwb3RsaWdodFNoYWRvdzogXCIwIDAgMTVweCByZ2JhKDAsIDAsIDAsIDAuNSlcIixcbiAgdGV4dENvbG9yOiBcIiMzMzNcIixcbiAgd2lkdGg6IDM4MCxcbiAgekluZGV4OiAxMDBcbn07XG52YXIgYnV0dG9uQmFzZSA9IHtcbiAgYmFja2dyb3VuZENvbG9yOiBcInRyYW5zcGFyZW50XCIsXG4gIGJvcmRlcjogMCxcbiAgYm9yZGVyUmFkaXVzOiAwLFxuICBjb2xvcjogXCIjNTU1XCIsXG4gIGN1cnNvcjogXCJwb2ludGVyXCIsXG4gIGZvbnRTaXplOiAxNixcbiAgbGluZUhlaWdodDogMSxcbiAgcGFkZGluZzogOCxcbiAgV2Via2l0QXBwZWFyYW5jZTogXCJub25lXCJcbn07XG52YXIgc3BvdGxpZ2h0ID0ge1xuICBib3JkZXJSYWRpdXM6IDQsXG4gIHBvc2l0aW9uOiBcImFic29sdXRlXCJcbn07XG5mdW5jdGlvbiBnZXRTdHlsZXMocHJvcHMsIHN0ZXApIHtcbiAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZTtcbiAgY29uc3QgeyBmbG9hdGVyUHJvcHMsIHN0eWxlcyB9ID0gcHJvcHM7XG4gIGNvbnN0IG1lcmdlZEZsb2F0ZXJQcm9wcyA9IGRlZXBtZXJnZSgoX2EgPSBzdGVwLmZsb2F0ZXJQcm9wcykgIT0gbnVsbCA/IF9hIDoge30sIGZsb2F0ZXJQcm9wcyAhPSBudWxsID8gZmxvYXRlclByb3BzIDoge30pO1xuICBjb25zdCBtZXJnZWRTdHlsZXMgPSBkZWVwbWVyZ2Uoc3R5bGVzICE9IG51bGwgPyBzdHlsZXMgOiB7fSwgKF9iID0gc3RlcC5zdHlsZXMpICE9IG51bGwgPyBfYiA6IHt9KTtcbiAgY29uc3Qgb3B0aW9ucyA9IGRlZXBtZXJnZShkZWZhdWx0T3B0aW9ucywgbWVyZ2VkU3R5bGVzLm9wdGlvbnMgfHwge30pO1xuICBjb25zdCBoaWRlQmVhY29uMiA9IHN0ZXAucGxhY2VtZW50ID09PSBcImNlbnRlclwiIHx8IHN0ZXAuZGlzYWJsZUJlYWNvbjtcbiAgbGV0IHsgd2lkdGggfSA9IG9wdGlvbnM7XG4gIGlmICh3aW5kb3cuaW5uZXJXaWR0aCA+IDQ4MCkge1xuICAgIHdpZHRoID0gMzgwO1xuICB9XG4gIGlmIChcIndpZHRoXCIgaW4gb3B0aW9ucykge1xuICAgIHdpZHRoID0gdHlwZW9mIG9wdGlvbnMud2lkdGggPT09IFwibnVtYmVyXCIgJiYgd2luZG93LmlubmVyV2lkdGggPCBvcHRpb25zLndpZHRoID8gd2luZG93LmlubmVyV2lkdGggLSAzMCA6IG9wdGlvbnMud2lkdGg7XG4gIH1cbiAgY29uc3Qgb3ZlcmxheSA9IHtcbiAgICBib3R0b206IDAsXG4gICAgbGVmdDogMCxcbiAgICBvdmVyZmxvdzogXCJoaWRkZW5cIixcbiAgICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLFxuICAgIHJpZ2h0OiAwLFxuICAgIHRvcDogMCxcbiAgICB6SW5kZXg6IG9wdGlvbnMuekluZGV4XG4gIH07XG4gIGNvbnN0IGRlZmF1bHRTdHlsZXMgPSB7XG4gICAgYmVhY29uOiB7XG4gICAgICAuLi5idXR0b25CYXNlLFxuICAgICAgZGlzcGxheTogaGlkZUJlYWNvbjIgPyBcIm5vbmVcIiA6IFwiaW5saW5lLWJsb2NrXCIsXG4gICAgICBoZWlnaHQ6IG9wdGlvbnMuYmVhY29uU2l6ZSxcbiAgICAgIHBvc2l0aW9uOiBcInJlbGF0aXZlXCIsXG4gICAgICB3aWR0aDogb3B0aW9ucy5iZWFjb25TaXplLFxuICAgICAgekluZGV4OiBvcHRpb25zLnpJbmRleFxuICAgIH0sXG4gICAgYmVhY29uSW5uZXI6IHtcbiAgICAgIGFuaW1hdGlvbjogXCJqb3lyaWRlLWJlYWNvbi1pbm5lciAxLjJzIGluZmluaXRlIGVhc2UtaW4tb3V0XCIsXG4gICAgICBiYWNrZ3JvdW5kQ29sb3I6IG9wdGlvbnMucHJpbWFyeUNvbG9yLFxuICAgICAgYm9yZGVyUmFkaXVzOiBcIjUwJVwiLFxuICAgICAgZGlzcGxheTogXCJibG9ja1wiLFxuICAgICAgaGVpZ2h0OiBcIjUwJVwiLFxuICAgICAgbGVmdDogXCI1MCVcIixcbiAgICAgIG9wYWNpdHk6IDAuNyxcbiAgICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCIsXG4gICAgICB0b3A6IFwiNTAlXCIsXG4gICAgICB0cmFuc2Zvcm06IFwidHJhbnNsYXRlKC01MCUsIC01MCUpXCIsXG4gICAgICB3aWR0aDogXCI1MCVcIlxuICAgIH0sXG4gICAgYmVhY29uT3V0ZXI6IHtcbiAgICAgIGFuaW1hdGlvbjogXCJqb3lyaWRlLWJlYWNvbi1vdXRlciAxLjJzIGluZmluaXRlIGVhc2UtaW4tb3V0XCIsXG4gICAgICBiYWNrZ3JvdW5kQ29sb3I6IGByZ2JhKCR7aGV4VG9SR0Iob3B0aW9ucy5wcmltYXJ5Q29sb3IpLmpvaW4oXCIsXCIpfSwgMC4yKWAsXG4gICAgICBib3JkZXI6IGAycHggc29saWQgJHtvcHRpb25zLnByaW1hcnlDb2xvcn1gLFxuICAgICAgYm9yZGVyUmFkaXVzOiBcIjUwJVwiLFxuICAgICAgYm94U2l6aW5nOiBcImJvcmRlci1ib3hcIixcbiAgICAgIGRpc3BsYXk6IFwiYmxvY2tcIixcbiAgICAgIGhlaWdodDogXCIxMDAlXCIsXG4gICAgICBsZWZ0OiAwLFxuICAgICAgb3BhY2l0eTogMC45LFxuICAgICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIixcbiAgICAgIHRvcDogMCxcbiAgICAgIHRyYW5zZm9ybU9yaWdpbjogXCJjZW50ZXJcIixcbiAgICAgIHdpZHRoOiBcIjEwMCVcIlxuICAgIH0sXG4gICAgdG9vbHRpcDoge1xuICAgICAgYmFja2dyb3VuZENvbG9yOiBvcHRpb25zLmJhY2tncm91bmRDb2xvcixcbiAgICAgIGJvcmRlclJhZGl1czogNSxcbiAgICAgIGJveFNpemluZzogXCJib3JkZXItYm94XCIsXG4gICAgICBjb2xvcjogb3B0aW9ucy50ZXh0Q29sb3IsXG4gICAgICBmb250U2l6ZTogMTYsXG4gICAgICBtYXhXaWR0aDogXCIxMDAlXCIsXG4gICAgICBwYWRkaW5nOiAxNSxcbiAgICAgIHBvc2l0aW9uOiBcInJlbGF0aXZlXCIsXG4gICAgICB3aWR0aFxuICAgIH0sXG4gICAgdG9vbHRpcENvbnRhaW5lcjoge1xuICAgICAgbGluZUhlaWdodDogMS40LFxuICAgICAgdGV4dEFsaWduOiBcImNlbnRlclwiXG4gICAgfSxcbiAgICB0b29sdGlwVGl0bGU6IHtcbiAgICAgIGZvbnRTaXplOiAxOCxcbiAgICAgIG1hcmdpbjogMFxuICAgIH0sXG4gICAgdG9vbHRpcENvbnRlbnQ6IHtcbiAgICAgIHBhZGRpbmc6IFwiMjBweCAxMHB4XCJcbiAgICB9LFxuICAgIHRvb2x0aXBGb290ZXI6IHtcbiAgICAgIGFsaWduSXRlbXM6IFwiY2VudGVyXCIsXG4gICAgICBkaXNwbGF5OiBcImZsZXhcIixcbiAgICAgIGp1c3RpZnlDb250ZW50OiBcImZsZXgtZW5kXCIsXG4gICAgICBtYXJnaW5Ub3A6IDE1XG4gICAgfSxcbiAgICB0b29sdGlwRm9vdGVyU3BhY2VyOiB7XG4gICAgICBmbGV4OiAxXG4gICAgfSxcbiAgICBidXR0b25OZXh0OiB7XG4gICAgICAuLi5idXR0b25CYXNlLFxuICAgICAgYmFja2dyb3VuZENvbG9yOiBvcHRpb25zLnByaW1hcnlDb2xvcixcbiAgICAgIGJvcmRlclJhZGl1czogNCxcbiAgICAgIGNvbG9yOiBcIiNmZmZcIlxuICAgIH0sXG4gICAgYnV0dG9uQmFjazoge1xuICAgICAgLi4uYnV0dG9uQmFzZSxcbiAgICAgIGNvbG9yOiBvcHRpb25zLnByaW1hcnlDb2xvcixcbiAgICAgIG1hcmdpbkxlZnQ6IFwiYXV0b1wiLFxuICAgICAgbWFyZ2luUmlnaHQ6IDVcbiAgICB9LFxuICAgIGJ1dHRvbkNsb3NlOiB7XG4gICAgICAuLi5idXR0b25CYXNlLFxuICAgICAgY29sb3I6IG9wdGlvbnMudGV4dENvbG9yLFxuICAgICAgaGVpZ2h0OiAxNCxcbiAgICAgIHBhZGRpbmc6IDE1LFxuICAgICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIixcbiAgICAgIHJpZ2h0OiAwLFxuICAgICAgdG9wOiAwLFxuICAgICAgd2lkdGg6IDE0XG4gICAgfSxcbiAgICBidXR0b25Ta2lwOiB7XG4gICAgICAuLi5idXR0b25CYXNlLFxuICAgICAgY29sb3I6IG9wdGlvbnMudGV4dENvbG9yLFxuICAgICAgZm9udFNpemU6IDE0XG4gICAgfSxcbiAgICBvdmVybGF5OiB7XG4gICAgICAuLi5vdmVybGF5LFxuICAgICAgYmFja2dyb3VuZENvbG9yOiBvcHRpb25zLm92ZXJsYXlDb2xvcixcbiAgICAgIG1peEJsZW5kTW9kZTogXCJoYXJkLWxpZ2h0XCJcbiAgICB9LFxuICAgIG92ZXJsYXlMZWdhY3k6IHtcbiAgICAgIC4uLm92ZXJsYXlcbiAgICB9LFxuICAgIG92ZXJsYXlMZWdhY3lDZW50ZXI6IHtcbiAgICAgIC4uLm92ZXJsYXksXG4gICAgICBiYWNrZ3JvdW5kQ29sb3I6IG9wdGlvbnMub3ZlcmxheUNvbG9yXG4gICAgfSxcbiAgICBzcG90bGlnaHQ6IHtcbiAgICAgIC4uLnNwb3RsaWdodCxcbiAgICAgIGJhY2tncm91bmRDb2xvcjogXCJncmF5XCJcbiAgICB9LFxuICAgIHNwb3RsaWdodExlZ2FjeToge1xuICAgICAgLi4uc3BvdGxpZ2h0LFxuICAgICAgYm94U2hhZG93OiBgMCAwIDAgOTk5OXB4ICR7b3B0aW9ucy5vdmVybGF5Q29sb3J9LCAke29wdGlvbnMuc3BvdGxpZ2h0U2hhZG93fWBcbiAgICB9LFxuICAgIGZsb2F0ZXJTdHlsZXM6IHtcbiAgICAgIGFycm93OiB7XG4gICAgICAgIGNvbG9yOiAoX2UgPSAoX2QgPSAoX2MgPSBtZXJnZWRGbG9hdGVyUHJvcHMgPT0gbnVsbCA/IHZvaWQgMCA6IG1lcmdlZEZsb2F0ZXJQcm9wcy5zdHlsZXMpID09IG51bGwgPyB2b2lkIDAgOiBfYy5hcnJvdykgPT0gbnVsbCA/IHZvaWQgMCA6IF9kLmNvbG9yKSAhPSBudWxsID8gX2UgOiBvcHRpb25zLmFycm93Q29sb3JcbiAgICAgIH0sXG4gICAgICBvcHRpb25zOiB7XG4gICAgICAgIHpJbmRleDogb3B0aW9ucy56SW5kZXggKyAxMDBcbiAgICAgIH1cbiAgICB9LFxuICAgIG9wdGlvbnNcbiAgfTtcbiAgcmV0dXJuIGRlZXBtZXJnZShkZWZhdWx0U3R5bGVzLCBtZXJnZWRTdHlsZXMpO1xufVxuXG4vLyBzcmMvbW9kdWxlcy9zdGVwLnRzXG5mdW5jdGlvbiBnZXRUb3VyUHJvcHMocHJvcHMpIHtcbiAgcmV0dXJuIHBpY2soXG4gICAgcHJvcHMsXG4gICAgXCJiZWFjb25Db21wb25lbnRcIixcbiAgICBcImRpc2FibGVDbG9zZU9uRXNjXCIsXG4gICAgXCJkaXNhYmxlT3ZlcmxheVwiLFxuICAgIFwiZGlzYWJsZU92ZXJsYXlDbG9zZVwiLFxuICAgIFwiZGlzYWJsZVNjcm9sbGluZ1wiLFxuICAgIFwiZGlzYWJsZVNjcm9sbFBhcmVudEZpeFwiLFxuICAgIFwiZmxvYXRlclByb3BzXCIsXG4gICAgXCJoaWRlQmFja0J1dHRvblwiLFxuICAgIFwiaGlkZUNsb3NlQnV0dG9uXCIsXG4gICAgXCJsb2NhbGVcIixcbiAgICBcInNob3dQcm9ncmVzc1wiLFxuICAgIFwic2hvd1NraXBCdXR0b25cIixcbiAgICBcInNwb3RsaWdodENsaWNrc1wiLFxuICAgIFwic3BvdGxpZ2h0UGFkZGluZ1wiLFxuICAgIFwic3R5bGVzXCIsXG4gICAgXCJ0b29sdGlwQ29tcG9uZW50XCJcbiAgKTtcbn1cbmZ1bmN0aW9uIGdldE1lcmdlZFN0ZXAocHJvcHMsIGN1cnJlbnRTdGVwKSB7XG4gIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mO1xuICBpZiAoIWN1cnJlbnRTdGVwKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3Qgc3RlcCA9IGN1cnJlbnRTdGVwICE9IG51bGwgPyBjdXJyZW50U3RlcCA6IHt9O1xuICBjb25zdCBtZXJnZWRTdGVwID0gZGVlcG1lcmdlMi5hbGwoW2RlZmF1bHRTdGVwLCBnZXRUb3VyUHJvcHMocHJvcHMpLCBzdGVwXSwge1xuICAgIGlzTWVyZ2VhYmxlT2JqZWN0OiBpczIucGxhaW5PYmplY3RcbiAgfSk7XG4gIGNvbnN0IG1lcmdlZFN0eWxlcyA9IGdldFN0eWxlcyhwcm9wcywgbWVyZ2VkU3RlcCk7XG4gIGNvbnN0IHNjcm9sbFBhcmVudDIgPSBoYXNDdXN0b21TY3JvbGxQYXJlbnQoXG4gICAgZ2V0RWxlbWVudChtZXJnZWRTdGVwLnRhcmdldCksXG4gICAgbWVyZ2VkU3RlcC5kaXNhYmxlU2Nyb2xsUGFyZW50Rml4XG4gICk7XG4gIGNvbnN0IGZsb2F0ZXJQcm9wcyA9IGRlZXBtZXJnZTIuYWxsKFtcbiAgICBkZWZhdWx0RmxvYXRlclByb3BzLFxuICAgIChfYSA9IHByb3BzLmZsb2F0ZXJQcm9wcykgIT0gbnVsbCA/IF9hIDoge30sXG4gICAgKF9iID0gbWVyZ2VkU3RlcC5mbG9hdGVyUHJvcHMpICE9IG51bGwgPyBfYiA6IHt9XG4gIF0pO1xuICBmbG9hdGVyUHJvcHMub2Zmc2V0ID0gbWVyZ2VkU3RlcC5vZmZzZXQ7XG4gIGZsb2F0ZXJQcm9wcy5zdHlsZXMgPSBkZWVwbWVyZ2UyKChfYyA9IGZsb2F0ZXJQcm9wcy5zdHlsZXMpICE9IG51bGwgPyBfYyA6IHt9LCBtZXJnZWRTdHlsZXMuZmxvYXRlclN0eWxlcyk7XG4gIGZsb2F0ZXJQcm9wcy5vZmZzZXQgKz0gKF9lID0gKF9kID0gcHJvcHMuc3BvdGxpZ2h0UGFkZGluZykgIT0gbnVsbCA/IF9kIDogbWVyZ2VkU3RlcC5zcG90bGlnaHRQYWRkaW5nKSAhPSBudWxsID8gX2UgOiAwO1xuICBpZiAobWVyZ2VkU3RlcC5wbGFjZW1lbnRCZWFjb24gJiYgZmxvYXRlclByb3BzLndyYXBwZXJPcHRpb25zKSB7XG4gICAgZmxvYXRlclByb3BzLndyYXBwZXJPcHRpb25zLnBsYWNlbWVudCA9IG1lcmdlZFN0ZXAucGxhY2VtZW50QmVhY29uO1xuICB9XG4gIGlmIChzY3JvbGxQYXJlbnQyICYmIGZsb2F0ZXJQcm9wcy5tb2RpZmllcnMucHJldmVudE92ZXJmbG93KSB7XG4gICAgZmxvYXRlclByb3BzLm1vZGlmaWVycy5wcmV2ZW50T3ZlcmZsb3cub3B0aW9ucyA9IHtcbiAgICAgIC4uLmZsb2F0ZXJQcm9wcy5tb2RpZmllcnMucHJldmVudE92ZXJmbG93Lm9wdGlvbnMsXG4gICAgICByb290Qm91bmRhcnk6IFwidmlld3BvcnRcIixcbiAgICAgIGJvdW5kYXJ5OiBcImNsaXBwaW5nUGFyZW50c1wiXG4gICAgfTtcbiAgfVxuICByZXR1cm4ge1xuICAgIC4uLm1lcmdlZFN0ZXAsXG4gICAgbG9jYWxlOiBkZWVwbWVyZ2UyLmFsbChbZGVmYXVsdExvY2FsZSwgKF9mID0gcHJvcHMubG9jYWxlKSAhPSBudWxsID8gX2YgOiB7fSwgbWVyZ2VkU3RlcC5sb2NhbGUgfHwge31dKSxcbiAgICBmbG9hdGVyUHJvcHMsXG4gICAgc3R5bGVzOiBvbWl0KG1lcmdlZFN0eWxlcywgXCJmbG9hdGVyU3R5bGVzXCIpXG4gIH07XG59XG5mdW5jdGlvbiB2YWxpZGF0ZVN0ZXAoc3RlcCwgZGVidWcgPSBmYWxzZSkge1xuICBpZiAoIWlzMi5wbGFpbk9iamVjdChzdGVwKSkge1xuICAgIGxvZyh7XG4gICAgICB0aXRsZTogXCJ2YWxpZGF0ZVN0ZXBcIixcbiAgICAgIGRhdGE6IFwic3RlcCBtdXN0IGJlIGFuIG9iamVjdFwiLFxuICAgICAgd2FybjogdHJ1ZSxcbiAgICAgIGRlYnVnXG4gICAgfSk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICghc3RlcC50YXJnZXQpIHtcbiAgICBsb2coe1xuICAgICAgdGl0bGU6IFwidmFsaWRhdGVTdGVwXCIsXG4gICAgICBkYXRhOiBcInRhcmdldCBpcyBtaXNzaW5nIGZyb20gdGhlIHN0ZXBcIixcbiAgICAgIHdhcm46IHRydWUsXG4gICAgICBkZWJ1Z1xuICAgIH0pO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlU3RlcHMoc3RlcHMsIGRlYnVnID0gZmFsc2UpIHtcbiAgaWYgKCFpczIuYXJyYXkoc3RlcHMpKSB7XG4gICAgbG9nKHtcbiAgICAgIHRpdGxlOiBcInZhbGlkYXRlU3RlcHNcIixcbiAgICAgIGRhdGE6IFwic3RlcHMgbXVzdCBiZSBhbiBhcnJheVwiLFxuICAgICAgd2FybjogdHJ1ZSxcbiAgICAgIGRlYnVnXG4gICAgfSk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBzdGVwcy5ldmVyeSgoZCkgPT4gdmFsaWRhdGVTdGVwKGQsIGRlYnVnKSk7XG59XG5cbi8vIHNyYy9tb2R1bGVzL3VzZUpveXJpZGVEYXRhLnRzXG5pbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlTWVtbywgdXNlUmVmIH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgaXNFcXVhbCBmcm9tIFwiQGdpbGJhcmJhcmEvZGVlcC1lcXVhbFwiO1xuaW1wb3J0IHtcbiAgdXNlRGVlcENvbXBhcmVFZmZlY3QsXG4gIHVzZU1vdW50LFxuICB1c2VQcmV2aW91cyxcbiAgdXNlU2V0U3RhdGUsXG4gIHVzZVNpbmdsZXRvbixcbiAgdXNlVXBkYXRlRWZmZWN0XG59IGZyb20gXCJAZ2lsYmFyYmFyYS9ob29rc1wiO1xuaW1wb3J0IGlzNCBmcm9tIFwiaXMtbGl0ZVwiO1xuaW1wb3J0IHVzZVRyZWVDaGFuZ2VzIGZyb20gXCJ0cmVlLWNoYW5nZXMtaG9va1wiO1xuXG4vLyBzcmMvbW9kdWxlcy9zdG9yZS50c1xuaW1wb3J0IGRlZXBFcXVhbCBmcm9tIFwiQGdpbGJhcmJhcmEvZGVlcC1lcXVhbFwiO1xuaW1wb3J0IGlzMyBmcm9tIFwiaXMtbGl0ZVwiO1xudmFyIGRlZmF1bHRTdGF0ZTIgPSB7XG4gIGFjdGlvbjogXCJpbml0XCIsXG4gIGNvbnRyb2xsZWQ6IGZhbHNlLFxuICBpbmRleDogMCxcbiAgbGlmZWN5Y2xlOiBMSUZFQ1lDTEUuSU5JVCxcbiAgb3JpZ2luOiBudWxsLFxuICBzaXplOiAwLFxuICBzdGF0dXM6IFNUQVRVUy5JRExFXG59O1xudmFyIFN0b3JlID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImJlYWNvblBvcHBlclwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwidG9vbHRpcFBvcHBlclwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiZGF0YVwiLCAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwibGlzdGVuZXJcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInByb3BzXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJzdG9yZVwiLCAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwidXBkYXRlU3RhdGVcIiwgKHBhdGNoLCBmb3JjZUluZGV4ID0gZmFsc2UpID0+IHtcbiAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAuLi50aGlzLmdldFN0YXRlKCksXG4gICAgICAgIC4uLnRoaXMucHJlcGFyZVN0YXRlKHBhdGNoLCBmb3JjZUluZGV4KVxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImNsZWFudXBQb3BwZXJzXCIsICgpID0+IHtcbiAgICAgIHRoaXMuYmVhY29uUG9wcGVyID0gbnVsbDtcbiAgICAgIHRoaXMudG9vbHRpcFBvcHBlciA9IG51bGw7XG4gICAgfSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImdldFBvcHBlclwiLCAobmFtZSkgPT4ge1xuICAgICAgaWYgKG5hbWUgPT09IFwiYmVhY29uXCIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmVhY29uUG9wcGVyO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMudG9vbHRpcFBvcHBlcjtcbiAgICB9KTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwic2V0UG9wcGVyXCIsIChwb3BwZXIsIHR5cGUpID0+IHtcbiAgICAgIHZhciBfYSwgX2I7XG4gICAgICBpZiAodHlwZSA9PT0gXCJ3cmFwcGVyXCIpIHtcbiAgICAgICAgdGhpcy5iZWFjb25Qb3BwZXIgPSBwb3BwZXI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnRvb2x0aXBQb3BwZXIgPSBwb3BwZXI7XG4gICAgICB9XG4gICAgICBpZiAocG9wcGVyICYmIHRoaXMuc3RvcmUuZ2V0KFwibGlmZWN5Y2xlXCIpID09PSBMSUZFQ1lDTEUuQ09NUExFVEUpIHtcbiAgICAgICAgdGhpcy51cGRhdGVTdGF0ZSh7XG4gICAgICAgICAgYWN0aW9uOiBBQ1RJT05TLlVQREFURSxcbiAgICAgICAgICBsaWZlY3ljbGU6IExJRkVDWUNMRS5JTklUXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgY29uc3QgZ2V0UG9wcGVyID0gKF9iID0gKF9hID0gdGhpcy5nZXRTdGVwKCkpID09IG51bGwgPyB2b2lkIDAgOiBfYS5mbG9hdGVyUHJvcHMpID09IG51bGwgPyB2b2lkIDAgOiBfYi5nZXRQb3BwZXI7XG4gICAgICBpZiAoZ2V0UG9wcGVyKSB7XG4gICAgICAgIGdldFBvcHBlcihwb3BwZXIsIHR5cGUpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJhZGRMaXN0ZW5lclwiLCAobGlzdGVuZXIpID0+IHtcbiAgICAgIHRoaXMubGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgICB9KTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwic2V0U3RlcHNcIiwgKHN0ZXBzKSA9PiB7XG4gICAgICBjb25zdCB7IHNpemUsIHN0YXR1cyB9ID0gdGhpcy5nZXRTdGF0ZSgpO1xuICAgICAgY29uc3Qgc3RhdGUgPSB7XG4gICAgICAgIHNpemU6IHN0ZXBzLmxlbmd0aCxcbiAgICAgICAgc3RhdHVzXG4gICAgICB9O1xuICAgICAgdGhpcy5kYXRhLnNldChcInN0ZXBzXCIsIHN0ZXBzKTtcbiAgICAgIGlmIChzdGF0dXMgPT09IFNUQVRVUy5XQUlUSU5HICYmICFzaXplICYmIHN0ZXBzLmxlbmd0aCkge1xuICAgICAgICBzdGF0ZS5zdGF0dXMgPSBTVEFUVVMuUlVOTklORztcbiAgICAgIH1cbiAgICAgIHRoaXMudXBkYXRlU3RhdGUoc3RhdGUpO1xuICAgIH0pO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJjbG9zZVwiLCAob3JpZ2luID0gbnVsbCkgPT4ge1xuICAgICAgY29uc3QgeyBpbmRleCwgc3RhdHVzIH0gPSB0aGlzLmdldFN0YXRlKCk7XG4gICAgICBpZiAoc3RhdHVzICE9PSBTVEFUVVMuUlVOTklORykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLnVwZGF0ZVN0YXRlKHtcbiAgICAgICAgYWN0aW9uOiBBQ1RJT05TLkNMT1NFLFxuICAgICAgICBpbmRleDogaW5kZXggKyAxLFxuICAgICAgICBvcmlnaW4sXG4gICAgICAgIGxpZmVjeWNsZTogTElGRUNZQ0xFLkNPTVBMRVRFXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiZ29cIiwgKG5leHRJbmRleCkgPT4ge1xuICAgICAgY29uc3QgeyBjb250cm9sbGVkLCBzdGF0dXMgfSA9IHRoaXMuZ2V0U3RhdGUoKTtcbiAgICAgIGlmIChjb250cm9sbGVkIHx8IHN0YXR1cyAhPT0gU1RBVFVTLlJVTk5JTkcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3Qgc3RlcCA9IHRoaXMuZ2V0U3RlcChuZXh0SW5kZXgpO1xuICAgICAgdGhpcy51cGRhdGVTdGF0ZSh7XG4gICAgICAgIGFjdGlvbjogQUNUSU9OUy5HTyxcbiAgICAgICAgaW5kZXg6IG5leHRJbmRleCxcbiAgICAgICAgbGlmZWN5Y2xlOiBMSUZFQ1lDTEUuQ09NUExFVEUsXG4gICAgICAgIHN0YXR1czogc3RlcCA/IHN0YXR1cyA6IFNUQVRVUy5GSU5JU0hFRFxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImluZm9cIiwgKCkgPT4gdGhpcy5nZXRTdGF0ZSgpKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwibmV4dFwiLCAoKSA9PiB7XG4gICAgICBjb25zdCB7IGluZGV4LCBzdGF0dXMgfSA9IHRoaXMuZ2V0U3RhdGUoKTtcbiAgICAgIGlmIChzdGF0dXMgIT09IFNUQVRVUy5SVU5OSU5HKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMudXBkYXRlU3RhdGUoe1xuICAgICAgICBhY3Rpb246IEFDVElPTlMuTkVYVCxcbiAgICAgICAgaW5kZXg6IHRoaXMuZ2V0VXBkYXRlZEluZGV4KGluZGV4ICsgMSksXG4gICAgICAgIGxpZmVjeWNsZTogTElGRUNZQ0xFLkNPTVBMRVRFXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwib3BlblwiLCAoKSA9PiB7XG4gICAgICBjb25zdCB7IHN0YXR1cyB9ID0gdGhpcy5nZXRTdGF0ZSgpO1xuICAgICAgaWYgKHN0YXR1cyAhPT0gU1RBVFVTLlJVTk5JTkcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy51cGRhdGVTdGF0ZSh7IGFjdGlvbjogQUNUSU9OUy5VUERBVEUsIGxpZmVjeWNsZTogTElGRUNZQ0xFLlRPT0xUSVAgfSk7XG4gICAgfSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInByZXZcIiwgKCkgPT4ge1xuICAgICAgY29uc3QgeyBpbmRleCwgc3RhdHVzIH0gPSB0aGlzLmdldFN0YXRlKCk7XG4gICAgICBpZiAoc3RhdHVzICE9PSBTVEFUVVMuUlVOTklORykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLnVwZGF0ZVN0YXRlKHtcbiAgICAgICAgYWN0aW9uOiBBQ1RJT05TLlBSRVYsXG4gICAgICAgIGluZGV4OiB0aGlzLmdldFVwZGF0ZWRJbmRleChpbmRleCAtIDEpLFxuICAgICAgICBsaWZlY3ljbGU6IExJRkVDWUNMRS5DT01QTEVURVxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInJlc2V0XCIsIChyZXN0YXJ0ID0gZmFsc2UpID0+IHtcbiAgICAgIGNvbnN0IHsgY29udHJvbGxlZCB9ID0gdGhpcy5nZXRTdGF0ZSgpO1xuICAgICAgaWYgKGNvbnRyb2xsZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy51cGRhdGVTdGF0ZSh7XG4gICAgICAgIGFjdGlvbjogQUNUSU9OUy5SRVNFVCxcbiAgICAgICAgaW5kZXg6IDAsXG4gICAgICAgIGxpZmVjeWNsZTogTElGRUNZQ0xFLkNPTVBMRVRFLFxuICAgICAgICBzdGF0dXM6IHJlc3RhcnQgPyBTVEFUVVMuUlVOTklORyA6IFNUQVRVUy5SRUFEWVxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInNraXBcIiwgKCkgPT4ge1xuICAgICAgY29uc3QgeyBzdGF0dXMgfSA9IHRoaXMuZ2V0U3RhdGUoKTtcbiAgICAgIGlmIChzdGF0dXMgIT09IFNUQVRVUy5SVU5OSU5HKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMudXBkYXRlU3RhdGUoe1xuICAgICAgICBhY3Rpb246IEFDVElPTlMuU0tJUCxcbiAgICAgICAgbGlmZWN5Y2xlOiBMSUZFQ1lDTEUuQ09NUExFVEUsXG4gICAgICAgIHN0YXR1czogU1RBVFVTLlNLSVBQRURcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJzdGFydFwiLCAobmV4dEluZGV4KSA9PiB7XG4gICAgICBjb25zdCB7IGluZGV4LCBzaXplIH0gPSB0aGlzLmdldFN0YXRlKCk7XG4gICAgICB0aGlzLnVwZGF0ZVN0YXRlKFxuICAgICAgICB7XG4gICAgICAgICAgYWN0aW9uOiBBQ1RJT05TLlNUQVJULFxuICAgICAgICAgIGluZGV4OiBpczMubnVtYmVyKG5leHRJbmRleCkgPyBuZXh0SW5kZXggOiBpbmRleCxcbiAgICAgICAgICBzdGF0dXM6IHNpemUgPyBTVEFUVVMuUlVOTklORyA6IFNUQVRVUy5XQUlUSU5HXG4gICAgICAgIH0sXG4gICAgICAgIHRydWVcbiAgICAgICk7XG4gICAgfSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInN0b3BcIiwgKGFkdmFuY2UgPSBmYWxzZSkgPT4ge1xuICAgICAgY29uc3QgeyBpbmRleCwgc3RhdHVzIH0gPSB0aGlzLmdldFN0YXRlKCk7XG4gICAgICBpZiAoW1NUQVRVUy5GSU5JU0hFRCwgU1RBVFVTLlNLSVBQRURdLmluY2x1ZGVzKHN0YXR1cykpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy51cGRhdGVTdGF0ZSh7XG4gICAgICAgIGFjdGlvbjogQUNUSU9OUy5TVE9QLFxuICAgICAgICBpbmRleDogaW5kZXggKyAoYWR2YW5jZSA/IDEgOiAwKSxcbiAgICAgICAgbGlmZWN5Y2xlOiBMSUZFQ1lDTEUuQ09NUExFVEUsXG4gICAgICAgIHN0YXR1czogU1RBVFVTLlBBVVNFRFxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgY29uc3QgeyBjb250aW51b3VzID0gZmFsc2UsIHN0ZXBJbmRleCwgc3RlcHMgPSBbXSB9ID0gb3B0aW9ucyAhPSBudWxsID8gb3B0aW9ucyA6IHt9O1xuICAgIHRoaXMuc2V0U3RhdGUoXG4gICAgICB7XG4gICAgICAgIGFjdGlvbjogQUNUSU9OUy5JTklULFxuICAgICAgICBjb250cm9sbGVkOiBpczMubnVtYmVyKHN0ZXBJbmRleCksXG4gICAgICAgIGNvbnRpbnVvdXMsXG4gICAgICAgIGluZGV4OiBpczMubnVtYmVyKHN0ZXBJbmRleCkgPyBzdGVwSW5kZXggOiAwLFxuICAgICAgICBsaWZlY3ljbGU6IExJRkVDWUNMRS5JTklULFxuICAgICAgICBvcmlnaW46IG51bGwsXG4gICAgICAgIHN0YXR1czogc3RlcHMubGVuZ3RoID8gU1RBVFVTLlJFQURZIDogU1RBVFVTLklETEVcbiAgICAgIH0sXG4gICAgICB0cnVlXG4gICAgKTtcbiAgICB0aGlzLnNldFN0ZXBzKHN0ZXBzKTtcbiAgICB0aGlzLmJlYWNvblBvcHBlciA9IG51bGw7XG4gICAgdGhpcy50b29sdGlwUG9wcGVyID0gbnVsbDtcbiAgICB0aGlzLmxpc3RlbmVyID0gbnVsbDtcbiAgICB0aGlzLnByb3BzID0gb3B0aW9ucyAhPSBudWxsID8gb3B0aW9ucyA6IHsgc3RlcHM6IFtdIH07XG4gIH1cbiAgZ2V0U3RlcChuZXh0SW5kZXgpIHtcbiAgICBjb25zdCBzdGVwcyA9IHRoaXMuZGF0YS5nZXQoXCJzdGVwc1wiKTtcbiAgICBjb25zdCB7IGluZGV4IH0gPSB0aGlzLmdldFN0YXRlKCk7XG4gICAgcmV0dXJuIGdldE1lcmdlZFN0ZXAodGhpcy5wcm9wcywgc3RlcHNbbmV4dEluZGV4ICE9IG51bGwgPyBuZXh0SW5kZXggOiBpbmRleF0pO1xuICB9XG4gIGdldFVwZGF0ZWRJbmRleChuZXh0SW5kZXgpIHtcbiAgICBjb25zdCB7IHNpemUgfSA9IHRoaXMuZ2V0U3RhdGUoKTtcbiAgICByZXR1cm4gTWF0aC5taW4oTWF0aC5tYXgobmV4dEluZGV4LCAwKSwgc2l6ZSk7XG4gIH1cbiAgaGFzVXBkYXRlZFN0YXRlKG9sZFN0YXRlKSB7XG4gICAgcmV0dXJuICFkZWVwRXF1YWwob2xkU3RhdGUsIHRoaXMuZ2V0U3RhdGUoKSk7XG4gIH1cbiAgcHJlcGFyZVN0YXRlKHBhdGNoLCBmb3JjZUluZGV4ID0gZmFsc2UpIHtcbiAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZjtcbiAgICBjb25zdCB7IGFjdGlvbiwgY29udHJvbGxlZCwgaW5kZXgsIHNpemUsIHN0YXR1cyB9ID0gdGhpcy5nZXRTdGF0ZSgpO1xuICAgIGNvbnN0IG5ld0luZGV4ID0gKF9hID0gcGF0Y2guaW5kZXgpICE9IG51bGwgPyBfYSA6IGluZGV4O1xuICAgIHJldHVybiB7XG4gICAgICBhY3Rpb246IChfYiA9IHBhdGNoLmFjdGlvbikgIT0gbnVsbCA/IF9iIDogYWN0aW9uLFxuICAgICAgY29udHJvbGxlZCxcbiAgICAgIGluZGV4OiBjb250cm9sbGVkICYmICFmb3JjZUluZGV4ID8gaW5kZXggOiBuZXdJbmRleCxcbiAgICAgIGxpZmVjeWNsZTogKF9jID0gcGF0Y2gubGlmZWN5Y2xlKSAhPSBudWxsID8gX2MgOiBMSUZFQ1lDTEUuSU5JVCxcbiAgICAgIG9yaWdpbjogKF9kID0gcGF0Y2gub3JpZ2luKSAhPSBudWxsID8gX2QgOiBudWxsLFxuICAgICAgc2l6ZTogKF9lID0gcGF0Y2guc2l6ZSkgIT0gbnVsbCA/IF9lIDogc2l6ZSxcbiAgICAgIHN0YXR1czogKF9mID0gcGF0Y2guc3RhdHVzKSAhPSBudWxsID8gX2YgOiBzdGF0dXNcbiAgICB9O1xuICB9XG4gIHNldFN0YXRlKHBhdGNoLCBpbml0aWFsID0gZmFsc2UpIHtcbiAgICBjb25zdCBzdGF0ZSA9IHRoaXMuZ2V0U3RhdGUoKTtcbiAgICBjb25zdCB7XG4gICAgICBhY3Rpb24sXG4gICAgICBpbmRleCxcbiAgICAgIGxpZmVjeWNsZSxcbiAgICAgIG9yaWdpbiA9IG51bGwsXG4gICAgICBzaXplLFxuICAgICAgc3RhdHVzXG4gICAgfSA9IHtcbiAgICAgIC4uLnN0YXRlLFxuICAgICAgLi4ucGF0Y2hcbiAgICB9O1xuICAgIHRoaXMuc3RvcmUuc2V0KFwiYWN0aW9uXCIsIGFjdGlvbik7XG4gICAgdGhpcy5zdG9yZS5zZXQoXCJpbmRleFwiLCBpbmRleCk7XG4gICAgdGhpcy5zdG9yZS5zZXQoXCJsaWZlY3ljbGVcIiwgbGlmZWN5Y2xlKTtcbiAgICB0aGlzLnN0b3JlLnNldChcIm9yaWdpblwiLCBvcmlnaW4pO1xuICAgIHRoaXMuc3RvcmUuc2V0KFwic2l6ZVwiLCBzaXplKTtcbiAgICB0aGlzLnN0b3JlLnNldChcInN0YXR1c1wiLCBzdGF0dXMpO1xuICAgIGlmIChpbml0aWFsKSB7XG4gICAgICB0aGlzLnN0b3JlLnNldChcImNvbnRyb2xsZWRcIiwgcGF0Y2guY29udHJvbGxlZCk7XG4gICAgICB0aGlzLnN0b3JlLnNldChcImNvbnRpbnVvdXNcIiwgcGF0Y2guY29udGludW91cyk7XG4gICAgfVxuICAgIGlmICh0aGlzLmxpc3RlbmVyICYmIHRoaXMuaGFzVXBkYXRlZFN0YXRlKHN0YXRlKSkge1xuICAgICAgdGhpcy5saXN0ZW5lcih0aGlzLmdldFN0YXRlKCkpO1xuICAgIH1cbiAgfVxuICBnZXRTdGF0ZSgpIHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKCEoKF9hID0gdGhpcyA9PSBudWxsID8gdm9pZCAwIDogdGhpcy5zdG9yZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnNpemUpKSB7XG4gICAgICByZXR1cm4geyAuLi5kZWZhdWx0U3RhdGUyIH07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBhY3Rpb246IHRoaXMuc3RvcmUuZ2V0KFwiYWN0aW9uXCIpIHx8IFwiXCIsXG4gICAgICBjb250cm9sbGVkOiB0aGlzLnN0b3JlLmdldChcImNvbnRyb2xsZWRcIikgfHwgZmFsc2UsXG4gICAgICBpbmRleDogcGFyc2VJbnQodGhpcy5zdG9yZS5nZXQoXCJpbmRleFwiKSwgMTApLFxuICAgICAgbGlmZWN5Y2xlOiB0aGlzLnN0b3JlLmdldChcImxpZmVjeWNsZVwiKSB8fCBcIlwiLFxuICAgICAgb3JpZ2luOiB0aGlzLnN0b3JlLmdldChcIm9yaWdpblwiKSB8fCBudWxsLFxuICAgICAgc2l6ZTogdGhpcy5zdG9yZS5nZXQoXCJzaXplXCIpIHx8IDAsXG4gICAgICBzdGF0dXM6IHRoaXMuc3RvcmUuZ2V0KFwic3RhdHVzXCIpIHx8IFwiXCJcbiAgICB9O1xuICB9XG4gIGdldEhlbHBlcnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNsb3NlOiB0aGlzLmNsb3NlLFxuICAgICAgZ286IHRoaXMuZ28sXG4gICAgICBpbmZvOiB0aGlzLmluZm8sXG4gICAgICBuZXh0OiB0aGlzLm5leHQsXG4gICAgICBvcGVuOiB0aGlzLm9wZW4sXG4gICAgICBwcmV2OiB0aGlzLnByZXYsXG4gICAgICByZXNldDogdGhpcy5yZXNldCxcbiAgICAgIHNraXA6IHRoaXMuc2tpcFxuICAgIH07XG4gIH1cbn07XG5mdW5jdGlvbiBjcmVhdGVTdG9yZShvcHRpb25zKSB7XG4gIHJldHVybiBuZXcgU3RvcmUob3B0aW9ucyk7XG59XG5cbi8vIHNyYy9tb2R1bGVzL3VzZUpveXJpZGVEYXRhLnRzXG5mdW5jdGlvbiB1c2VKb3lyaWRlRGF0YShwcm9wcykge1xuICBjb25zdCB7XG4gICAgY2FsbGJhY2ssXG4gICAgY29udGludW91cyxcbiAgICBkZWJ1ZyxcbiAgICBkaXNhYmxlU2Nyb2xsUGFyZW50Rml4LFxuICAgIGdldEhlbHBlcnMsXG4gICAgcnVuLFxuICAgIHNjcm9sbER1cmF0aW9uLFxuICAgIHNjcm9sbE9mZnNldCxcbiAgICBzY3JvbGxUb0ZpcnN0U3RlcCxcbiAgICBzdGVwSW5kZXgsXG4gICAgc3RlcHNcbiAgfSA9IHByb3BzO1xuICBjb25zdCBzdG9yZSA9IHVzZVJlZihjcmVhdGVTdG9yZShwcm9wcykpO1xuICBjb25zdCBbc3RhdGUsIHNldFN0YXRlXSA9IHVzZVNldFN0YXRlKHN0b3JlLmN1cnJlbnQuZ2V0U3RhdGUoKSk7XG4gIGNvbnN0IHsgYWN0aW9uLCBjb250cm9sbGVkLCBpbmRleCwgbGlmZWN5Y2xlLCBzaXplLCBzdGF0dXMgfSA9IHN0YXRlO1xuICBjb25zdCBsYXN0QWN0aW9uID0gdXNlUmVmKG51bGwpO1xuICBjb25zdCBwcmV2aW91c1Byb3BzID0gdXNlUHJldmlvdXMocHJvcHMpO1xuICBjb25zdCBwcmV2aW91c1N0YXRlID0gdXNlUHJldmlvdXMoc3RhdGUpO1xuICBjb25zdCB7IGNoYW5nZWQ6IGNoYW5nZWRQcm9wcyB9ID0gdXNlVHJlZUNoYW5nZXMocHJvcHMpO1xuICBjb25zdCB7IGNoYW5nZWQ6IGNoYW5nZWRTdGF0ZSwgY2hhbmdlZEZyb206IGNoYW5nZWRTdGF0ZUZyb20gfSA9IHVzZVRyZWVDaGFuZ2VzKHN0YXRlKTtcbiAgY29uc3Qgc3RlcCA9IHVzZU1lbW8oKCkgPT4gZ2V0TWVyZ2VkU3RlcChwcm9wcywgc3RlcHNbaW5kZXhdKSwgW2luZGV4LCBwcm9wcywgc3RlcHNdKTtcbiAgY29uc3QgcHJldmlvdXNTdGVwID0gdXNlTWVtbygoKSA9PiBnZXRNZXJnZWRTdGVwKHByb3BzLCBzdGVwc1tpbmRleCAtIDFdKSwgW2luZGV4LCBwcm9wcywgc3RlcHNdKTtcbiAgdXNlU2luZ2xldG9uKCgpID0+IHtcbiAgICBzdG9yZS5jdXJyZW50LmFkZExpc3RlbmVyKChuZXdTdGF0ZSkgPT4ge1xuICAgICAgc2V0U3RhdGUobmV3U3RhdGUpO1xuICAgIH0pO1xuICB9KTtcbiAgY29uc3Qgc2Nyb2xsVG9TdGVwID0gdXNlQ2FsbGJhY2soXG4gICAgKGxhc3RTdGF0ZSkgPT4ge1xuICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2Y7XG4gICAgICBpZiAoIXN0ZXApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgdGFyZ2V0ID0gZ2V0RWxlbWVudChzdGVwLnRhcmdldCk7XG4gICAgICBjb25zdCBzaG91bGRTY3JvbGxUb1N0ZXAgPSBzaG91bGRTY3JvbGwoe1xuICAgICAgICBpc0ZpcnN0U3RlcDogaW5kZXggPT09IDAsXG4gICAgICAgIGxpZmVjeWNsZSxcbiAgICAgICAgcHJldmlvdXNMaWZlY3ljbGU6IGxhc3RTdGF0ZS5saWZlY3ljbGUsXG4gICAgICAgIHNjcm9sbFRvRmlyc3RTdGVwLFxuICAgICAgICBzdGVwLFxuICAgICAgICB0YXJnZXRcbiAgICAgIH0pO1xuICAgICAgY29uc3QgYmVhY29uUG9wcGVyID0gc3RvcmUuY3VycmVudC5nZXRQb3BwZXIoXCJiZWFjb25cIik7XG4gICAgICBjb25zdCB0b29sdGlwUG9wcGVyID0gc3RvcmUuY3VycmVudC5nZXRQb3BwZXIoXCJ0b29sdGlwXCIpO1xuICAgICAgaWYgKHN0YXR1cyA9PT0gU1RBVFVTLlJVTk5JTkcgJiYgc2hvdWxkU2Nyb2xsVG9TdGVwKSB7XG4gICAgICAgIGNvbnN0IGhhc0N1c3RvbVNjcm9sbCA9IGhhc0N1c3RvbVNjcm9sbFBhcmVudCh0YXJnZXQsIGRpc2FibGVTY3JvbGxQYXJlbnRGaXgpO1xuICAgICAgICBjb25zdCBzY3JvbGxQYXJlbnQyID0gZ2V0U2Nyb2xsUGFyZW50KHRhcmdldCwgZGlzYWJsZVNjcm9sbFBhcmVudEZpeCk7XG4gICAgICAgIGxldCBzY3JvbGxZID0gTWF0aC5mbG9vcihnZXRTY3JvbGxUbyh0YXJnZXQsIHNjcm9sbE9mZnNldCwgZGlzYWJsZVNjcm9sbFBhcmVudEZpeCkpIHx8IDA7XG4gICAgICAgIGxvZyh7XG4gICAgICAgICAgdGl0bGU6IFwic2Nyb2xsVG9TdGVwXCIsXG4gICAgICAgICAgZGF0YTogW1xuICAgICAgICAgICAgeyBrZXk6IFwiaW5kZXhcIiwgdmFsdWU6IGluZGV4IH0sXG4gICAgICAgICAgICB7IGtleTogXCJsaWZlY3ljbGVcIiwgdmFsdWU6IGxpZmVjeWNsZSB9LFxuICAgICAgICAgICAgeyBrZXk6IFwic3RhdHVzXCIsIHZhbHVlOiBzdGF0dXMgfVxuICAgICAgICAgIF0sXG4gICAgICAgICAgZGVidWdcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChsaWZlY3ljbGUgPT09IExJRkVDWUNMRS5CRUFDT04gJiYgYmVhY29uUG9wcGVyKSB7XG4gICAgICAgICAgY29uc3QgeyBtb2RpZmllcnNEYXRhLCBwbGFjZW1lbnQgfSA9IChfYSA9IGJlYWNvblBvcHBlci5zdGF0ZSkgIT0gbnVsbCA/IF9hIDoge307XG4gICAgICAgICAgY29uc3QgeyBvZmZzZXQgfSA9IG1vZGlmaWVyc0RhdGEgIT0gbnVsbCA/IG1vZGlmaWVyc0RhdGEgOiB7fTtcbiAgICAgICAgICBjb25zdCB5ID0gKF9jID0gKF9iID0gb2Zmc2V0ID09IG51bGwgPyB2b2lkIDAgOiBvZmZzZXQudG9wKSA9PSBudWxsID8gdm9pZCAwIDogX2IueSkgIT0gbnVsbCA/IF9jIDogMDtcbiAgICAgICAgICBpZiAoIVtcImJvdHRvbVwiXS5pbmNsdWRlcyhwbGFjZW1lbnQpICYmICFoYXNDdXN0b21TY3JvbGwpIHtcbiAgICAgICAgICAgIHNjcm9sbFkgPSBNYXRoLmZsb29yKHkgLSBzY3JvbGxPZmZzZXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChsaWZlY3ljbGUgPT09IExJRkVDWUNMRS5UT09MVElQICYmIHRvb2x0aXBQb3BwZXIpIHtcbiAgICAgICAgICBjb25zdCB7IG1vZGlmaWVyc0RhdGEsIHBsYWNlbWVudCB9ID0gKF9kID0gdG9vbHRpcFBvcHBlci5zdGF0ZSkgIT0gbnVsbCA/IF9kIDoge307XG4gICAgICAgICAgY29uc3QgeyBvZmZzZXQgfSA9IG1vZGlmaWVyc0RhdGEgIT0gbnVsbCA/IG1vZGlmaWVyc0RhdGEgOiB7fTtcbiAgICAgICAgICBjb25zdCB5ID0gKF9mID0gKF9lID0gb2Zmc2V0ID09IG51bGwgPyB2b2lkIDAgOiBvZmZzZXQudG9wKSA9PSBudWxsID8gdm9pZCAwIDogX2UueSkgIT0gbnVsbCA/IF9mIDogMDtcbiAgICAgICAgICBjb25zdCBmbGlwcGVkID0gISFwbGFjZW1lbnQgJiYgcGxhY2VtZW50ICE9PSBzdGVwLnBsYWNlbWVudDtcbiAgICAgICAgICBpZiAoW1widG9wXCIsIFwicmlnaHRcIiwgXCJsZWZ0XCJdLmluY2x1ZGVzKHBsYWNlbWVudCkgJiYgIWZsaXBwZWQgJiYgIWhhc0N1c3RvbVNjcm9sbCkge1xuICAgICAgICAgICAgc2Nyb2xsWSA9IE1hdGguZmxvb3IoeSAtIHNjcm9sbE9mZnNldCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNjcm9sbFkgLT0gc3RlcC5zcG90bGlnaHRQYWRkaW5nO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzY3JvbGxZID0gc2Nyb2xsWSA+PSAwID8gc2Nyb2xsWSA6IDA7XG4gICAgICAgIGlmIChzdGF0dXMgPT09IFNUQVRVUy5SVU5OSU5HKSB7XG4gICAgICAgICAgc2Nyb2xsVG8oc2Nyb2xsWSwgeyBlbGVtZW50OiBzY3JvbGxQYXJlbnQyLCBkdXJhdGlvbjogc2Nyb2xsRHVyYXRpb24gfSkudGhlbihcbiAgICAgICAgICAgICgpID0+IHtcbiAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hMjtcbiAgICAgICAgICAgICAgICAoX2EyID0gc3RvcmUuY3VycmVudC5nZXRQb3BwZXIoXCJ0b29sdGlwXCIpKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLnVwZGF0ZSgpO1xuICAgICAgICAgICAgICB9LCAxMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgW1xuICAgICAgZGVidWcsXG4gICAgICBkaXNhYmxlU2Nyb2xsUGFyZW50Rml4LFxuICAgICAgaW5kZXgsXG4gICAgICBsaWZlY3ljbGUsXG4gICAgICBzY3JvbGxEdXJhdGlvbixcbiAgICAgIHNjcm9sbE9mZnNldCxcbiAgICAgIHNjcm9sbFRvRmlyc3RTdGVwLFxuICAgICAgc3RhdHVzLFxuICAgICAgc3RlcFxuICAgIF1cbiAgKTtcbiAgdXNlTW91bnQoKCkgPT4ge1xuICAgIGlmIChydW4gJiYgc2l6ZSAmJiB2YWxpZGF0ZVN0ZXBzKHN0ZXBzLCBkZWJ1ZykpIHtcbiAgICAgIHN0b3JlLmN1cnJlbnQuc3RhcnQoKTtcbiAgICB9XG4gICAgaWYgKGdldEhlbHBlcnMpIHtcbiAgICAgIGdldEhlbHBlcnMoc3RvcmUuY3VycmVudC5nZXRIZWxwZXJzKCkpO1xuICAgIH1cbiAgfSk7XG4gIHVzZVVwZGF0ZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKHJ1biAmJiBzaXplICYmIHN0YXR1cyA9PT0gU1RBVFVTLklETEUpIHtcbiAgICAgIHN0b3JlLmN1cnJlbnQudXBkYXRlU3RhdGUoeyBzdGF0dXM6IFNUQVRVUy5SRUFEWSB9KTtcbiAgICB9XG4gICAgaWYgKGdldEhlbHBlcnMpIHtcbiAgICAgIGdldEhlbHBlcnMoc3RvcmUuY3VycmVudC5nZXRIZWxwZXJzKCkpO1xuICAgIH1cbiAgfSwgW2dldEhlbHBlcnMsIHJ1biwgc2l6ZSwgc3RhdHVzXSk7XG4gIHVzZURlZXBDb21wYXJlRWZmZWN0KCgpID0+IHtcbiAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgaWYgKCFwcmV2aW91c1Byb3BzIHx8ICFwcmV2aW91c1N0YXRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGlzQWZ0ZXJBY3Rpb24gPSBjaGFuZ2VkU3RhdGUoXCJhY3Rpb25cIiwgW1xuICAgICAgQUNUSU9OUy5ORVhULFxuICAgICAgQUNUSU9OUy5QUkVWLFxuICAgICAgQUNUSU9OUy5TS0lQLFxuICAgICAgQUNUSU9OUy5DTE9TRVxuICAgIF0pO1xuICAgIGlmIChpc0FmdGVyQWN0aW9uIHx8IGxhc3RBY3Rpb24uY3VycmVudCA9PT0gQUNUSU9OUy5DTE9TRSAmJiBhY3Rpb24gPT09IEFDVElPTlMuU1RBUlQpIHtcbiAgICAgIGxhc3RBY3Rpb24uY3VycmVudCA9IGFjdGlvbjtcbiAgICB9XG4gICAgaWYgKHN0YXR1cyA9PT0gU1RBVFVTLlJVTk5JTkcgJiYgc3RlcCAmJiBsaWZlY3ljbGUgPT09IExJRkVDWUNMRS5JTklUKSB7XG4gICAgICBzdG9yZS5jdXJyZW50LnVwZGF0ZVN0YXRlKHtcbiAgICAgICAgYWN0aW9uOiAoX2EgPSBsYXN0QWN0aW9uLmN1cnJlbnQpICE9IG51bGwgPyBfYSA6IEFDVElPTlMuVVBEQVRFLFxuICAgICAgICBsaWZlY3ljbGU6IExJRkVDWUNMRS5SRUFEWVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChzaXplICYmICFzdGVwICYmIGxpZmVjeWNsZSA9PT0gTElGRUNZQ0xFLklOSVQpIHtcbiAgICAgIHN0b3JlLmN1cnJlbnQudXBkYXRlU3RhdGUoe1xuICAgICAgICBhY3Rpb246IEFDVElPTlMuVVBEQVRFLFxuICAgICAgICBsaWZlY3ljbGU6IExJRkVDWUNMRS5DT01QTEVURSxcbiAgICAgICAgc3RhdHVzOiBTVEFUVVMuRklOSVNIRURcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoc3RhdHVzID09PSBTVEFUVVMuUlVOTklORyAmJiAoc3RlcCA9PSBudWxsID8gdm9pZCAwIDogc3RlcC5wbGFjZW1lbnQpID09PSBcImNlbnRlclwiICYmIGNoYW5nZWRTdGF0ZShcImxpZmVjeWNsZVwiLCBMSUZFQ1lDTEUuQ09NUExFVEUpKSB7XG4gICAgICBzdG9yZS5jdXJyZW50LnVwZGF0ZVN0YXRlKHsgYWN0aW9uOiBBQ1RJT05TLlVQREFURSwgbGlmZWN5Y2xlOiBMSUZFQ1lDTEUuSU5JVCB9KTtcbiAgICB9XG4gICAgY29uc3QgZWxlbWVudCA9IGdldEVsZW1lbnQoc3RlcCA9PSBudWxsID8gdm9pZCAwIDogc3RlcC50YXJnZXQpO1xuICAgIGNvbnN0IGVsZW1lbnRFeGlzdHMgPSAhIWVsZW1lbnQ7XG4gICAgaWYgKHN0ZXAgJiYgZWxlbWVudEV4aXN0cyAmJiBpc0VsZW1lbnRWaXNpYmxlKGVsZW1lbnQpKSB7XG4gICAgICBpZiAoY2hhbmdlZFN0YXRlRnJvbShcImxpZmVjeWNsZVwiLCBMSUZFQ1lDTEUuSU5JVCwgTElGRUNZQ0xFLlJFQURZKSkge1xuICAgICAgICBjYWxsYmFjayA9PSBudWxsID8gdm9pZCAwIDogY2FsbGJhY2soe1xuICAgICAgICAgIC4uLnN0YXRlLFxuICAgICAgICAgIGFjdGlvbjogKF9iID0gbGFzdEFjdGlvbi5jdXJyZW50KSAhPSBudWxsID8gX2IgOiBhY3Rpb24sXG4gICAgICAgICAgc3RlcCxcbiAgICAgICAgICB0eXBlOiBFVkVOVFMuU1RFUF9CRUZPUkVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChzdGVwICYmIHN0YXR1cyA9PT0gU1RBVFVTLlJVTk5JTkcpIHtcbiAgICAgIGNvbnNvbGUud2FybihlbGVtZW50RXhpc3RzID8gXCJUYXJnZXQgbm90IHZpc2libGVcIiA6IFwiVGFyZ2V0IG5vdCBtb3VudGVkXCIsIHN0ZXApO1xuICAgICAgY2FsbGJhY2sgPT0gbnVsbCA/IHZvaWQgMCA6IGNhbGxiYWNrKHtcbiAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgIHR5cGU6IEVWRU5UUy5UQVJHRVRfTk9UX0ZPVU5ELFxuICAgICAgICBzdGVwXG4gICAgICB9KTtcbiAgICAgIGlmICghY29udHJvbGxlZCkge1xuICAgICAgICBzdG9yZS5jdXJyZW50LnVwZGF0ZVN0YXRlKHtcbiAgICAgICAgICBhY3Rpb246IEFDVElPTlMuVVBEQVRFLFxuICAgICAgICAgIGluZGV4OiBpbmRleCArIChhY3Rpb24gPT09IEFDVElPTlMuUFJFViA/IC0xIDogMSlcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChzdGVwICYmIGNoYW5nZWRTdGF0ZShcImxpZmVjeWNsZVwiLCBMSUZFQ1lDTEUuUkVBRFkpKSB7XG4gICAgICBzdG9yZS5jdXJyZW50LnVwZGF0ZVN0YXRlKHtcbiAgICAgICAgYWN0aW9uOiBBQ1RJT05TLlVQREFURSxcbiAgICAgICAgbGlmZWN5Y2xlOiBoaWRlQmVhY29uKHN0ZXAsIHN0YXRlLCBjb250aW51b3VzKSA/IExJRkVDWUNMRS5UT09MVElQIDogTElGRUNZQ0xFLkJFQUNPTlxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChzdGVwICYmIGNoYW5nZWRTdGF0ZShcImxpZmVjeWNsZVwiLCBMSUZFQ1lDTEUuQkVBQ09OKSkge1xuICAgICAgY2FsbGJhY2sgPT0gbnVsbCA/IHZvaWQgMCA6IGNhbGxiYWNrKHtcbiAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgIHN0ZXAsXG4gICAgICAgIHR5cGU6IEVWRU5UUy5CRUFDT05cbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoc3RlcCAmJiBjaGFuZ2VkU3RhdGUoXCJsaWZlY3ljbGVcIiwgTElGRUNZQ0xFLlRPT0xUSVApKSB7XG4gICAgICBjYWxsYmFjayA9PSBudWxsID8gdm9pZCAwIDogY2FsbGJhY2soe1xuICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgc3RlcCxcbiAgICAgICAgdHlwZTogRVZFTlRTLlRPT0xUSVBcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBpc1J1bm5pbmdPclBhdXNlZFdpdGhTdGVwID0gc3RhdHVzID09PSBTVEFUVVMuUlVOTklORyB8fCBjb250cm9sbGVkICYmIHN0YXR1cyA9PT0gU1RBVFVTLlBBVVNFRCAmJiAhIXN0ZXA7XG4gICAgY29uc3QgY2FsbGJhY2tTdGVwID0gc3RlcCAhPSBudWxsID8gc3RlcCA6IHByZXZpb3VzU3RlcDtcbiAgICBjb25zdCBzaG91bGRTZW5kQ2FsbGJhY2sgPSBpc1J1bm5pbmdPclBhdXNlZFdpdGhTdGVwICYmIGNhbGxiYWNrU3RlcCAmJiBjaGFuZ2VkU3RhdGUoXCJsaWZlY3ljbGVcIiwgTElGRUNZQ0xFLkNPTVBMRVRFLCBMSUZFQ1lDTEUuVE9PTFRJUCkgJiYgKGVsZW1lbnRFeGlzdHMgfHwgIXN0ZXApO1xuICAgIGlmIChzaG91bGRTZW5kQ2FsbGJhY2spIHtcbiAgICAgIGNhbGxiYWNrID09IG51bGwgPyB2b2lkIDAgOiBjYWxsYmFjayh7XG4gICAgICAgIC4uLnN0YXRlLFxuICAgICAgICBhY3Rpb246IChfYyA9IGxhc3RBY3Rpb24uY3VycmVudCkgIT0gbnVsbCA/IF9jIDogQUNUSU9OUy5VUERBVEUsXG4gICAgICAgIGluZGV4OiAoX2QgPSBwcmV2aW91c1N0YXRlLmluZGV4KSAhPSBudWxsID8gX2QgOiBpbmRleCxcbiAgICAgICAgbGlmZWN5Y2xlLFxuICAgICAgICBzdGVwOiBjYWxsYmFja1N0ZXAsXG4gICAgICAgIHR5cGU6IEVWRU5UUy5TVEVQX0FGVEVSXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHN0YXR1cyA9PT0gU1RBVFVTLldBSVRJTkcpIHtcbiAgICAgIHN0b3JlLmN1cnJlbnQudXBkYXRlU3RhdGUoeyBzdGF0dXM6IFNUQVRVUy5SVU5OSU5HIH0pO1xuICAgIH1cbiAgICBpZiAoY2hhbmdlZFByb3BzKCkpIHtcbiAgICAgIGNvbnN0IHsgc3RlcEluZGV4OiBwcmV2aW91c1N0ZXBJbmRleCwgc3RlcHM6IHByZXZpb3VzU3RlcHMgfSA9IHByZXZpb3VzUHJvcHM7XG4gICAgICBpZiAoIWlzRXF1YWwocHJldmlvdXNTdGVwcywgc3RlcHMpKSB7XG4gICAgICAgIGlmICh2YWxpZGF0ZVN0ZXBzKHN0ZXBzLCBkZWJ1ZykpIHtcbiAgICAgICAgICBzdG9yZS5jdXJyZW50LnVwZGF0ZVN0YXRlKHsgc2l6ZTogc3RlcHMubGVuZ3RoIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUud2FybihcIlN0ZXBzIGFyZSBub3QgdmFsaWRcIiwgc3RlcHMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoY2hhbmdlZFByb3BzKFwicnVuXCIpKSB7XG4gICAgICAgIGlmIChydW4pIHtcbiAgICAgICAgICBpZiAoc3RvcmUuY3VycmVudC5nZXRTdGF0ZSgpLnNpemUpIHtcbiAgICAgICAgICAgIHN0b3JlLmN1cnJlbnQuc3RhcnQoc3RlcEluZGV4KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RvcmUuY3VycmVudC5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaXM0Lm51bWJlcihzdGVwSW5kZXgpICYmIGNoYW5nZWRQcm9wcyhcInN0ZXBJbmRleFwiKSkge1xuICAgICAgICBjb25zdCBuZXh0QWN0aW9uID0gaXM0Lm51bWJlcihwcmV2aW91c1N0ZXBJbmRleCkgJiYgcHJldmlvdXNTdGVwSW5kZXggPCBzdGVwSW5kZXggPyBBQ1RJT05TLk5FWFQgOiBBQ1RJT05TLlBSRVY7XG4gICAgICAgIGlmICghW1NUQVRVUy5GSU5JU0hFRCwgU1RBVFVTLlNLSVBQRURdLmluY2x1ZGVzKHN0YXR1cykpIHtcbiAgICAgICAgICBzdG9yZS5jdXJyZW50LnVwZGF0ZVN0YXRlKHsgYWN0aW9uOiBuZXh0QWN0aW9uLCBpbmRleDogc3RlcEluZGV4IH0sIHRydWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChjaGFuZ2VkU3RhdGUoXCJpbmRleFwiKSkge1xuICAgICAgbG9nKHtcbiAgICAgICAgdGl0bGU6IGBzdGVwOiR7bGlmZWN5Y2xlfWAsXG4gICAgICAgIGRhdGE6IFt7IGtleTogXCJwcm9wc1wiLCB2YWx1ZTogcHJvcHMgfV0sXG4gICAgICAgIGRlYnVnXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGNoYW5nZWRTdGF0ZShcImxpZmVjeWNsZVwiLCBMSUZFQ1lDTEUuQ09NUExFVEUpICYmIGluZGV4ICYmIGluZGV4ID49IHNpemUpIHtcbiAgICAgIHN0b3JlLmN1cnJlbnQudXBkYXRlU3RhdGUoe1xuICAgICAgICBhY3Rpb246IEFDVElPTlMuVVBEQVRFLFxuICAgICAgICBsaWZlY3ljbGU6IExJRkVDWUNMRS5DT01QTEVURSxcbiAgICAgICAgc3RhdHVzOiBTVEFUVVMuRklOSVNIRURcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAocHJldmlvdXNTdGVwICYmIGNoYW5nZWRTdGF0ZShcInN0YXR1c1wiLCBbU1RBVFVTLkZJTklTSEVELCBTVEFUVVMuU0tJUFBFRF0pKSB7XG4gICAgICBjYWxsYmFjayA9PSBudWxsID8gdm9pZCAwIDogY2FsbGJhY2soe1xuICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgaW5kZXg6IGluZGV4IC0gMSxcbiAgICAgICAgLy8gUmV0dXJuIHRoZSBsYXN0IHN0ZXAgd2hlbiB0aGUgdG91ciBpcyBmaW5pc2hlZFxuICAgICAgICBzdGVwOiBwcmV2aW91c1N0ZXAsXG4gICAgICAgIHR5cGU6IEVWRU5UUy5UT1VSX0VORFxuICAgICAgfSk7XG4gICAgICBzdG9yZS5jdXJyZW50LnJlc2V0KCk7XG4gICAgfVxuICAgIGlmIChzdGVwICYmIGNoYW5nZWRTdGF0ZUZyb20oXCJzdGF0dXNcIiwgW1NUQVRVUy5JRExFLCBTVEFUVVMuUkVBRFksIFNUQVRVUy5QQVVTRURdLCBTVEFUVVMuUlVOTklORykpIHtcbiAgICAgIGNhbGxiYWNrID09IG51bGwgPyB2b2lkIDAgOiBjYWxsYmFjayh7XG4gICAgICAgIC4uLnN0YXRlLFxuICAgICAgICBzdGVwLFxuICAgICAgICB0eXBlOiBFVkVOVFMuVE9VUl9TVEFSVFxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChzdGVwICYmIGNoYW5nZWRTdGF0ZShcImFjdGlvblwiLCBBQ1RJT05TLlNUT1ApKSB7XG4gICAgICBjYWxsYmFjayA9PSBudWxsID8gdm9pZCAwIDogY2FsbGJhY2soe1xuICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgc3RlcCxcbiAgICAgICAgdHlwZTogRVZFTlRTLlRPVVJfU1RBVFVTXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHN0ZXAgJiYgY2hhbmdlZFN0YXRlKFwiYWN0aW9uXCIsIEFDVElPTlMuUkVTRVQpKSB7XG4gICAgICBjYWxsYmFjayA9PSBudWxsID8gdm9pZCAwIDogY2FsbGJhY2soe1xuICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgc3RlcCxcbiAgICAgICAgdHlwZTogRVZFTlRTLlRPVVJfU1RBVFVTXG4gICAgICB9KTtcbiAgICB9XG4gICAgc2Nyb2xsVG9TdGVwKHByZXZpb3VzU3RhdGUpO1xuICB9LCBbXG4gICAgYWN0aW9uLFxuICAgIGNhbGxiYWNrLFxuICAgIGNoYW5nZWRQcm9wcyxcbiAgICBjaGFuZ2VkU3RhdGUsXG4gICAgY2hhbmdlZFN0YXRlRnJvbSxcbiAgICBjb250aW51b3VzLFxuICAgIGNvbnRyb2xsZWQsXG4gICAgZGVidWcsXG4gICAgaW5kZXgsXG4gICAgbGlmZWN5Y2xlLFxuICAgIHByZXZpb3VzUHJvcHMsXG4gICAgcHJldmlvdXNTdGF0ZSxcbiAgICBwcmV2aW91c1N0ZXAsXG4gICAgcHJvcHMsXG4gICAgcnVuLFxuICAgIHNjcm9sbFRvU3RlcCxcbiAgICBzaXplLFxuICAgIHN0YXRlLFxuICAgIHN0YXR1cyxcbiAgICBzdGVwLFxuICAgIHN0ZXBJbmRleCxcbiAgICBzdGVwc1xuICBdKTtcbiAgcmV0dXJuIHN0b3JlO1xufVxuXG4vLyBzcmMvbW9kdWxlcy91c2VQb3J0YWxFbGVtZW50LnRzXG5pbXBvcnQgeyB1c2VNb3VudCBhcyB1c2VNb3VudDIsIHVzZVNldFN0YXRlIGFzIHVzZVNldFN0YXRlMiwgdXNlVW5tb3VudCB9IGZyb20gXCJAZ2lsYmFyYmFyYS9ob29rc1wiO1xuaW1wb3J0IGlzNSBmcm9tIFwiaXMtbGl0ZVwiO1xuZnVuY3Rpb24gdXNlUG9ydGFsRWxlbWVudChwb3J0YWxFbGVtZW50KSB7XG4gIGNvbnN0IFt7IGVsZW1lbnQsIHVzZUV4dGVybmFsUG9ydGFsIH0sIHNldFN0YXRlXSA9IHVzZVNldFN0YXRlMih7XG4gICAgdXNlRXh0ZXJuYWxQb3J0YWw6IGZhbHNlLFxuICAgIGVsZW1lbnQ6IG51bGxcbiAgfSk7XG4gIHVzZU1vdW50MigoKSA9PiB7XG4gICAgaWYgKHBvcnRhbEVsZW1lbnQpIHtcbiAgICAgIGlmIChpczUuZG9tRWxlbWVudChwb3J0YWxFbGVtZW50KSkge1xuICAgICAgICBzZXRTdGF0ZSh7IGVsZW1lbnQ6IHBvcnRhbEVsZW1lbnQsIHVzZUV4dGVybmFsUG9ydGFsOiB0cnVlIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgcG9ydGFsID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcihwb3J0YWxFbGVtZW50KTtcbiAgICAgICAgaWYgKHBvcnRhbCkge1xuICAgICAgICAgIHNldFN0YXRlKHsgZWxlbWVudDogcG9ydGFsIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghcG9ydGFsRWxlbWVudCkge1xuICAgICAgY29uc3QgcG9ydGFsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgIHBvcnRhbC5pZCA9IFBPUlRBTF9FTEVNRU5UX0lEO1xuICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChwb3J0YWwpO1xuICAgICAgc2V0U3RhdGUoeyBlbGVtZW50OiBwb3J0YWwgfSk7XG4gICAgfVxuICB9KTtcbiAgdXNlVW5tb3VudCgoKSA9PiB7XG4gICAgaWYgKCFlbGVtZW50IHx8IHVzZUV4dGVybmFsUG9ydGFsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChlbGVtZW50LnBhcmVudE5vZGUgPT09IGRvY3VtZW50LmJvZHkpIHtcbiAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoZWxlbWVudCk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGVsZW1lbnQ7XG59XG5cbi8vIHNyYy9jb21wb25lbnRzL092ZXJsYXkudHN4XG5pbXBvcnQgeyB1c2VDYWxsYmFjayBhcyB1c2VDYWxsYmFjazIsIHVzZUVmZmVjdCwgdXNlTWVtbyBhcyB1c2VNZW1vMiwgdXNlUmVmIGFzIHVzZVJlZjIgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IHVzZUlzTW91bnRlZCwgdXNlTW91bnQgYXMgdXNlTW91bnQzLCB1c2VTZXRTdGF0ZSBhcyB1c2VTZXRTdGF0ZTMsIHVzZVVubW91bnQgYXMgdXNlVW5tb3VudDIgfSBmcm9tIFwiQGdpbGJhcmJhcmEvaG9va3NcIjtcbmltcG9ydCB1c2VUcmVlQ2hhbmdlczIgZnJvbSBcInRyZWUtY2hhbmdlcy1ob29rXCI7XG5cbi8vIHNyYy9jb21wb25lbnRzL1Nwb3RsaWdodC50c3hcbmltcG9ydCB7IGpzeCB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xuZnVuY3Rpb24gSm95cmlkZVNwb3RsaWdodCh7IHN0eWxlcyB9KSB7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4KFxuICAgIFwiZGl2XCIsXG4gICAge1xuICAgICAgY2xhc3NOYW1lOiBcInJlYWN0LWpveXJpZGVfX3Nwb3RsaWdodFwiLFxuICAgICAgXCJkYXRhLXRlc3QtaWRcIjogXCJzcG90bGlnaHRcIixcbiAgICAgIHN0eWxlOiBzdHlsZXNcbiAgICB9LFxuICAgIFwiSm95cmlkZVNwb3RsaWdodFwiXG4gICk7XG59XG5cbi8vIHNyYy9jb21wb25lbnRzL092ZXJsYXkudHN4XG5pbXBvcnQgeyBqc3ggYXMganN4MiB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xuZnVuY3Rpb24gSm95cmlkZU92ZXJsYXkocHJvcHMpIHtcbiAgY29uc3Qge1xuICAgIGNvbnRpbnVvdXMsXG4gICAgZGVidWcsXG4gICAgZGlzYWJsZU92ZXJsYXksXG4gICAgZGlzYWJsZU92ZXJsYXlDbG9zZSxcbiAgICBkaXNhYmxlU2Nyb2xsaW5nLFxuICAgIGRpc2FibGVTY3JvbGxQYXJlbnRGaXggPSBmYWxzZSxcbiAgICBsaWZlY3ljbGUsXG4gICAgb25DbGlja092ZXJsYXksXG4gICAgcGxhY2VtZW50LFxuICAgIHNwb3RsaWdodENsaWNrcyxcbiAgICBzcG90bGlnaHRQYWRkaW5nID0gMCxcbiAgICBzdHlsZXMsXG4gICAgdGFyZ2V0XG4gIH0gPSBwcm9wcztcbiAgY29uc3QgaXNNb3VudGVkID0gdXNlSXNNb3VudGVkKCk7XG4gIGNvbnN0IHsgY2hhbmdlZCB9ID0gdXNlVHJlZUNoYW5nZXMyKHByb3BzKTtcbiAgY29uc3QgcmVzaXplVGltZW91dFJlZiA9IHVzZVJlZjIoKTtcbiAgY29uc3Qgc2Nyb2xsVGltZW91dFJlZiA9IHVzZVJlZjIoKTtcbiAgY29uc3Qgc2Nyb2xsUGFyZW50UmVmID0gdXNlUmVmMihudWxsKTtcbiAgY29uc3QgW3sgaXNTY3JvbGxpbmcsIG1vdXNlT3ZlclNwb3RsaWdodCwgc2hvd1Nwb3RsaWdodCB9LCBzZXRTdGF0ZV0gPSB1c2VTZXRTdGF0ZTMoe1xuICAgIGlzU2Nyb2xsaW5nOiBmYWxzZSxcbiAgICBtb3VzZU92ZXJTcG90bGlnaHQ6IGZhbHNlLFxuICAgIHJlc2l6ZWRBdDogMCxcbiAgICBzaG93U3BvdGxpZ2h0OiB0cnVlXG4gIH0pO1xuICBjb25zdCB1cGRhdGVTdGF0ZSA9IHVzZUNhbGxiYWNrMihcbiAgICAoc3RhdGUpID0+IHtcbiAgICAgIGlmICghaXNNb3VudGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHNldFN0YXRlKHN0YXRlKTtcbiAgICB9LFxuICAgIFtpc01vdW50ZWQsIHNldFN0YXRlXVxuICApO1xuICBjb25zdCBvdmVybGF5U3R5bGVzID0gdXNlTWVtbzIoKCkgPT4ge1xuICAgIGxldCBiYXNlU3R5bGVzID0gc3R5bGVzLm92ZXJsYXk7XG4gICAgaWYgKGlzTGVnYWN5KCkpIHtcbiAgICAgIGJhc2VTdHlsZXMgPSBwbGFjZW1lbnQgPT09IFwiY2VudGVyXCIgPyBzdHlsZXMub3ZlcmxheUxlZ2FjeUNlbnRlciA6IHN0eWxlcy5vdmVybGF5TGVnYWN5O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgY3Vyc29yOiBkaXNhYmxlT3ZlcmxheUNsb3NlID8gXCJkZWZhdWx0XCIgOiBcInBvaW50ZXJcIixcbiAgICAgIGhlaWdodDogZ2V0RG9jdW1lbnRIZWlnaHQoKSxcbiAgICAgIHBvaW50ZXJFdmVudHM6IG1vdXNlT3ZlclNwb3RsaWdodCA/IFwibm9uZVwiIDogXCJhdXRvXCIsXG4gICAgICAuLi5iYXNlU3R5bGVzXG4gICAgfTtcbiAgfSwgW1xuICAgIGRpc2FibGVPdmVybGF5Q2xvc2UsXG4gICAgbW91c2VPdmVyU3BvdGxpZ2h0LFxuICAgIHBsYWNlbWVudCxcbiAgICBzdHlsZXMub3ZlcmxheSxcbiAgICBzdHlsZXMub3ZlcmxheUxlZ2FjeSxcbiAgICBzdHlsZXMub3ZlcmxheUxlZ2FjeUNlbnRlclxuICBdKTtcbiAgY29uc3Qgc3BvdGxpZ2h0U3R5bGVzID0gdXNlTWVtbzIoKCkgPT4ge1xuICAgIHZhciBfYSwgX2IsIF9jO1xuICAgIGNvbnN0IGVsZW1lbnQgPSBnZXRFbGVtZW50KHRhcmdldCk7XG4gICAgY29uc3QgZWxlbWVudFJlY3QgPSBnZXRDbGllbnRSZWN0KGVsZW1lbnQpO1xuICAgIGNvbnN0IGlzRml4ZWRUYXJnZXQgPSBoYXNQb3NpdGlvbihlbGVtZW50KTtcbiAgICBjb25zdCB0b3AgPSBnZXRFbGVtZW50UG9zaXRpb24oZWxlbWVudCwgc3BvdGxpZ2h0UGFkZGluZywgZGlzYWJsZVNjcm9sbFBhcmVudEZpeCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGhlaWdodDogTWF0aC5yb3VuZCgoKF9hID0gZWxlbWVudFJlY3QgPT0gbnVsbCA/IHZvaWQgMCA6IGVsZW1lbnRSZWN0LmhlaWdodCkgIT0gbnVsbCA/IF9hIDogMCkgKyBzcG90bGlnaHRQYWRkaW5nICogMiksXG4gICAgICBsZWZ0OiBNYXRoLnJvdW5kKCgoX2IgPSBlbGVtZW50UmVjdCA9PSBudWxsID8gdm9pZCAwIDogZWxlbWVudFJlY3QubGVmdCkgIT0gbnVsbCA/IF9iIDogMCkgLSBzcG90bGlnaHRQYWRkaW5nKSxcbiAgICAgIG9wYWNpdHk6IHNob3dTcG90bGlnaHQgPyAxIDogMCxcbiAgICAgIHBvaW50ZXJFdmVudHM6IHNwb3RsaWdodENsaWNrcyA/IFwibm9uZVwiIDogXCJhdXRvXCIsXG4gICAgICBwb3NpdGlvbjogaXNGaXhlZFRhcmdldCA/IFwiZml4ZWRcIiA6IFwiYWJzb2x1dGVcIixcbiAgICAgIHRvcCxcbiAgICAgIHRyYW5zaXRpb246IFwib3BhY2l0eSAwLjJzXCIsXG4gICAgICB3aWR0aDogTWF0aC5yb3VuZCgoKF9jID0gZWxlbWVudFJlY3QgPT0gbnVsbCA/IHZvaWQgMCA6IGVsZW1lbnRSZWN0LndpZHRoKSAhPSBudWxsID8gX2MgOiAwKSArIHNwb3RsaWdodFBhZGRpbmcgKiAyKSxcbiAgICAgIC4uLmlzTGVnYWN5KCkgPyBzdHlsZXMuc3BvdGxpZ2h0TGVnYWN5IDogc3R5bGVzLnNwb3RsaWdodFxuICAgIH07XG4gIH0sIFtcbiAgICBkaXNhYmxlU2Nyb2xsUGFyZW50Rml4LFxuICAgIHNob3dTcG90bGlnaHQsXG4gICAgc3BvdGxpZ2h0Q2xpY2tzLFxuICAgIHNwb3RsaWdodFBhZGRpbmcsXG4gICAgc3R5bGVzLnNwb3RsaWdodCxcbiAgICBzdHlsZXMuc3BvdGxpZ2h0TGVnYWN5LFxuICAgIHRhcmdldFxuICBdKTtcbiAgY29uc3QgaGFuZGxlTW91c2VNb3ZlID0gdXNlQ2FsbGJhY2syKFxuICAgIChldmVudCkgPT4ge1xuICAgICAgY29uc3QgeyBoZWlnaHQsIGxlZnQsIHBvc2l0aW9uLCB0b3AsIHdpZHRoIH0gPSBzcG90bGlnaHRTdHlsZXM7XG4gICAgICBjb25zdCBvZmZzZXRZID0gcG9zaXRpb24gPT09IFwiZml4ZWRcIiA/IGV2ZW50LmNsaWVudFkgOiBldmVudC5wYWdlWTtcbiAgICAgIGNvbnN0IG9mZnNldFggPSBwb3NpdGlvbiA9PT0gXCJmaXhlZFwiID8gZXZlbnQuY2xpZW50WCA6IGV2ZW50LnBhZ2VYO1xuICAgICAgY29uc3QgaW5TcG90bGlnaHRIZWlnaHQgPSBvZmZzZXRZID49IHRvcCAmJiBvZmZzZXRZIDw9IHRvcCArIGhlaWdodDtcbiAgICAgIGNvbnN0IGluU3BvdGxpZ2h0V2lkdGggPSBvZmZzZXRYID49IGxlZnQgJiYgb2Zmc2V0WCA8PSBsZWZ0ICsgd2lkdGg7XG4gICAgICBjb25zdCBpblNwb3RsaWdodCA9IGluU3BvdGxpZ2h0V2lkdGggJiYgaW5TcG90bGlnaHRIZWlnaHQ7XG4gICAgICBpZiAoaW5TcG90bGlnaHQgIT09IG1vdXNlT3ZlclNwb3RsaWdodCkge1xuICAgICAgICB1cGRhdGVTdGF0ZSh7IG1vdXNlT3ZlclNwb3RsaWdodDogaW5TcG90bGlnaHQgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBbc3BvdGxpZ2h0U3R5bGVzLCBtb3VzZU92ZXJTcG90bGlnaHQsIHVwZGF0ZVN0YXRlXVxuICApO1xuICBjb25zdCBoYW5kbGVSZXNpemUgPSB1c2VDYWxsYmFjazIoKCkgPT4ge1xuICAgIGNsZWFyVGltZW91dChyZXNpemVUaW1lb3V0UmVmLmN1cnJlbnQpO1xuICAgIHJlc2l6ZVRpbWVvdXRSZWYuY3VycmVudCA9IHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGlmICghaXNNb3VudGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHNldFN0YXRlKHsgcmVzaXplZEF0OiBEYXRlLm5vdygpIH0pO1xuICAgIH0sIDEwMCk7XG4gIH0sIFtpc01vdW50ZWQsIHNldFN0YXRlXSk7XG4gIGNvbnN0IGhhbmRsZVNjcm9sbCA9IHVzZUNhbGxiYWNrMigoKSA9PiB7XG4gICAgY29uc3QgZWxlbWVudCA9IGdldEVsZW1lbnQodGFyZ2V0KTtcbiAgICBpZiAoc2Nyb2xsUGFyZW50UmVmLmN1cnJlbnQgIT09IGRvY3VtZW50KSB7XG4gICAgICBpZiAoIWlzU2Nyb2xsaW5nKSB7XG4gICAgICAgIHVwZGF0ZVN0YXRlKHsgaXNTY3JvbGxpbmc6IHRydWUsIHNob3dTcG90bGlnaHQ6IGZhbHNlIH0pO1xuICAgICAgfVxuICAgICAgY2xlYXJUaW1lb3V0KHNjcm9sbFRpbWVvdXRSZWYuY3VycmVudCk7XG4gICAgICBzY3JvbGxUaW1lb3V0UmVmLmN1cnJlbnQgPSB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHVwZGF0ZVN0YXRlKHsgaXNTY3JvbGxpbmc6IGZhbHNlLCBzaG93U3BvdGxpZ2h0OiB0cnVlIH0pO1xuICAgICAgfSwgNTApO1xuICAgIH0gZWxzZSBpZiAoaGFzUG9zaXRpb24oZWxlbWVudCwgXCJzdGlja3lcIikpIHtcbiAgICAgIHVwZGF0ZVN0YXRlKHt9KTtcbiAgICB9XG4gIH0sIFtpc1Njcm9sbGluZywgdGFyZ2V0LCB1cGRhdGVTdGF0ZV0pO1xuICB1c2VNb3VudDMoKCkgPT4ge1xuICAgIGNvbnN0IGVsZW1lbnQgPSBnZXRFbGVtZW50KHRhcmdldCk7XG4gICAgc2Nyb2xsUGFyZW50UmVmLmN1cnJlbnQgPSBnZXRTY3JvbGxQYXJlbnQoXG4gICAgICBlbGVtZW50ICE9IG51bGwgPyBlbGVtZW50IDogZG9jdW1lbnQuYm9keSxcbiAgICAgIGRpc2FibGVTY3JvbGxQYXJlbnRGaXgsXG4gICAgICB0cnVlXG4gICAgKTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICBpZiAoIWRpc2FibGVTY3JvbGxpbmcgJiYgaGFzQ3VzdG9tU2Nyb2xsUGFyZW50KGVsZW1lbnQsIHRydWUpKSB7XG4gICAgICAgIGxvZyh7XG4gICAgICAgICAgdGl0bGU6IFwic3RlcCBoYXMgYSBjdXN0b20gc2Nyb2xsIHBhcmVudCBhbmQgY2FuIGNhdXNlIHRyb3VibGUgd2l0aCBzY3JvbGxpbmdcIixcbiAgICAgICAgICBkYXRhOiBbeyBrZXk6IFwicGFyZW50XCIsIHZhbHVlOiBzY3JvbGxQYXJlbnRSZWYgfV0sXG4gICAgICAgICAgZGVidWdcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIGhhbmRsZVJlc2l6ZSk7XG4gIH0pO1xuICB1c2VVbm1vdW50MigoKSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIGhhbmRsZU1vdXNlTW92ZSk7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgaGFuZGxlUmVzaXplKTtcbiAgICBjbGVhclRpbWVvdXQocmVzaXplVGltZW91dFJlZi5jdXJyZW50KTtcbiAgICBjbGVhclRpbWVvdXQoc2Nyb2xsVGltZW91dFJlZi5jdXJyZW50KTtcbiAgICAoX2EgPSBzY3JvbGxQYXJlbnRSZWYgPT0gbnVsbCA/IHZvaWQgMCA6IHNjcm9sbFBhcmVudFJlZi5jdXJyZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2EucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCBoYW5kbGVTY3JvbGwpO1xuICB9KTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKGNoYW5nZWQoXCJsaWZlY3ljbGVcIiwgTElGRUNZQ0xFLlRPT0xUSVApKSB7XG4gICAgICAoX2EgPSBzY3JvbGxQYXJlbnRSZWYgPT0gbnVsbCA/IHZvaWQgMCA6IHNjcm9sbFBhcmVudFJlZi5jdXJyZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2EuYWRkRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCBoYW5kbGVTY3JvbGwsIHsgcGFzc2l2ZTogdHJ1ZSB9KTtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBpZiAoIWlzU2Nyb2xsaW5nKSB7XG4gICAgICAgICAgdXBkYXRlU3RhdGUoeyBzaG93U3BvdGxpZ2h0OiB0cnVlIH0pO1xuICAgICAgICB9XG4gICAgICB9LCAxMDApO1xuICAgIH1cbiAgfSwgW2NoYW5nZWQsIGhhbmRsZVNjcm9sbCwgaXNTY3JvbGxpbmcsIHVwZGF0ZVN0YXRlXSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGNoYW5nZWQoXCJzcG90bGlnaHRDbGlja3NcIikgfHwgY2hhbmdlZChcImRpc2FibGVPdmVybGF5XCIpIHx8IGNoYW5nZWQoXCJsaWZlY3ljbGVcIikpIHtcbiAgICAgIGlmIChzcG90bGlnaHRDbGlja3MgJiYgbGlmZWN5Y2xlID09PSBMSUZFQ1lDTEUuVE9PTFRJUCkge1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCBoYW5kbGVNb3VzZU1vdmUsIGZhbHNlKTtcbiAgICAgIH0gZWxzZSBpZiAobGlmZWN5Y2xlICE9PSBMSUZFQ1lDTEUuVE9PTFRJUCkge1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCBoYW5kbGVNb3VzZU1vdmUpO1xuICAgICAgfVxuICAgIH1cbiAgfSwgW2NoYW5nZWQsIGhhbmRsZU1vdXNlTW92ZSwgbGlmZWN5Y2xlLCBzcG90bGlnaHRDbGlja3NdKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoY2hhbmdlZChcInRhcmdldFwiKSB8fCBjaGFuZ2VkKFwiZGlzYWJsZVNjcm9sbFBhcmVudEZpeFwiKSkge1xuICAgICAgY29uc3QgZWxlbWVudCA9IGdldEVsZW1lbnQodGFyZ2V0KTtcbiAgICAgIHNjcm9sbFBhcmVudFJlZi5jdXJyZW50ID0gZ2V0U2Nyb2xsUGFyZW50KFxuICAgICAgICBlbGVtZW50ICE9IG51bGwgPyBlbGVtZW50IDogZG9jdW1lbnQuYm9keSxcbiAgICAgICAgZGlzYWJsZVNjcm9sbFBhcmVudEZpeCxcbiAgICAgICAgdHJ1ZVxuICAgICAgKTtcbiAgICB9XG4gIH0sIFtjaGFuZ2VkLCBkaXNhYmxlU2Nyb2xsUGFyZW50Rml4LCB0YXJnZXRdKTtcbiAgY29uc3QgaGlkZGVuTGlmZWN5Y2xlcyA9IFtcbiAgICBMSUZFQ1lDTEUuSU5JVCxcbiAgICBMSUZFQ1lDTEUuQkVBQ09OLFxuICAgIExJRkVDWUNMRS5DT01QTEVURSxcbiAgICBMSUZFQ1lDTEUuRVJST1JcbiAgXTtcbiAgaWYgKGRpc2FibGVPdmVybGF5IHx8IChjb250aW51b3VzID8gaGlkZGVuTGlmZWN5Y2xlcy5pbmNsdWRlcyhsaWZlY3ljbGUpIDogbGlmZWN5Y2xlICE9PSBMSUZFQ1lDTEUuVE9PTFRJUCkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBsZXQgc3BvdGxpZ2h0MiA9IHBsYWNlbWVudCAhPT0gXCJjZW50ZXJcIiAmJiBzaG93U3BvdGxpZ2h0ICYmIC8qIEBfX1BVUkVfXyAqLyBqc3gyKEpveXJpZGVTcG90bGlnaHQsIHsgc3R5bGVzOiBzcG90bGlnaHRTdHlsZXMgfSk7XG4gIGNvbnN0IGFjdHVhbE92ZXJsYXlTdHlsZXMgPSB7IC4uLm92ZXJsYXlTdHlsZXMgfTtcbiAgaWYgKGdldEJyb3dzZXIoKSA9PT0gXCJzYWZhcmlcIikge1xuICAgIGNvbnN0IHsgbWl4QmxlbmRNb2RlLCB6SW5kZXgsIC4uLnNhZmFyaU92ZXJsYXkgfSA9IG92ZXJsYXlTdHlsZXM7XG4gICAgc3BvdGxpZ2h0MiA9IC8qIEBfX1BVUkVfXyAqLyBqc3gyKFwiZGl2XCIsIHsgc3R5bGU6IHsgLi4uc2FmYXJpT3ZlcmxheSB9LCBjaGlsZHJlbjogc3BvdGxpZ2h0MiB9KTtcbiAgICBkZWxldGUgYWN0dWFsT3ZlcmxheVN0eWxlcy5iYWNrZ3JvdW5kQ29sb3I7XG4gIH1cbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3gyKFxuICAgIFwiZGl2XCIsXG4gICAge1xuICAgICAgY2xhc3NOYW1lOiBcInJlYWN0LWpveXJpZGVfX292ZXJsYXlcIixcbiAgICAgIFwiZGF0YS10ZXN0LWlkXCI6IFwib3ZlcmxheVwiLFxuICAgICAgb25DbGljazogb25DbGlja092ZXJsYXksXG4gICAgICByb2xlOiBcInByZXNlbnRhdGlvblwiLFxuICAgICAgc3R5bGU6IGFjdHVhbE92ZXJsYXlTdHlsZXMsXG4gICAgICBjaGlsZHJlbjogc3BvdGxpZ2h0MlxuICAgIH1cbiAgKTtcbn1cblxuLy8gc3JjL2NvbXBvbmVudHMvUG9ydGFsLnRzeFxuaW1wb3J0IHsgY3JlYXRlUG9ydGFsIH0gZnJvbSBcInJlYWN0LWRvbVwiO1xuZnVuY3Rpb24gSm95cmlkZVBvcnRhbChwcm9wcykge1xuICBjb25zdCB7IGNoaWxkcmVuLCBlbGVtZW50IH0gPSBwcm9wcztcbiAgaWYgKCFlbGVtZW50KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZVBvcnRhbChjaGlsZHJlbiwgZWxlbWVudCk7XG59XG5cbi8vIHNyYy9jb21wb25lbnRzL1N0ZXAudHN4XG5pbXBvcnQgeyB1c2VFZmZlY3QgYXMgdXNlRWZmZWN0MiwgdXNlUmVmIGFzIHVzZVJlZjQgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCBGbG9hdGVyIGZyb20gXCJyZWFjdC1mbG9hdGVyXCI7XG5pbXBvcnQgeyB1c2VNb3VudCBhcyB1c2VNb3VudDUsIHVzZVVubW91bnQgYXMgdXNlVW5tb3VudDQgfSBmcm9tIFwiQGdpbGJhcmJhcmEvaG9va3NcIjtcbmltcG9ydCBpczcgZnJvbSBcImlzLWxpdGVcIjtcbmltcG9ydCB1c2VUcmVlQ2hhbmdlczMgZnJvbSBcInRyZWUtY2hhbmdlcy1ob29rXCI7XG5cbi8vIHNyYy9tb2R1bGVzL3Njb3BlLnRzXG52YXIgU2NvcGUgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiZWxlbWVudFwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwib3B0aW9uc1wiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiY2FuQmVUYWJiZWRcIiwgKGVsZW1lbnQpID0+IHtcbiAgICAgIGNvbnN0IHsgdGFiSW5kZXggfSA9IGVsZW1lbnQ7XG4gICAgICBpZiAodGFiSW5kZXggPT09IG51bGwgfHwgdGFiSW5kZXggPCAwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmNhbkhhdmVGb2N1cyhlbGVtZW50KTtcbiAgICB9KTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiY2FuSGF2ZUZvY3VzXCIsIChlbGVtZW50KSA9PiB7XG4gICAgICBjb25zdCB2YWxpZFRhYk5vZGVzID0gL2lucHV0fHNlbGVjdHx0ZXh0YXJlYXxidXR0b258b2JqZWN0LztcbiAgICAgIGNvbnN0IG5vZGVOYW1lID0gZWxlbWVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgY29uc3QgaXNWYWxpZCA9IHZhbGlkVGFiTm9kZXMudGVzdChub2RlTmFtZSkgJiYgIWVsZW1lbnQuZ2V0QXR0cmlidXRlKFwiZGlzYWJsZWRcIikgfHwgbm9kZU5hbWUgPT09IFwiYVwiICYmICEhZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJocmVmXCIpO1xuICAgICAgcmV0dXJuIGlzVmFsaWQgJiYgdGhpcy5pc1Zpc2libGUoZWxlbWVudCk7XG4gICAgfSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImZpbmRWYWxpZFRhYkVsZW1lbnRzXCIsICgpID0+IFtdLnNsaWNlLmNhbGwodGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCIqXCIpLCAwKS5maWx0ZXIodGhpcy5jYW5CZVRhYmJlZCkpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJoYW5kbGVLZXlEb3duXCIsIChldmVudCkgPT4ge1xuICAgICAgY29uc3QgeyBjb2RlID0gXCJUYWJcIiB9ID0gdGhpcy5vcHRpb25zO1xuICAgICAgaWYgKGV2ZW50LmNvZGUgPT09IGNvZGUpIHtcbiAgICAgICAgdGhpcy5pbnRlcmNlcHRUYWIoZXZlbnQpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJpbnRlcmNlcHRUYWJcIiwgKGV2ZW50KSA9PiB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgY29uc3QgZWxlbWVudHMgPSB0aGlzLmZpbmRWYWxpZFRhYkVsZW1lbnRzKCk7XG4gICAgICBjb25zdCB7IHNoaWZ0S2V5IH0gPSBldmVudDtcbiAgICAgIGlmICghZWxlbWVudHMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGxldCB4ID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA/IGVsZW1lbnRzLmluZGV4T2YoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkgOiAwO1xuICAgICAgaWYgKHggPT09IC0xIHx8ICFzaGlmdEtleSAmJiB4ICsgMSA9PT0gZWxlbWVudHMubGVuZ3RoKSB7XG4gICAgICAgIHggPSAwO1xuICAgICAgfSBlbHNlIGlmIChzaGlmdEtleSAmJiB4ID09PSAwKSB7XG4gICAgICAgIHggPSBlbGVtZW50cy5sZW5ndGggLSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeCArPSBzaGlmdEtleSA/IC0xIDogMTtcbiAgICAgIH1cbiAgICAgIGVsZW1lbnRzW3hdLmZvY3VzKCk7XG4gICAgfSk7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNsYXNzLW1ldGhvZHMtdXNlLXRoaXNcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiaXNIaWRkZW5cIiwgKGVsZW1lbnQpID0+IHtcbiAgICAgIGNvbnN0IG5vU2l6ZSA9IGVsZW1lbnQub2Zmc2V0V2lkdGggPD0gMCAmJiBlbGVtZW50Lm9mZnNldEhlaWdodCA8PSAwO1xuICAgICAgY29uc3Qgc3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcbiAgICAgIGlmIChub1NpemUgJiYgIWVsZW1lbnQuaW5uZXJIVE1MKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5vU2l6ZSAmJiBzdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKFwib3ZlcmZsb3dcIikgIT09IFwidmlzaWJsZVwiIHx8IHN0eWxlLmdldFByb3BlcnR5VmFsdWUoXCJkaXNwbGF5XCIpID09PSBcIm5vbmVcIjtcbiAgICB9KTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiaXNWaXNpYmxlXCIsIChlbGVtZW50KSA9PiB7XG4gICAgICBsZXQgcGFyZW50RWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICB3aGlsZSAocGFyZW50RWxlbWVudCkge1xuICAgICAgICBpZiAocGFyZW50RWxlbWVudCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XG4gICAgICAgICAgaWYgKHBhcmVudEVsZW1lbnQgPT09IGRvY3VtZW50LmJvZHkpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodGhpcy5pc0hpZGRlbihwYXJlbnRFbGVtZW50KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwYXJlbnRFbGVtZW50ID0gcGFyZW50RWxlbWVudC5wYXJlbnROb2RlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwicmVtb3ZlU2NvcGVcIiwgKCkgPT4ge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHRoaXMuaGFuZGxlS2V5RG93bik7XG4gICAgfSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImNoZWNrRm9jdXNcIiwgKHRhcmdldCkgPT4ge1xuICAgICAgaWYgKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgIT09IHRhcmdldCkge1xuICAgICAgICB0YXJnZXQuZm9jdXMoKTtcbiAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB0aGlzLmNoZWNrRm9jdXModGFyZ2V0KSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInNldEZvY3VzXCIsICgpID0+IHtcbiAgICAgIGNvbnN0IHsgc2VsZWN0b3IgfSA9IHRoaXMub3B0aW9ucztcbiAgICAgIGlmICghc2VsZWN0b3IpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgdGFyZ2V0ID0gdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpO1xuICAgICAgaWYgKHRhcmdldCkge1xuICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHRoaXMuY2hlY2tGb2N1cyh0YXJnZXQpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoIShlbGVtZW50IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBwYXJhbWV0ZXI6IGVsZW1lbnQgbXVzdCBiZSBhbiBIVE1MRWxlbWVudFwiKTtcbiAgICB9XG4gICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCB0aGlzLmhhbmRsZUtleURvd24sIGZhbHNlKTtcbiAgICB0aGlzLnNldEZvY3VzKCk7XG4gIH1cbn07XG5cbi8vIHNyYy9jb21wb25lbnRzL0JlYWNvbi50c3hcbmltcG9ydCB7IHVzZVJlZiBhcyB1c2VSZWYzIH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyB1c2VNb3VudCBhcyB1c2VNb3VudDQsIHVzZVNpbmdsZXRvbiBhcyB1c2VTaW5nbGV0b24yLCB1c2VVbm1vdW50IGFzIHVzZVVubW91bnQzIH0gZnJvbSBcIkBnaWxiYXJiYXJhL2hvb2tzXCI7XG5pbXBvcnQgaXM2IGZyb20gXCJpcy1saXRlXCI7XG5pbXBvcnQgeyBqc3ggYXMganN4MywganN4cyB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xuZnVuY3Rpb24gSm95cmlkZUJlYWNvbihwcm9wcykge1xuICBjb25zdCB7XG4gICAgYmVhY29uQ29tcG9uZW50LFxuICAgIGNvbnRpbnVvdXMsXG4gICAgaW5kZXgsXG4gICAgaXNMYXN0U3RlcCxcbiAgICBsb2NhbGUsXG4gICAgb25DbGlja09ySG92ZXIsXG4gICAgc2hvdWxkRm9jdXMsXG4gICAgc2l6ZSxcbiAgICBzdGVwLFxuICAgIHN0eWxlc1xuICB9ID0gcHJvcHM7XG4gIGNvbnN0IGJlYWNvblJlZiA9IHVzZVJlZjMobnVsbCk7XG4gIHVzZVNpbmdsZXRvbjIoKCkgPT4ge1xuICAgIGlmIChiZWFjb25Db21wb25lbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaGVhZCA9IGRvY3VtZW50LmhlYWQgfHwgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJoZWFkXCIpWzBdO1xuICAgIGNvbnN0IHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xuICAgIHN0eWxlLmlkID0gXCJqb3lyaWRlLWJlYWNvbi1hbmltYXRpb25cIjtcbiAgICBpZiAocHJvcHMubm9uY2UpIHtcbiAgICAgIHN0eWxlLnNldEF0dHJpYnV0ZShcIm5vbmNlXCIsIHByb3BzLm5vbmNlKTtcbiAgICB9XG4gICAgY29uc3QgY3NzID0gYFxuICAgICAgICBAa2V5ZnJhbWVzIGpveXJpZGUtYmVhY29uLWlubmVyIHtcbiAgICAgICAgICAyMCUge1xuICAgICAgICAgICAgb3BhY2l0eTogMC45O1xuICAgICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgICAgOTAlIHtcbiAgICAgICAgICAgIG9wYWNpdHk6IDAuNztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIEBrZXlmcmFtZXMgam95cmlkZS1iZWFjb24tb3V0ZXIge1xuICAgICAgICAgIDAlIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogc2NhbGUoMSk7XG4gICAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgICA0NSUge1xuICAgICAgICAgICAgb3BhY2l0eTogMC43O1xuICAgICAgICAgICAgdHJhbnNmb3JtOiBzY2FsZSgwLjc1KTtcbiAgICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAgIDEwMCUge1xuICAgICAgICAgICAgb3BhY2l0eTogMC45O1xuICAgICAgICAgICAgdHJhbnNmb3JtOiBzY2FsZSgxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIGA7XG4gICAgc3R5bGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKSk7XG4gICAgaGVhZC5hcHBlbmRDaGlsZChzdHlsZSk7XG4gIH0pO1xuICB1c2VNb3VudDQoKCkgPT4ge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIGlmICghaXM2LmRvbUVsZW1lbnQoYmVhY29uUmVmLmN1cnJlbnQpKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcImJlYWNvbiBpcyBub3QgYSB2YWxpZCBET00gZWxlbWVudFwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBpZiAoaXM2LmRvbUVsZW1lbnQoYmVhY29uUmVmLmN1cnJlbnQpICYmIHNob3VsZEZvY3VzKSB7XG4gICAgICAgIGJlYWNvblJlZi5jdXJyZW50LmZvY3VzKCk7XG4gICAgICB9XG4gICAgfSwgMCk7XG4gIH0pO1xuICB1c2VVbm1vdW50MygoKSA9PiB7XG4gICAgY29uc3Qgc3R5bGUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImpveXJpZGUtYmVhY29uLWFuaW1hdGlvblwiKTtcbiAgICBpZiAoc3R5bGUgPT0gbnVsbCA/IHZvaWQgMCA6IHN0eWxlLnBhcmVudE5vZGUpIHtcbiAgICAgIHN0eWxlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3R5bGUpO1xuICAgIH1cbiAgfSk7XG4gIGNvbnN0IHNldEJlYWNvblJlZiA9IChlbCkgPT4ge1xuICAgIGJlYWNvblJlZi5jdXJyZW50ID0gZWw7XG4gIH07XG4gIGNvbnN0IHRpdGxlID0gZ2V0UmVhY3ROb2RlVGV4dChsb2NhbGUub3Blbik7XG4gIGNvbnN0IHNoYXJlZFByb3BzID0ge1xuICAgIFwiYXJpYS1sYWJlbFwiOiB0aXRsZSxcbiAgICBvbkNsaWNrOiBvbkNsaWNrT3JIb3ZlcixcbiAgICBvbk1vdXNlRW50ZXI6IG9uQ2xpY2tPckhvdmVyLFxuICAgIHJlZjogc2V0QmVhY29uUmVmLFxuICAgIHRpdGxlXG4gIH07XG4gIGxldCBjb21wb25lbnQ7XG4gIGlmIChiZWFjb25Db21wb25lbnQpIHtcbiAgICBjb25zdCBCZWFjb25Db21wb25lbnQgPSBiZWFjb25Db21wb25lbnQ7XG4gICAgY29tcG9uZW50ID0gLyogQF9fUFVSRV9fICovIGpzeDMoXG4gICAgICBCZWFjb25Db21wb25lbnQsXG4gICAgICB7XG4gICAgICAgIGNvbnRpbnVvdXMsXG4gICAgICAgIGluZGV4LFxuICAgICAgICBpc0xhc3RTdGVwLFxuICAgICAgICBzaXplLFxuICAgICAgICBzdGVwLFxuICAgICAgICAuLi5zaGFyZWRQcm9wc1xuICAgICAgfVxuICAgICk7XG4gIH0gZWxzZSB7XG4gICAgY29tcG9uZW50ID0gLyogQF9fUFVSRV9fICovIGpzeHMoXG4gICAgICBcImJ1dHRvblwiLFxuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6IFwicmVhY3Qtam95cmlkZV9fYmVhY29uXCIsXG4gICAgICAgIFwiZGF0YS10ZXN0LWlkXCI6IFwiYnV0dG9uLWJlYWNvblwiLFxuICAgICAgICBzdHlsZTogc3R5bGVzLmJlYWNvbixcbiAgICAgICAgdHlwZTogXCJidXR0b25cIixcbiAgICAgICAgLi4uc2hhcmVkUHJvcHMsXG4gICAgICAgIGNoaWxkcmVuOiBbXG4gICAgICAgICAgLyogQF9fUFVSRV9fICovIGpzeDMoXCJzcGFuXCIsIHsgc3R5bGU6IHN0eWxlcy5iZWFjb25Jbm5lciB9KSxcbiAgICAgICAgICAvKiBAX19QVVJFX18gKi8ganN4MyhcInNwYW5cIiwgeyBzdHlsZTogc3R5bGVzLmJlYWNvbk91dGVyIH0pXG4gICAgICAgIF1cbiAgICAgIH0sXG4gICAgICBcIkpveXJpZGVCZWFjb25cIlxuICAgICk7XG4gIH1cbiAgcmV0dXJuIGNvbXBvbmVudDtcbn1cblxuLy8gc3JjL2NvbXBvbmVudHMvVG9vbHRpcC9DbG9zZUJ1dHRvbi50c3hcbmltcG9ydCB7IGpzeCBhcyBqc3g0IH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG5mdW5jdGlvbiBKb3lyaWRlVG9vbHRpcENsb3NlQnV0dG9uKHsgc3R5bGVzLCAuLi5wcm9wcyB9KSB7XG4gIGNvbnN0IHsgY29sb3IsIGhlaWdodCwgd2lkdGgsIC4uLnN0eWxlIH0gPSBzdHlsZXM7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4NChcImJ1dHRvblwiLCB7IHN0eWxlLCB0eXBlOiBcImJ1dHRvblwiLCAuLi5wcm9wcywgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3g0KFxuICAgIFwic3ZnXCIsXG4gICAge1xuICAgICAgaGVpZ2h0OiB0eXBlb2YgaGVpZ2h0ID09PSBcIm51bWJlclwiID8gYCR7aGVpZ2h0fXB4YCA6IGhlaWdodCxcbiAgICAgIHByZXNlcnZlQXNwZWN0UmF0aW86IFwieE1pZFlNaWRcIixcbiAgICAgIHZlcnNpb246IFwiMS4xXCIsXG4gICAgICB2aWV3Qm94OiBcIjAgMCAxOCAxOFwiLFxuICAgICAgd2lkdGg6IHR5cGVvZiB3aWR0aCA9PT0gXCJudW1iZXJcIiA/IGAke3dpZHRofXB4YCA6IHdpZHRoLFxuICAgICAgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIixcbiAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4NChcImdcIiwgeyBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeDQoXG4gICAgICAgIFwicGF0aFwiLFxuICAgICAgICB7XG4gICAgICAgICAgZDogXCJNOC4xMzkxMTEyOSw5LjAwMjY4MTkxIEwwLjE3MTUyMTgyNywxNy4wMjU4NDY3IEMtMC4wNDk4MDI3MDQ5LDE3LjI0ODcxNSAtMC4wNDk4MDI3MDQ5LDE3LjYwOTgzOTQgMC4xNzE1MjE4MjcsMTcuODMyNzU0NSBDMC4yODIwNDM1NCwxNy45NDQzNTI2IDAuNDI3MTg4MjA2LDE3Ljk5OTg3MDYgMC41NzIwNTE3NjUsMTcuOTk5ODcwNiBDMC43MTcxNDk1OCwxNy45OTk4NzA2IDAuODYyMDEzMTM5LDE3Ljk0NDM1MjYgMC45NzI1ODE3MDMsMTcuODMyNzU0NSBMOS4wMDAwOTM3LDkuNzQ5MjQ2MTggTDE3LjAyNzYwNTcsMTcuODMyNzU0NSBDMTcuMTM4NDA4NSwxNy45NDQzNTI2IDE3LjI4MzI3MjEsMTcuOTk5ODcwNiAxNy40MjgxMzU2LDE3Ljk5OTg3MDYgQzE3LjU3Mjk5OTIsMTcuOTk5ODcwNiAxNy43MTgwOTcsMTcuOTQ0MzUyNiAxNy44Mjg2NjU2LDE3LjgzMjc1NDUgQzE4LjA0OTk5MDEsMTcuNjA5ODg2MiAxOC4wNDk5OTAxLDE3LjI0ODc2MTggMTcuODI4NjY1NiwxNy4wMjU4NDY3IEw5Ljg2MTM1NzIyLDkuMDAyNjgxOTEgTDE3LjgzNDAwNjYsMC45NzM4NDgyMjUgQzE4LjA1NTMzMTEsMC43NTA5Nzk5MzQgMTguMDU1MzMxMSwwLjM4OTg1NTUzMiAxNy44MzQwMDY2LDAuMTY2OTQwMzkgQzE3LjYxMjY4MjEsLTAuMDU1NjQ2Nzk2OCAxNy4yNTQwMzcsLTAuMDU1NjQ2Nzk2OCAxNy4wMzI5NDY3LDAuMTY2OTQwMzkgTDkuMDAwNDIxNjYsOC4yNTYxMTc2NSBMMC45NjcwMDY0MjQsMC4xNjcyNjgzNDUgQzAuNzQ1NjgxODkyLC0wLjA1NTMxODg0MjYgMC4zODczMTc5MzEsLTAuMDU1MzE4ODQyNiAwLjE2NTk5MzM5OSwwLjE2NzI2ODM0NSBDLTAuMDU1MzMxMTMzMSwwLjM5MDEzNjYzNSAtMC4wNTUzMzExMzMxLDAuNzUxMjYxMDM4IDAuMTY1OTkzMzk5LDAuOTc0MTc2MTc5IEw4LjEzOTIwNDk5LDkuMDAyNjgxOTEgTDguMTM5MTExMjksOS4wMDI2ODE5MSBaXCIsXG4gICAgICAgICAgZmlsbDogY29sb3JcbiAgICAgICAgfVxuICAgICAgKSB9KVxuICAgIH1cbiAgKSB9KTtcbn1cblxuLy8gc3JjL2NvbXBvbmVudHMvVG9vbHRpcC9Db250YWluZXIudHN4XG5pbXBvcnQgeyBqc3ggYXMganN4NSwganN4cyBhcyBqc3hzMiB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xuZnVuY3Rpb24gSm95cmlkZVRvb2x0aXBDb250YWluZXIocHJvcHMpIHtcbiAgY29uc3QgeyBiYWNrUHJvcHMsIGNsb3NlUHJvcHMsIGluZGV4LCBpc0xhc3RTdGVwLCBwcmltYXJ5UHJvcHMsIHNraXBQcm9wcywgc3RlcCwgdG9vbHRpcFByb3BzIH0gPSBwcm9wcztcbiAgY29uc3QgeyBjb250ZW50LCBoaWRlQmFja0J1dHRvbiwgaGlkZUNsb3NlQnV0dG9uLCBoaWRlRm9vdGVyLCBzaG93U2tpcEJ1dHRvbiwgc3R5bGVzLCB0aXRsZSB9ID0gc3RlcDtcbiAgY29uc3Qgb3V0cHV0ID0ge307XG4gIG91dHB1dC5wcmltYXJ5ID0gLyogQF9fUFVSRV9fICovIGpzeDUoXG4gICAgXCJidXR0b25cIixcbiAgICB7XG4gICAgICBcImRhdGEtdGVzdC1pZFwiOiBcImJ1dHRvbi1wcmltYXJ5XCIsXG4gICAgICBzdHlsZTogc3R5bGVzLmJ1dHRvbk5leHQsXG4gICAgICB0eXBlOiBcImJ1dHRvblwiLFxuICAgICAgLi4ucHJpbWFyeVByb3BzXG4gICAgfVxuICApO1xuICBpZiAoc2hvd1NraXBCdXR0b24gJiYgIWlzTGFzdFN0ZXApIHtcbiAgICBvdXRwdXQuc2tpcCA9IC8qIEBfX1BVUkVfXyAqLyBqc3g1KFxuICAgICAgXCJidXR0b25cIixcbiAgICAgIHtcbiAgICAgICAgXCJhcmlhLWxpdmVcIjogXCJvZmZcIixcbiAgICAgICAgXCJkYXRhLXRlc3QtaWRcIjogXCJidXR0b24tc2tpcFwiLFxuICAgICAgICBzdHlsZTogc3R5bGVzLmJ1dHRvblNraXAsXG4gICAgICAgIHR5cGU6IFwiYnV0dG9uXCIsXG4gICAgICAgIC4uLnNraXBQcm9wc1xuICAgICAgfVxuICAgICk7XG4gIH1cbiAgaWYgKCFoaWRlQmFja0J1dHRvbiAmJiBpbmRleCA+IDApIHtcbiAgICBvdXRwdXQuYmFjayA9IC8qIEBfX1BVUkVfXyAqLyBqc3g1KFwiYnV0dG9uXCIsIHsgXCJkYXRhLXRlc3QtaWRcIjogXCJidXR0b24tYmFja1wiLCBzdHlsZTogc3R5bGVzLmJ1dHRvbkJhY2ssIHR5cGU6IFwiYnV0dG9uXCIsIC4uLmJhY2tQcm9wcyB9KTtcbiAgfVxuICBvdXRwdXQuY2xvc2UgPSAhaGlkZUNsb3NlQnV0dG9uICYmIC8qIEBfX1BVUkVfXyAqLyBqc3g1KEpveXJpZGVUb29sdGlwQ2xvc2VCdXR0b24sIHsgXCJkYXRhLXRlc3QtaWRcIjogXCJidXR0b24tY2xvc2VcIiwgc3R5bGVzOiBzdHlsZXMuYnV0dG9uQ2xvc2UsIC4uLmNsb3NlUHJvcHMgfSk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4czIoXG4gICAgXCJkaXZcIixcbiAgICB7XG4gICAgICBcImFyaWEtbGFiZWxcIjogZ2V0UmVhY3ROb2RlVGV4dCh0aXRsZSAhPSBudWxsID8gdGl0bGUgOiBjb250ZW50KSxcbiAgICAgIGNsYXNzTmFtZTogXCJyZWFjdC1qb3lyaWRlX190b29sdGlwXCIsXG4gICAgICBzdHlsZTogc3R5bGVzLnRvb2x0aXAsXG4gICAgICAuLi50b29sdGlwUHJvcHMsXG4gICAgICBjaGlsZHJlbjogW1xuICAgICAgICAvKiBAX19QVVJFX18gKi8ganN4czIoXCJkaXZcIiwgeyBzdHlsZTogc3R5bGVzLnRvb2x0aXBDb250YWluZXIsIGNoaWxkcmVuOiBbXG4gICAgICAgICAgdGl0bGUgJiYgLyogQF9fUFVSRV9fICovIGpzeDUoXCJoMVwiLCB7IFwiYXJpYS1sYWJlbFwiOiBnZXRSZWFjdE5vZGVUZXh0KHRpdGxlKSwgc3R5bGU6IHN0eWxlcy50b29sdGlwVGl0bGUsIGNoaWxkcmVuOiB0aXRsZSB9KSxcbiAgICAgICAgICAvKiBAX19QVVJFX18gKi8ganN4NShcImRpdlwiLCB7IHN0eWxlOiBzdHlsZXMudG9vbHRpcENvbnRlbnQsIGNoaWxkcmVuOiBjb250ZW50IH0pXG4gICAgICAgIF0gfSksXG4gICAgICAgICFoaWRlRm9vdGVyICYmIC8qIEBfX1BVUkVfXyAqLyBqc3hzMihcImRpdlwiLCB7IHN0eWxlOiBzdHlsZXMudG9vbHRpcEZvb3RlciwgY2hpbGRyZW46IFtcbiAgICAgICAgICAvKiBAX19QVVJFX18gKi8ganN4NShcImRpdlwiLCB7IHN0eWxlOiBzdHlsZXMudG9vbHRpcEZvb3RlclNwYWNlciwgY2hpbGRyZW46IG91dHB1dC5za2lwIH0pLFxuICAgICAgICAgIG91dHB1dC5iYWNrLFxuICAgICAgICAgIG91dHB1dC5wcmltYXJ5XG4gICAgICAgIF0gfSksXG4gICAgICAgIG91dHB1dC5jbG9zZVxuICAgICAgXVxuICAgIH0sXG4gICAgXCJKb3lyaWRlVG9vbHRpcFwiXG4gICk7XG59XG5cbi8vIHNyYy9jb21wb25lbnRzL1Rvb2x0aXAvaW5kZXgudHN4XG5pbXBvcnQgeyBqc3ggYXMganN4NiB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xuZnVuY3Rpb24gVG9vbHRpcChwcm9wcykge1xuICBjb25zdCB7IGNvbnRpbnVvdXMsIGhlbHBlcnMsIGluZGV4LCBpc0xhc3RTdGVwLCBzZXRUb29sdGlwUmVmLCBzaXplLCBzdGVwIH0gPSBwcm9wcztcbiAgY29uc3QgaGFuZGxlQ2xpY2tCYWNrID0gKGV2ZW50KSA9PiB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICBoZWxwZXJzLnByZXYoKTtcbiAgfTtcbiAgY29uc3QgaGFuZGxlQ2xpY2tDbG9zZSA9IChldmVudCkgPT4ge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgaGVscGVycy5jbG9zZShcImJ1dHRvbl9jbG9zZVwiKTtcbiAgfTtcbiAgY29uc3QgaGFuZGxlQ2xpY2tQcmltYXJ5ID0gKGV2ZW50KSA9PiB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICBpZiAoIWNvbnRpbnVvdXMpIHtcbiAgICAgIGhlbHBlcnMuY2xvc2UoXCJidXR0b25fcHJpbWFyeVwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaGVscGVycy5uZXh0KCk7XG4gIH07XG4gIGNvbnN0IGhhbmRsZUNsaWNrU2tpcCA9IChldmVudCkgPT4ge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgaGVscGVycy5za2lwKCk7XG4gIH07XG4gIGNvbnN0IGdldEVsZW1lbnRzUHJvcHMgPSAoKSA9PiB7XG4gICAgY29uc3QgeyBiYWNrLCBjbG9zZSwgbGFzdCwgbmV4dCwgbmV4dExhYmVsV2l0aFByb2dyZXNzLCBza2lwIH0gPSBzdGVwLmxvY2FsZTtcbiAgICBjb25zdCBiYWNrVGV4dCA9IGdldFJlYWN0Tm9kZVRleHQoYmFjayk7XG4gICAgY29uc3QgY2xvc2VUZXh0ID0gZ2V0UmVhY3ROb2RlVGV4dChjbG9zZSk7XG4gICAgY29uc3QgbGFzdFRleHQgPSBnZXRSZWFjdE5vZGVUZXh0KGxhc3QpO1xuICAgIGNvbnN0IG5leHRUZXh0ID0gZ2V0UmVhY3ROb2RlVGV4dChuZXh0KTtcbiAgICBjb25zdCBza2lwVGV4dCA9IGdldFJlYWN0Tm9kZVRleHQoc2tpcCk7XG4gICAgbGV0IHByaW1hcnkgPSBjbG9zZTtcbiAgICBsZXQgcHJpbWFyeVRleHQgPSBjbG9zZVRleHQ7XG4gICAgaWYgKGNvbnRpbnVvdXMpIHtcbiAgICAgIHByaW1hcnkgPSBuZXh0O1xuICAgICAgcHJpbWFyeVRleHQgPSBuZXh0VGV4dDtcbiAgICAgIGlmIChzdGVwLnNob3dQcm9ncmVzcyAmJiAhaXNMYXN0U3RlcCkge1xuICAgICAgICBjb25zdCBsYWJlbFdpdGhQcm9ncmVzcyA9IGdldFJlYWN0Tm9kZVRleHQobmV4dExhYmVsV2l0aFByb2dyZXNzLCB7XG4gICAgICAgICAgc3RlcDogaW5kZXggKyAxLFxuICAgICAgICAgIHN0ZXBzOiBzaXplXG4gICAgICAgIH0pO1xuICAgICAgICBwcmltYXJ5ID0gcmVwbGFjZUxvY2FsZUNvbnRlbnQobmV4dExhYmVsV2l0aFByb2dyZXNzLCBpbmRleCArIDEsIHNpemUpO1xuICAgICAgICBwcmltYXJ5VGV4dCA9IGxhYmVsV2l0aFByb2dyZXNzO1xuICAgICAgfVxuICAgICAgaWYgKGlzTGFzdFN0ZXApIHtcbiAgICAgICAgcHJpbWFyeSA9IGxhc3Q7XG4gICAgICAgIHByaW1hcnlUZXh0ID0gbGFzdFRleHQ7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBiYWNrUHJvcHM6IHtcbiAgICAgICAgXCJhcmlhLWxhYmVsXCI6IGJhY2tUZXh0LFxuICAgICAgICBjaGlsZHJlbjogYmFjayxcbiAgICAgICAgXCJkYXRhLWFjdGlvblwiOiBcImJhY2tcIixcbiAgICAgICAgb25DbGljazogaGFuZGxlQ2xpY2tCYWNrLFxuICAgICAgICByb2xlOiBcImJ1dHRvblwiLFxuICAgICAgICB0aXRsZTogYmFja1RleHRcbiAgICAgIH0sXG4gICAgICBjbG9zZVByb3BzOiB7XG4gICAgICAgIFwiYXJpYS1sYWJlbFwiOiBjbG9zZVRleHQsXG4gICAgICAgIGNoaWxkcmVuOiBjbG9zZSxcbiAgICAgICAgXCJkYXRhLWFjdGlvblwiOiBcImNsb3NlXCIsXG4gICAgICAgIG9uQ2xpY2s6IGhhbmRsZUNsaWNrQ2xvc2UsXG4gICAgICAgIHJvbGU6IFwiYnV0dG9uXCIsXG4gICAgICAgIHRpdGxlOiBjbG9zZVRleHRcbiAgICAgIH0sXG4gICAgICBwcmltYXJ5UHJvcHM6IHtcbiAgICAgICAgXCJhcmlhLWxhYmVsXCI6IHByaW1hcnlUZXh0LFxuICAgICAgICBjaGlsZHJlbjogcHJpbWFyeSxcbiAgICAgICAgXCJkYXRhLWFjdGlvblwiOiBcInByaW1hcnlcIixcbiAgICAgICAgb25DbGljazogaGFuZGxlQ2xpY2tQcmltYXJ5LFxuICAgICAgICByb2xlOiBcImJ1dHRvblwiLFxuICAgICAgICB0aXRsZTogcHJpbWFyeVRleHRcbiAgICAgIH0sXG4gICAgICBza2lwUHJvcHM6IHtcbiAgICAgICAgXCJhcmlhLWxhYmVsXCI6IHNraXBUZXh0LFxuICAgICAgICBjaGlsZHJlbjogc2tpcCxcbiAgICAgICAgXCJkYXRhLWFjdGlvblwiOiBcInNraXBcIixcbiAgICAgICAgb25DbGljazogaGFuZGxlQ2xpY2tTa2lwLFxuICAgICAgICByb2xlOiBcImJ1dHRvblwiLFxuICAgICAgICB0aXRsZTogc2tpcFRleHRcbiAgICAgIH0sXG4gICAgICB0b29sdGlwUHJvcHM6IHtcbiAgICAgICAgXCJhcmlhLW1vZGFsXCI6IHRydWUsXG4gICAgICAgIHJlZjogc2V0VG9vbHRpcFJlZixcbiAgICAgICAgcm9sZTogXCJhbGVydGRpYWxvZ1wiXG4gICAgICB9XG4gICAgfTtcbiAgfTtcbiAgY29uc3QgeyBiZWFjb25Db21wb25lbnQsIHRvb2x0aXBDb21wb25lbnQsIC4uLmNsZWFuU3RlcCB9ID0gc3RlcDtcbiAgbGV0IGNvbXBvbmVudDtcbiAgaWYgKHRvb2x0aXBDb21wb25lbnQpIHtcbiAgICBjb25zdCByZW5kZXJQcm9wcyA9IHtcbiAgICAgIC4uLmdldEVsZW1lbnRzUHJvcHMoKSxcbiAgICAgIGNvbnRpbnVvdXMsXG4gICAgICBpbmRleCxcbiAgICAgIGlzTGFzdFN0ZXAsXG4gICAgICBzaXplLFxuICAgICAgc3RlcDogY2xlYW5TdGVwLFxuICAgICAgc2V0VG9vbHRpcFJlZlxuICAgIH07XG4gICAgY29uc3QgVG9vbHRpcENvbXBvbmVudCA9IHRvb2x0aXBDb21wb25lbnQ7XG4gICAgY29tcG9uZW50ID0gLyogQF9fUFVSRV9fICovIGpzeDYoVG9vbHRpcENvbXBvbmVudCwgeyAuLi5yZW5kZXJQcm9wcyB9KTtcbiAgfSBlbHNlIHtcbiAgICBjb21wb25lbnQgPSAvKiBAX19QVVJFX18gKi8ganN4NihcbiAgICAgIEpveXJpZGVUb29sdGlwQ29udGFpbmVyLFxuICAgICAge1xuICAgICAgICAuLi5nZXRFbGVtZW50c1Byb3BzKCksXG4gICAgICAgIGNvbnRpbnVvdXMsXG4gICAgICAgIGluZGV4LFxuICAgICAgICBpc0xhc3RTdGVwLFxuICAgICAgICBzaXplLFxuICAgICAgICBzdGVwXG4gICAgICB9XG4gICAgKTtcbiAgfVxuICByZXR1cm4gY29tcG9uZW50O1xufVxuXG4vLyBzcmMvY29tcG9uZW50cy9TdGVwLnRzeFxuaW1wb3J0IHsganN4IGFzIGpzeDcgfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbmZ1bmN0aW9uIEpveXJpZGVTdGVwKHByb3BzKSB7XG4gIGNvbnN0IHtcbiAgICBjbGVhbnVwUG9wcGVycyxcbiAgICBjb250aW51b3VzLFxuICAgIGRlYnVnLFxuICAgIGhlbHBlcnMsXG4gICAgaW5kZXgsXG4gICAgbGlmZWN5Y2xlLFxuICAgIG5vbmNlLFxuICAgIHNldFBvcHBlcixcbiAgICBzaG91bGRTY3JvbGw6IHNob3VsZFNjcm9sbDIsXG4gICAgc2l6ZSxcbiAgICBzdGVwLFxuICAgIHVwZGF0ZVN0YXRlXG4gIH0gPSBwcm9wcztcbiAgY29uc3Qgc2NvcGVSZWYgPSB1c2VSZWY0KG51bGwpO1xuICBjb25zdCB0b29sdGlwUmVmID0gdXNlUmVmNChudWxsKTtcbiAgY29uc3QgeyBjaGFuZ2VkLCBjaGFuZ2VkRnJvbSB9ID0gdXNlVHJlZUNoYW5nZXMzKHByb3BzKTtcbiAgdXNlTW91bnQ1KCgpID0+IHtcbiAgICBsb2coe1xuICAgICAgdGl0bGU6IGBzdGVwOiR7aW5kZXh9YCxcbiAgICAgIGRhdGE6IFt7IGtleTogXCJwcm9wc1wiLCB2YWx1ZTogcHJvcHMgfV0sXG4gICAgICBkZWJ1Z1xuICAgIH0pO1xuICB9KTtcbiAgdXNlVW5tb3VudDQoKCkgPT4ge1xuICAgIHZhciBfYTtcbiAgICAoX2EgPSBzY29wZVJlZi5jdXJyZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2EucmVtb3ZlU2NvcGUoKTtcbiAgfSk7XG4gIHVzZUVmZmVjdDIoKCkgPT4ge1xuICAgIHZhciBfYTtcbiAgICBpZiAoY2hhbmdlZChcImxpZmVjeWNsZVwiLCBMSUZFQ1lDTEUuVE9PTFRJUCkpIHtcbiAgICAgIGlmIChzaG91bGRTY3JvbGwyICYmIHRvb2x0aXBSZWYuY3VycmVudCkge1xuICAgICAgICBzY29wZVJlZi5jdXJyZW50ID0gbmV3IFNjb3BlKHRvb2x0aXBSZWYuY3VycmVudCwgeyBzZWxlY3RvcjogXCJbZGF0YS1hY3Rpb249cHJpbWFyeV1cIiB9KTtcbiAgICAgICAgc2NvcGVSZWYuY3VycmVudC5zZXRGb2N1cygpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoY2hhbmdlZEZyb20oXCJsaWZlY3ljbGVcIiwgW0xJRkVDWUNMRS5UT09MVElQLCBMSUZFQ1lDTEUuSU5JVF0sIExJRkVDWUNMRS5JTklUKSkge1xuICAgICAgKF9hID0gc2NvcGVSZWYuY3VycmVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnJlbW92ZVNjb3BlKCk7XG4gICAgICBjbGVhbnVwUG9wcGVycygpO1xuICAgIH1cbiAgfSwgW2NoYW5nZWQsIGNoYW5nZWRGcm9tLCBjbGVhbnVwUG9wcGVycywgc2hvdWxkU2Nyb2xsMl0pO1xuICBjb25zdCBoYW5kbGVDbGlja0hvdmVyQmVhY29uID0gKGV2ZW50KSA9PiB7XG4gICAgaWYgKGV2ZW50LnR5cGUgPT09IFwibW91c2VlbnRlclwiICYmIHN0ZXAuZXZlbnQgIT09IFwiaG92ZXJcIikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB1cGRhdGVTdGF0ZSh7IGxpZmVjeWNsZTogTElGRUNZQ0xFLlRPT0xUSVAgfSk7XG4gIH07XG4gIGNvbnN0IHNldFRvb2x0aXBSZWYgPSAoZWxlbWVudCkgPT4ge1xuICAgIHRvb2x0aXBSZWYuY3VycmVudCA9IGVsZW1lbnQ7XG4gIH07XG4gIGNvbnN0IHRhcmdldCA9IGdldEVsZW1lbnQoc3RlcC50YXJnZXQpO1xuICBpZiAoIXZhbGlkYXRlU3RlcChzdGVwKSB8fCAhaXM3LmRvbUVsZW1lbnQodGFyZ2V0KSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IHRvb2x0aXAgPSAocmVuZGVyUHJvcHMpID0+IHtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeDcoXG4gICAgICBUb29sdGlwLFxuICAgICAge1xuICAgICAgICBjb250aW51b3VzLFxuICAgICAgICBoZWxwZXJzLFxuICAgICAgICBpbmRleCxcbiAgICAgICAgaXNMYXN0U3RlcDogaW5kZXggKyAxID09PSBzaXplLFxuICAgICAgICBzZXRUb29sdGlwUmVmLFxuICAgICAgICBzaXplLFxuICAgICAgICBzdGVwLFxuICAgICAgICAuLi5yZW5kZXJQcm9wc1xuICAgICAgfVxuICAgICk7XG4gIH07XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4NyhcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJyZWFjdC1qb3lyaWRlX19zdGVwXCIsIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4NyhcbiAgICBGbG9hdGVyLFxuICAgIHtcbiAgICAgIC4uLnN0ZXAuZmxvYXRlclByb3BzLFxuICAgICAgY29tcG9uZW50OiB0b29sdGlwLFxuICAgICAgZGVidWcsXG4gICAgICBnZXRQb3BwZXI6IHNldFBvcHBlcixcbiAgICAgIGlkOiBgcmVhY3Qtam95cmlkZS1zdGVwLSR7aW5kZXh9YCxcbiAgICAgIG9wZW46IGxpZmVjeWNsZSA9PT0gTElGRUNZQ0xFLlRPT0xUSVAsXG4gICAgICBwbGFjZW1lbnQ6IHN0ZXAucGxhY2VtZW50LFxuICAgICAgcG9ydGFsRWxlbWVudDogYCMke1BPUlRBTF9FTEVNRU5UX0lEfWAsXG4gICAgICB0YXJnZXQ6IHN0ZXAudGFyZ2V0LFxuICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3g3KFxuICAgICAgICBKb3lyaWRlQmVhY29uLFxuICAgICAgICB7XG4gICAgICAgICAgYmVhY29uQ29tcG9uZW50OiBzdGVwLmJlYWNvbkNvbXBvbmVudCxcbiAgICAgICAgICBjb250aW51b3VzLFxuICAgICAgICAgIGluZGV4LFxuICAgICAgICAgIGlzTGFzdFN0ZXA6IGluZGV4ICsgMSA9PT0gc2l6ZSxcbiAgICAgICAgICBsb2NhbGU6IHN0ZXAubG9jYWxlLFxuICAgICAgICAgIG5vbmNlLFxuICAgICAgICAgIG9uQ2xpY2tPckhvdmVyOiBoYW5kbGVDbGlja0hvdmVyQmVhY29uLFxuICAgICAgICAgIHNob3VsZEZvY3VzOiBzaG91bGRTY3JvbGwyLFxuICAgICAgICAgIHNpemUsXG4gICAgICAgICAgc3RlcCxcbiAgICAgICAgICBzdHlsZXM6IHN0ZXAuc3R5bGVzXG4gICAgICAgIH1cbiAgICAgIClcbiAgICB9LFxuICAgIGBKb3lyaWRlU3RlcC0ke2luZGV4fWBcbiAgKSB9KTtcbn1cblxuLy8gc3JjL2luZGV4LnRzeFxuaW1wb3J0IHsganN4IGFzIGpzeDgsIGpzeHMgYXMganN4czMgfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbmZ1bmN0aW9uIEpveXJpZGUocHJvcHMpIHtcbiAgY29uc3QgbWVyZ2VkUHJvcHMgPSBtZXJnZVByb3BzKGRlZmF1bHRQcm9wcywgcHJvcHMpO1xuICBjb25zdCB7IGNvbnRpbnVvdXMsIGRlYnVnLCBkaXNhYmxlQ2xvc2VPbkVzYywgbm9uY2UsIHBvcnRhbEVsZW1lbnQsIHNjcm9sbFRvRmlyc3RTdGVwLCBzdGVwcyB9ID0gbWVyZ2VkUHJvcHM7XG4gIGNvbnN0IHN0b3JlID0gdXNlSm95cmlkZURhdGEobWVyZ2VkUHJvcHMpO1xuICBjb25zdCBlbGVtZW50ID0gdXNlUG9ydGFsRWxlbWVudChwb3J0YWxFbGVtZW50KTtcbiAgdXNlU2luZ2xldG9uMygoKSA9PiB7XG4gICAgbG9nKHtcbiAgICAgIHRpdGxlOiBcImluaXRcIixcbiAgICAgIGRhdGE6IFtcbiAgICAgICAgeyBrZXk6IFwicHJvcHNcIiwgdmFsdWU6IHByb3BzIH0sXG4gICAgICAgIHsga2V5OiBcInN0YXRlXCIsIHZhbHVlOiBzdG9yZS5jdXJyZW50LmdldFN0YXRlKCkgfVxuICAgICAgXSxcbiAgICAgIGRlYnVnXG4gICAgfSk7XG4gIH0pO1xuICB1c2VFZmZlY3QzKCgpID0+IHtcbiAgICBjb25zdCBoYW5kbGVLZXlib2FyZCA9IChldmVudCkgPT4ge1xuICAgICAgY29uc3QgeyBpbmRleDogaW5kZXgyLCBsaWZlY3ljbGU6IGxpZmVjeWNsZTIgfSA9IHN0b3JlLmN1cnJlbnQuZ2V0U3RhdGUoKTtcbiAgICAgIGNvbnN0IHN0ZXAyID0gc3RlcHNbaW5kZXgyXTtcbiAgICAgIGlmIChsaWZlY3ljbGUyID09PSBMSUZFQ1lDTEUuVE9PTFRJUCkge1xuICAgICAgICBpZiAoZXZlbnQuY29kZSA9PT0gXCJFc2NhcGVcIiAmJiAhc3RlcDIuZGlzYWJsZUNsb3NlT25Fc2MpIHtcbiAgICAgICAgICBzdG9yZS5jdXJyZW50LmNsb3NlKFwia2V5Ym9hcmRcIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIGlmICghZGlzYWJsZUNsb3NlT25Fc2MpIHtcbiAgICAgIGRvY3VtZW50LmJvZHkuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgaGFuZGxlS2V5Ym9hcmQsIHsgcGFzc2l2ZTogdHJ1ZSB9KTtcbiAgICB9XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGlmICghZGlzYWJsZUNsb3NlT25Fc2MpIHtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBoYW5kbGVLZXlib2FyZCk7XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW2Rpc2FibGVDbG9zZU9uRXNjLCBzdGVwcywgc3RvcmVdKTtcbiAgY29uc3QgeyBpbmRleCwgbGlmZWN5Y2xlLCBzdGF0dXMgfSA9IHN0b3JlLmN1cnJlbnQuZ2V0U3RhdGUoKTtcbiAgY29uc3QgaXNSdW5uaW5nID0gc3RhdHVzID09PSBTVEFUVVMuUlVOTklORztcbiAgY29uc3QgY29udGVudCA9IHt9O1xuICBjb25zdCBzdGVwID0gdXNlTWVtbzMoKCkgPT4gZ2V0TWVyZ2VkU3RlcChwcm9wcywgc3RlcHNbaW5kZXhdKSwgW2luZGV4LCBwcm9wcywgc3RlcHNdKTtcbiAgY29uc3QgaGFuZGxlQ2xpY2tPdmVybGF5ID0gKCkgPT4ge1xuICAgIGlmICghKHN0ZXAgPT0gbnVsbCA/IHZvaWQgMCA6IHN0ZXAuZGlzYWJsZU92ZXJsYXlDbG9zZSkpIHtcbiAgICAgIHN0b3JlLmN1cnJlbnQuY2xvc2UoXCJvdmVybGF5XCIpO1xuICAgIH1cbiAgfTtcbiAgaWYgKCFzdGVwKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKGlzUnVubmluZykge1xuICAgIGNvbnRlbnQuc3RlcCA9IC8qIEBfX1BVUkVfXyAqLyBqc3g4KFxuICAgICAgSm95cmlkZVN0ZXAsXG4gICAgICB7XG4gICAgICAgIC4uLnN0b3JlLmN1cnJlbnQuZ2V0U3RhdGUoKSxcbiAgICAgICAgY2xlYW51cFBvcHBlcnM6IHN0b3JlLmN1cnJlbnQuY2xlYW51cFBvcHBlcnMsXG4gICAgICAgIGNvbnRpbnVvdXMsXG4gICAgICAgIGRlYnVnLFxuICAgICAgICBoZWxwZXJzOiBzdG9yZS5jdXJyZW50LmdldEhlbHBlcnMoKSxcbiAgICAgICAgbm9uY2UsXG4gICAgICAgIHNldFBvcHBlcjogc3RvcmUuY3VycmVudC5zZXRQb3BwZXIsXG4gICAgICAgIHNob3VsZFNjcm9sbDogIXN0ZXAuZGlzYWJsZVNjcm9sbGluZyAmJiAoaW5kZXggIT09IDAgfHwgc2Nyb2xsVG9GaXJzdFN0ZXApLFxuICAgICAgICBzdGVwLFxuICAgICAgICB1cGRhdGVTdGF0ZTogc3RvcmUuY3VycmVudC51cGRhdGVTdGF0ZVxuICAgICAgfVxuICAgICk7XG4gICAgY29udGVudC5vdmVybGF5ID0gLyogQF9fUFVSRV9fICovIGpzeDgoSm95cmlkZVBvcnRhbCwgeyBlbGVtZW50LCBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeDgoXG4gICAgICBKb3lyaWRlT3ZlcmxheSxcbiAgICAgIHtcbiAgICAgICAgLi4uc3RlcCxcbiAgICAgICAgY29udGludW91cyxcbiAgICAgICAgZGVidWcsXG4gICAgICAgIGxpZmVjeWNsZSxcbiAgICAgICAgb25DbGlja092ZXJsYXk6IGhhbmRsZUNsaWNrT3ZlcmxheVxuICAgICAgfVxuICAgICkgfSk7XG4gIH1cbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3hzMyhcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJyZWFjdC1qb3lyaWRlXCIsIGNoaWxkcmVuOiBbXG4gICAgY29udGVudC5zdGVwLFxuICAgIGNvbnRlbnQub3ZlcmxheVxuICBdIH0pO1xufVxuZnVuY3Rpb24gUmVhY3RKb3lyaWRlKHByb3BzKSB7XG4gIGlmICghY2FuVXNlRE9NKCkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeDgoSm95cmlkZSwgeyAuLi5wcm9wcyB9KTtcbn1cbmV4cG9ydCB7XG4gIEFDVElPTlMsXG4gIEVWRU5UUyxcbiAgSm95cmlkZSxcbiAgTElGRUNZQ0xFLFxuICBPUklHSU4sXG4gIFBPUlRBTF9FTEVNRU5UX0lELFxuICBTVEFUVVMsXG4gIFJlYWN0Sm95cmlkZSBhcyBkZWZhdWx0XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/react-joyride@3.0.0-7_@types+react@19.1.13_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/react-joyride/dist/index.mjs\n");

/***/ })

};
;